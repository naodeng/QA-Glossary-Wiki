# 健全性测试

<!-- TOC START -->
- [相关术语：](#相关术语：)
- [关于健全性测试的问题？](#关于健全性测试的问题？)
  - [基础知识和重要性](#基础知识和重要性)
    - [软件测试中的健全性测试是什么？](#软件测试中的健全性测试是什么？)
    - [为什么健全性测试在软件开发生命周期中很重要？](#为什么健全性测试在软件开发生命周期中很重要？)
    - [健全性测试与冒烟测试有何不同？](#健全性测试与冒烟测试有何不同？)
    - [执行健全性测试的主要好处是什么？](#执行健全性测试的主要好处是什么？)
    - [健全性测试在敏捷方法中的作用是什么？](#健全性测试在敏捷方法中的作用是什么？)
  - [流程和技术](#流程和技术)
    - [健全性测试过程涉及哪些步骤？](#健全性测试过程涉及哪些步骤？)
    - [健全性测试中常用哪些技术？](#健全性测试中常用哪些技术？)
    - [如何确定在健全性测试中要测试哪些功能？](#如何确定在健全性测试中要测试哪些功能？)
    - [健全性测试的典型持续时间是多长？](#健全性测试的典型持续时间是多长？)
    - [在持续集成环境中如何进行健全性测试？](#在持续集成环境中如何进行健全性测试？)
  - [工具和实践](#工具和实践)
    - [健全性测试常用哪些工具？](#健全性测试常用哪些工具？)
    - [如何将自动化纳入健全性测试中？](#如何将自动化纳入健全性测试中？)
    - [有效的健全性测试的最佳实践有哪些？](#有效的健全性测试的最佳实践有哪些？)
    - [健全性测试可以重复使用吗？或者它们对于每个软件版本通常都是唯一的吗？](#健全性测试可以重复使用吗？或者它们对于每个软件版本通常都是唯一的吗？)
    - [如何记录健全性测试的结果？](#如何记录健全性测试的结果？)
<!-- TOC END -->

健全性测试

，一个子集

回归测试

，确保代码修改正确运行。如果出现问题，它将停止构建。

## 相关术语：

- [Build Verification Testing](../B/build-verification-testing.md)

## 关于健全性测试的问题？

### 基础知识和重要性

#### 软件测试中的健全性测试是什么？

[Sanity testing](../S/sanity-testing.md) 是[regression testing](../R/regression-testing.md) 的子集，专注于在微小更改或[bug](../B/bug.md) 修复后验证特定功能。这是一种快速、非详尽的检查，以确保特定功能或 [bug](../B/bug.md) 在修改后按预期工作。与广泛而浅薄的冒烟测试不同，[sanity testing](../S/sanity-testing.md) 是狭窄而深入的，集中于一个或几个功能领域。
  在确定要测试的功能时，请优先考虑受最近代码更改直接影响的功能。 [Sanity testing](../S/sanity-testing.md) 通常很简短，通常在几个小时内完成，对于在敏捷等快节奏的开发环境中保持质量至关重要。
  在持续集成中，健全性测试在成功构建和冒烟测试后触发。他们充当看门人，确保在执行更严格的测试之前新的更改不会破坏关键功能。
  常见技术包括有针对性的[retesting](../R/retesting.md) 和使用[exploratory testing](../E/exploratory-testing.md) 来关注受影响的功能。虽然健全性测试可以重复使用，但它们通常需要更新以适应最新的应用程序更改。
  自动化在[sanity testing](../S/sanity-testing.md)中发挥着重要作用，可以快速执行这些重点测试。自动化健全性测试被编写成脚本，在版本控制中维护，并集成到 CI/CD 管道中。
  结果应清晰简洁地记录下来，通常记录在 [test management](../T/test-management.md) 工具中或集成到 CI/CD 报告机制中。
  最佳实践包括保持精益[test suite](../T/test-suite.md)、关注关键功能以及确保测试易于更新。 [Selenium](../S/selenium.md)、TestComplete 等工具或 Jenkins 或 CircleCI 等特定 CI 工具通常用于促进[sanity testing](../S/sanity-testing.md)。

#### 为什么健全性测试在软件开发生命周期中很重要？

[Sanity testing](../S/sanity-testing.md) 在软件开发生命周期中至关重要，因为它确保最近的更改或[bug](../B/bug.md) 修复不会对现有功能产生不利影响。它充当微小代码更改后的**快速运行状况检查**，验证特定功能或 [bug](../B/bug.md) 是否按预期工作。这种有针对性的测试方法不会[retesting](../R/retesting.md)整个应用程序，而是仅关注受影响的区域及其相关功能，从而节省了时间和资源。
  通过确认版本的核心方面正常运行，[sanity testing](../S/sanity-testing.md) 有助于维护稳定的构建并防止明显的问题传播到开发的后期阶段。当存在**频繁发布或持续部署**时，这一点尤其重要，因为它允许快速验证关键功能，而无需完整回归套件的开销。
  在**敏捷环境**中，健全性测试通常是自动化的，以便在每次[iteration](../I/iteration.md)之后立即提供有关应用程序稳定性的反馈。他们充当看门人，确保在进入更广泛的测试阶段或将构建升级到下一个环境之前最新的更改是合理的。
  [Sanity testing](../S/sanity-testing.md) 的重要性体现在它在保持对软件可靠性的高度信心方面的作用，特别是当时间限制或资源限制使得完全[regression testing](../R/regression-testing.md) 不切实际时。它可以帮助团队确定问题的优先级、简化开发流程并更快地交付高质量的软件。

#### 健全性测试与冒烟测试有何不同？

[Sanity testing](../S/sanity-testing.md) 和冒烟测试都是[acceptance testing](../A/acceptance-testing.md) 的子集，但它们具有不同的目的，并且发生在软件发布周期的不同阶段。 **冒烟测试**是一项初步测试，用于在新构建后检查应用程序的基本功能，以确保主要功能正常工作并且构建足够稳定以进行进一步测试。这就像软件的初始健康检查。
  相比之下，**[sanity testing](../S/sanity-testing.md)** 是一种更有针对性的测试形式，在收到经过微小更改或处于稳定开发阶段的软件版本后执行。它确保更新的特定问题或功能按预期工作，而无需执行详尽的测试。 [Sanity testing](../S/sanity-testing.md) 通常是无脚本的，有助于验证系统的合理性，确保建议的功能大致按预期工作。
  烟雾测试是广泛和浅的，[sanity testing](../S/sanity-testing.md) 是狭窄和深入的。烟雾测试通常是自动化的，充当进一步测试的看门人，而 [sanity testing](../S/sanity-testing.md) 可以是手动或自动的，用于在进行更改后检查特定组件。
  从本质上讲，冒烟测试询问的是“应用程序是否能广泛运行？”而[sanity testing](../S/sanity-testing.md) 则询问“最近的更改有意义并且功能正常吗？”两者在软件开发生命周期中都至关重要，但在不同的点和出于不同的原因应用。

#### 执行健全性测试的主要好处是什么？

[Sanity testing](../S/sanity-testing.md) 提供了几个主要优点：

- **快速反馈**：它可以在微小更改后立即验证核心功能，确保快速识别任何缺陷。
  - **成本效益**：通过专注于特定领域，与完整的回归测试相比，可以节省时间和资源。
  - **关注关键问题**：健全性测试集中于关键功能，这对于进一步测试或发布的决策过程至关重要。
  - **简化测试**：它简化了应用程序特定部分的评估，使其更易于执行和理解。
  - **提高质量**：定期健全性检查通过在开发的早期阶段发现问题来帮助保持产品的高质量。
  - **支持持续集成**：在 CI 环境中，可以自动运行健全性测试，以验证新代码提交没有破坏关键功能。
  [Sanity testing](../S/sanity-testing.md) 是一种战略方法，用于验证特定功能或[bug](../B/bug.md) 修复是否按预期工作。它是 [regression testing](../R/regression-testing.md) 的子集，通常用作检查点来确定应用程序是否已准备好进行进一步、更广泛的测试。通过将健全性测试纳入[test suite](../T/test-suite.md)，团队可以确保软件最关键的方面始终处于工作状态，这在频繁更改的快节奏开发环境中尤其有益。

- **快速反馈**：它可以在微小更改后立即验证核心功能，确保快速识别任何缺陷。
  - **成本效益**：通过专注于特定领域，与完整的回归测试相比，可以节省时间和资源。
  - **关注关键问题**：健全性测试集中于关键功能，这对于进一步测试或发布的决策过程至关重要。
  - **简化测试**：它简化了应用程序特定部分的评估，使其更易于执行和理解。
  - **提高质量**：定期健全性检查通过在开发的早期阶段发现问题来帮助保持产品的高质量。
  - **支持持续集成**：在 CI 环境中，可以自动运行健全性测试，以验证新代码提交没有破坏关键功能。

#### 健全性测试在敏捷方法中的作用是什么？

在敏捷方法中， **[sanity testing](../S/sanity-testing.md)** 用作重点检查，以确保特定功能或 [bug](../B/bug.md) 修复在微小更改或新版本中按预期工作。这是一种快速、狭窄的回​​归测试，用于验证代码更改没有破坏现有功能。 [Sanity testing](../S/sanity-testing.md) 通常在**冒烟测试**之后和更广泛的[regression testing](../R/regression-testing.md) 或[user acceptance testing](../U/user-acceptance-testing.md) (UAT) 之前完成。
  敏捷团队经常在持续集成和部署 (CI/CD) 期间使用健全性测试来验证最近的提交没有引入任何重大问题。这在敏捷的迭代开发周期中至关重要，因为变化频繁且快速。
  由于敏捷强调**用户满意度**和**工作软件**，[sanity testing](../S/sanity-testing.md) 通过快速确认最新的更改没有损害用户体验或核心功能来符合这些原则。它有助于为下一个 [iteration](../I/iteration.md) 开发保持稳定的产品。
  健全性测试通常是**手动**，但可以自动化以提高效率。它们通常源自与最近变化最相关的回归测试子集。虽然它们可以重复使用，但应定期对其进行审查和更新，以与不断发展的软件保持一致。
  健全性测试的**文档**应该简洁，抓住测试内容和结果的本质。该文档有助于团队内部的沟通，并作为未来测试周期的参考。
  **最佳实践**包括根据变更的影响确定测试的优先级，保持健全性测试的精简，并确保它们易于维护并适应软件中的变更。

### 流程和技术

#### 健全性测试过程涉及哪些步骤？

[Sanity testing](../S/sanity-testing.md) 涉及专注于在微小更改后验证特定功能的测试子集。以下是步骤的简要概述：

1. **识别更改的功能**：查明受最近代码更改影响的功能。
  2. **选择[Test Cases](../T/test-case.md)** ：选择涵盖受影响功能的相关测试用例。
  3. **设置[Test Environment](../T/test-environment.md)**：准备环境以反映生产设置。
  4. **执行测试**：手动或通过自动化脚本运行选定的测试用例。
  5. **分析结果**：评估测试结果以确保更改按预期工作。
  6. **报告结果**：记录任何缺陷或问题并将其传达给开发团队。
  7. **重新测试**：修复后，重新测试以确认问题已解决。
  请记住，健全性测试是快速的、有针对性的，但并不详尽。它们确保特定功能或 [bug](../B/bug.md) 修复程序可以正常工作，而不会产生意外的副作用。

1. **识别更改的功能**：查明受最近代码更改影响的功能。
  2. **选择[Test Cases](../T/test-case.md)** ：选择涵盖受影响功能的相关测试用例。
  3. **设置[Test Environment](../T/test-environment.md)**：准备环境以反映生产设置。
  4. **执行测试**：手动或通过自动化脚本运行选定的测试用例。
  5. **分析结果**：评估测试结果以确保更改按预期工作。
  6. **报告结果**：记录任何缺陷或问题并将其传达给开发团队。
  7. **重新测试**：修复后，重新测试以确认问题已解决。

#### 健全性测试中常用哪些技术？

[Sanity testing](../S/sanity-testing.md) 通常采用一组集中且狭窄的技术来验证特定功能或[bug](../B/bug.md) 修复在较小的代码更改后是否按预期工作。以下是使用的一些技术：

- **选择性[Test Case](../T/test-case.md) 执行**：运行与最近代码更改直接相关的测试用例子集。
  - **[Priority](../P/priority.md)-based 测试**：首先对关键功能执行测试，以确保它们不受最近更改的影响。
  - **[Exploratory Testing](../E/exploratory-testing.md)** ：非正式测试，测试人员在执行测试时主动控制测试的设计。
  - **重新测试全部**：在某些情况下，健全性测试可能涉及重新运行修改后的组件的所有现有测试用例，以确保没有引入新问题。
  - **[Test Case](../T/test-case.md) 采样**：选择一些代表较大测试集的测试用例来快速验证系统的运行状况。
  将自动化纳入[sanity testing](../S/sanity-testing.md) 涉及编写这些技术的脚本以自动执行：

  ```
  // Example of an automated sanity test script
  describe('Sanity Test Suite', () => {
    it('should verify critical functionality A works', () => {
      // Test steps for functionality A
    });
    it('should verify critical functionality B works', () => {
      // Test steps for functionality B
    });
    // Additional test cases...
  });
  ```自动化健全性测试通常集成到 CI/CD 管道中，以便在每次构建部署后运行。结果记录在由自动化框架或 CI 工具生成的 [test reports](../T/test-report.md) 中，然后进行审查以做出有关构建稳定性的决策。

- **选择性[Test Case](../T/test-case.md) 执行**：运行与最近代码更改直接相关的测试用例子集。
  - **[Priority](../P/priority.md)-based 测试**：首先对关键功能执行测试，以确保它们不受最近更改的影响。
  - **[Exploratory Testing](../E/exploratory-testing.md)** ：非正式测试，测试人员在执行测试时主动控制测试的设计。
  - **重新测试全部**：在某些情况下，健全性测试可能涉及重新运行修改后的组件的所有现有测试用例，以确保没有引入新问题。
  - **[Test Case](../T/test-case.md) 采样**：选择一些代表较大测试集的测试用例来快速验证系统的运行状况。

#### 如何确定在健全性测试中要测试哪些功能？

确定要在 **[sanity testing](../S/sanity-testing.md)** 中测试哪些功能涉及关注最近修改或受代码更改影响的软件的最关键方面。要选择这些功能，请考虑以下标准：

- **最近[Bug](../B/bug.md) 修复**：优先考虑最近进行错误修复的功能，以确保修复有效并且不会引入新问题。
  - **新功能**：测试对应用程序操作至关重要且最终用户可能经常使用的新功能。
  - **高风险区域**：识别应用程序中容易出错或有问题历史的区域，因为这些区域更有可能因新的更改而中断。
  - **核心功能**：专注于应用程序顺利运行所必需的核心功能，因为这里的任何问题都可能导致软件无法使用。
  - **依赖关系**：考虑对修改后的代码有依赖关系的功能，因为更改可能会对相关功能产生级联影响。
  使用基于风险的方法确定测试工作的优先级，确保覆盖最有影响力和最关键的领域。与开发人员、产品经理和其他利益相关者合作，了解变更的范围及其对应用程序的潜在影响。这种合作有助于创建一个既高效又有效的有针对性的理智[test suite](../T/test-suite.md)。

- **最近[Bug](../B/bug.md) 修复**：优先考虑最近进行错误修复的功能，以确保修复有效并且不会引入新问题。
  - **新功能**：测试对应用程序操作至关重要且最终用户可能经常使用的新功能。
  - **高风险区域**：识别应用程序中容易出错或有问题历史的区域，因为这些区域更有可能因新的更改而中断。
  - **核心功能**：专注于应用程序顺利运行所必需的核心功能，因为这里的任何问题都可能导致软件无法使用。
  - **依赖关系**：考虑对修改后的代码有依赖关系的功能，因为更改可能会对相关功能产生级联影响。

#### 健全性测试的典型持续时间是多长？

**健全性测试**的典型持续时间根据软件更改的范围和项目的规模而变化。一般来说，健全性测试很简短，通常需要 **15 分钟到几个小时** 才能执行。这些测试旨在进行快速检查，以确保最关键的功能在进行微小修改后能够按预期工作。
  由于[sanity testing](../S/sanity-testing.md) 是[regression testing](../R/regression-testing.md) 的子集，因此它侧重于特定区域而不是整个应用程序。持续时间较短，以便于向开发团队快速反馈。在**持续集成**环境中，健全性测试可能运行得更快，因为一旦新版本可用，它们就会自动执行并执行。
  对于经验丰富的[test automation](../T/test-automation.md) 工程师来说，拥有一套经过充分优化、可以自动触发的健全性测试至关重要。该套件应该简洁而全面，足以涵盖可能受最近代码更改影响的关键功能。通过并行执行和高效[test management](../T/test-management.md)实践可以进一步提高执行速度。
  请记住，[sanity testing](../S/sanity-testing.md) 的目标是快速确定进行进一步、更详尽的测试是否合理。因此，持续时间应与这一目标保持一致，确保彻底性和时间效率之间的平衡。

#### 在持续集成环境中如何进行健全性测试？

在**持续集成 (CI)** 环境中，[sanity testing](../S/sanity-testing.md) 通常是自动化的并集成到 CI 管道中。流程如下：

1. **代码提交**：开发人员将代码推送到存储库，触发 CI 管道。
  2. **构建**：CI 服务器将代码编译成可执行应用程序。
  3. **部署**：构建自动部署到测试环境。
  4. **健全性[Test Suite](../T/test-suite.md)** ：执行一组预定义的健全性测试。这些测试是回归套件的子集，重点关注关键功能。
  5. **[Test Execution](../T/test-execution.md)** ：自动化脚本运行健全性测试。这些脚本通常用高级语言编写并由测试框架管理。
  6. **结果分析**：自动收集并分析测试结果。故障会导致管道停止运行，并通知利益相关者。
  7. **反馈循环**：开发人员会立即收到有关构建健全性的反馈，以便在必要时进行快速修复。

  ```
  // Example of a sanity test script in TypeScript
  import { expect } from 'chai';
  import { login, getUserProfile } from './appActions';
  describe('Sanity Test Suite', () => {
    it('should successfully log in and retrieve user profile', async () => {
      const loginResponse = await login('user', 'password');
      expect(loginResponse).to.be.true;
      const profile = await getUserProfile();
      expect(profile).to.have.property('username');
    });
  });
  ```自动化健全性测试旨在**快速**和**集中**，提供快速检查以确保应用程序最关键的部分在每次构建后都能正常运行。结果通常会记录到 [test management](../T/test-management.md) 工具或直接记录到 CI 系统中，以便于访问和查看。

1. **代码提交**：开发人员将代码推送到存储库，触发 CI 管道。
  2. **构建**：CI 服务器将代码编译成可执行应用程序。
  3. **部署**：构建自动部署到测试环境。
  4. **健全性[Test Suite](../T/test-suite.md)** ：执行一组预定义的健全性测试。这些测试是回归套件的子集，重点关注关键功能。
  5. **[Test Execution](../T/test-execution.md)** ：自动化脚本运行健全性测试。这些脚本通常用高级语言编写并由测试框架管理。
  6. **结果分析**：自动收集并分析测试结果。故障会导致管道停止运行，并通知利益相关者。
  7. **反馈循环**：开发人员会立即收到有关构建健全性的反馈，以便在必要时进行快速修复。

### 工具和实践

#### 健全性测试常用哪些工具？

**[sanity testing](../S/sanity-testing.md)** 的常用工具包括：

- **[Selenium](../S/selenium.md)** ：支持多种语言和浏览器的流行 Web 应用程序框架。
  - **Appium** ：将 Selenium 的框架扩展到移动应用程序。
  - **TestComplete** ：为自动化测试提供用户友好的界面和脚本语言。
  - **JUnit**
    （对于 Java）和
    **[NUnit](../N/nunit.md)**
    （针对 .NET）：可适用于健全性检查的单元测试框架。

- **[Postman](../P/postman.md)** ：用于 API 健全性测试，允许快速检查 RESTful 服务。
  - **QTP/UFT**：Micro Focus 的多功能工具，用于功能和回归测试。
  - **RationalFunctionalTester**：IBM 的自动化功能和回归测试解决方案。
  - **[Cypress](../C/cypress.md)** ：专为 Web 应用程序设计的现代端到端测试框架。
  - **机器人框架**：用于验收测试和验收测试驱动开发（ATDD）的关键字驱动测试自动化框架。
  这些工具可以集成到 **CI/CD 管道**中，以便在每次构建后自动执行健全性测试。脚本通常使用该工具支持的语言编写，例如 Python、Java 或 JavaScript。

  ```
  // Example of a simple sanity check using Selenium WebDriver in JavaScript
  const { Builder, By } = require('selenium-webdriver');
  (async function example() {
      let driver = await new Builder().forBrowser('firefox').build();
      try {
          await driver.get('http://www.example.com');
          const element = await driver.findElement(By.id('important-element'));
          if (element.isDisplayed()) {
              console.log('Sanity test passed.');
          } else {
              console.log('Sanity test failed.');
          }
      } finally {
          await driver.quit();
      }
  })();
  ```[sanity testing](../S/sanity-testing.md) 的自动化脚本通常**特定于正在测试的版本**或构建，重点关注最近修改的关键功能。

- **[Selenium](../S/selenium.md)** ：支持多种语言和浏览器的流行 Web 应用程序框架。
  - **Appium** ：将 Selenium 的框架扩展到移动应用程序。
  - **TestComplete** ：为自动化测试提供用户友好的界面和脚本语言。
  - **JUnit**
    （对于 Java）和
    **[NUnit](../N/nunit.md)**
    （针对 .NET）：可适用于健全性检查的单元测试框架。

- **[Postman](../P/postman.md)** ：用于 API 健全性测试，允许快速检查 RESTful 服务。
  - **QTP/UFT**：Micro Focus 的多功能工具，用于功能和回归测试。
  - **RationalFunctionalTester**：IBM 的自动化功能和回归测试解决方案。
  - **[Cypress](../C/cypress.md)** ：专为 Web 应用程序设计的现代端到端测试框架。
  - **机器人框架**：用于验收测试和验收测试驱动开发（ATDD）的关键字驱动测试自动化框架。

#### 如何将自动化纳入健全性测试中？

将自动化纳入[sanity testing](../S/sanity-testing.md) 可以简化流程并确保关键功能在微小更改后按预期工作。要自动执行健全性测试，请按照下列步骤操作：

1. **识别关键路径**
    是稳定的并且不太可能经常改变。这些应该是您理智套件的重点。

2. **创建自动化[test scripts](../T/test-script.md)**
    对于这些关键功能，使用首选的测试自动化工具。

3. **与 CI/CD 管道集成**
    在构建后或部署到临时环境后触发健全套件。

4. 使用
    **断言**
    验证测试的预期结果。

5. **优先考虑速度和稳定性**
    在您的测试中快速评估应用程序的运行状况。

6. **维护和更新**
    根据需要调整测试套件以适应应用程序关键路径中的任何变化。

  ```
  // Example of a simple automated sanity test script
  describe('Sanity Test', () => {
    it('should login successfully with valid credentials', async () => {
      await navigateToLoginPage();
      await enterCredentials('user@example.com', 'password123');
      await submitLoginForm();
      expect(await isLoggedIn()).toBe(true);
    });
  });
  ```确保自动化健全性测试是**独立的**和**独立的**，以避免级联故障。定期**审查和完善**套件，以丢弃过时的测试并为最新功能添加新的测试。通过自动化[sanity testing](../S/sanity-testing.md)，您可以实现更快的反馈循环和更有效地利用测试资源。

1. **识别关键路径**
    是稳定的并且不太可能经常改变。这些应该是您理智套件的重点。

2. **创建自动化[test scripts](../T/test-script.md)**
    对于这些关键功能，使用首选的测试自动化工具。

3. **与 CI/CD 管道集成**
    在构建后或部署到临时环境后触发健全套件。

4. 使用
    **断言**
    验证测试的预期结果。

5. **优先考虑速度和稳定性**
    在您的测试中快速评估应用程序的运行状况。

6. **维护和更新**
    根据需要调整测试套件以适应应用程序关键路径中的任何变化。

#### 有效的健全性测试的最佳实践有哪些？

为了确保有效[sanity testing](../S/sanity-testing.md)，请遵循以下最佳实践：

- **优先考虑关键路径**
    重点关注最近发生变化的最重要的特性和功能。

- **维护清单**
    健全性测试用例，以简化流程并确保整个测试周期的一致性。

- **保持测试简单**
    并且简单明了，避免了更适合全面测试阶段的复杂场景。

- **尽可能自动化**
    加快流程并能够频繁重新运行健全性测试，尤其是在 CI/CD 管道中。

- **使用版本控制**
    让您的健全性测试脚本能够跟踪更改并促进团队成员之间的协作。

- **验证修复**
    和新功能快速确认它们按预期工作，而不会引入新问题。

- **隔离[test environment](../T/test-environment.md)**
    确保健全性测试不受外部因素影响并提供可靠的结果。

- **记录结果**
    简而言之，重点关注通过/失败状态和需要立即关注的关键观察结果。

- **有效沟通**
    与开发团队一起快速解决健全性测试期间发现的任何问题。

- **审查和更新**
    定期检查您的健全性测试套件，以反映应用程序中的更改并删除过时或冗余的测试。
  通过遵循这些实践，您可以最大限度地提高 [sanity testing](../S/sanity-testing.md) 工作的效率和效果，确保软件稳定并准备好进行进一步测试或发布。

- **优先考虑关键路径**
    重点关注最近发生变化的最重要的特性和功能。

- **维护清单**
    健全性测试用例，以简化流程并确保整个测试周期的一致性。

- **保持测试简单**
    并且简单明了，避免了更适合全面测试阶段的复杂场景。

- **尽可能自动化**
    加快流程并能够频繁重新运行健全性测试，尤其是在 CI/CD 管道中。

- **使用版本控制**
    让您的健全性测试脚本能够跟踪更改并促进团队成员之间的协作。

- **验证修复**
    和新功能快速确认它们按预期工作，而不会引入新问题。

- **隔离[test environment](../T/test-environment.md)**
    确保健全性测试不受外部因素影响并提供可靠的结果。

- **记录结果**
    简而言之，重点关注通过/失败状态和需要立即关注的关键观察结果。

- **有效沟通**
    与开发团队一起快速解决健全性测试期间发现的任何问题。

- **审查和更新**
    定期检查您的健全性测试套件，以反映应用程序中的更改并删除过时或冗余的测试。

#### 健全性测试可以重复使用吗？或者它们对于每个软件版本通常都是唯一的吗？

健全性测试通常可以在不同的软件版本之间**重用**，特别是当版本之间的更改是增量的并且不会显着影响健全性测试所涵盖的功能领域时。这些测试旨在快速评估核心功能在微小更改或 [bug](../B/bug.md) 修复后是否按预期工作。
  但是，当引入新功能或对现有功能进行重大更改时，可能需要**更新或重写**以反映新的上下文。必须审查每个版本中的更改范围并相应地调整健全性测试，以确保它们保持相关性和有效性。
  在实践中，维护**模块化和灵活** [test suite](../T/test-suite.md) 可以促进健全性测试的重用。通过设计独立且可轻松组合的测试，您可以混合搭配 [test cases](../T/test-case.md) 为每个软件版本创建适当的健全性 [test suite](../T/test-suite.md)。
  自动化在实现健全性测试的重用方面发挥着关键作用。自动化测试可以快速**适应和执行**，与[manual testing](../M/manual-testing.md) 相比节省时间和精力。保持自动化代码组织良好并使用版本控制来管理对 [test scripts](../T/test-script.md) 的更改至关重要。
  总之，虽然健全性测试可以跨软件版本重用，但应该**定期审查和更新**，以确保它们与应用程序的当前状态保持一致，并提供有关其健全性的有意义的反馈。

#### 如何记录健全性测试的结果？

记录健全性测试的结果应该**直接**和**简洁**。请遵循以下准则：

- **总结结果**：以明确的声明开始，表明健全性测试是通过还是失败。
  - **列出测试的功能**：提供已检查的特定功能的要点列表。
  - **详细失败**：对于任何失败的测试，请包括问题的简要描述、重现步骤以及任何相关的屏幕截图或错误消息。
  - **参考 [test cases](../T/test-case.md)** ：链接到用于健全性测试的详细测试用例或脚本（如果适用）。
  - **包括环境详细信息**：记下测试环境、软件版本和配置。
  - **记录[test data](../T/test-data.md)** ：提及使用的任何特定数据集，这对于重现问题至关重要。
  - **状态影响**：评估任何故障对整个系统的影响。
  - **建议**：提供立即建议或采取的行动，例如提交错误报告或停止发布。
  使用 Markdown 进行格式化：

  ```
  - **Outcome**: Passed/Failed
  - **Functionalities Tested**:
    - Login process
    - Payment gateway integration
    - New user registration
  - **Failures**:
    - Payment gateway integration: Timeout error when processing payments. Steps to reproduce: [Link to test case]. Screenshot: ![Error Screenshot](url).
  - **Environment**: Windows 10, Software v2.3.1, Test Environment B
  - **Test Data Used**: Test Credit Card #1234
  - **Impact**: Payment processing critical for release. Failure blocks release.
  - **Recommendations**: Bug reported (ID #98765), suggest rollback to previous stable version.
  ```确保文档是**最新的**并且所有相关团队成员**均可访问**。

- **总结结果**：以明确的声明开始，表明健全性测试是通过还是失败。
  - **列出测试的功能**：提供已检查的特定功能的要点列表。
  - **详细失败**：对于任何失败的测试，请包括问题的简要描述、重现步骤以及任何相关的屏幕截图或错误消息。
  - **参考 [test cases](../T/test-case.md)** ：链接到用于健全性测试的详细测试用例或脚本（如果适用）。
  - **包括环境详细信息**：记下测试环境、软件版本和配置。
  - **记录[test data](../T/test-data.md)**：提及使用的任何特定数据集，这对于重现问题至关重要。
  - **状态影响**：评估任何故障对整个系统的影响。
  - **建议**：提供立即建议或采取的行动，例如提交错误报告或停止发布。

# 模糊测试

<!-- TOC START -->
- [相关术语：](#相关术语：)
  - [另请参阅：](#另请参阅：)
- [关于模糊测试的问题？](#关于模糊测试的问题？)
  - [基础知识和重要性](#基础知识和重要性)
    - [什么是模糊测试？](#什么是模糊测试？)
    - [为什么模糊测试在软件测试中很重要？](#为什么模糊测试在软件测试中很重要？)
    - [模糊测试与其他类型的测试有何不同？](#模糊测试与其他类型的测试有何不同？)
    - [模糊测试的主要优点是什么？](#模糊测试的主要优点是什么？)
    - [模糊测试可以帮助识别哪些类型的软件错误？](#模糊测试可以帮助识别哪些类型的软件错误？)
  - [实施和技术](#实施和技术)
    - [模糊测试是如何实施的？](#模糊测试是如何实施的？)
    - [模糊测试中使用了哪些不同的技术？](#模糊测试中使用了哪些不同的技术？)
    - [基于生成和基于突变的模糊测试有什么区别？](#基于生成和基于突变的模糊测试有什么区别？)
    - [如何实现模糊测试自动化？](#如何实现模糊测试自动化？)
    - [模糊测试常用的工具有哪些？](#模糊测试常用的工具有哪些？)
  - [挑战和解决方案](#挑战和解决方案)
    - [实施模糊测试有哪些挑战？](#实施模糊测试有哪些挑战？)
    - [如何克服这些挑战？](#如何克服这些挑战？)
    - [模糊测试有哪些限制？](#模糊测试有哪些限制？)
    - [如何衡量模糊测试的有效性？](#如何衡量模糊测试的有效性？)
    - [如何将模糊测试集成到持续集成/持续部署（CI/CD）管道中？](#如何将模糊测试集成到持续集成持续部署（cicd）管道中？)
<!-- TOC END -->

（又名模糊测试）

模糊测试

是一个动态的

软件测试

涉及向系统提供随机、格式错误或意外的输入数据以识别漏洞和弱点的技术。目标是

模糊测试

是触发软件中的错误、崩溃、内存泄漏或其他不可预见的行为，然后可以对其进行分析以发现潜在的安全威胁或软件缺陷。它对于发现可能被恶意攻击利用的问题特别有效，例如缓冲区溢出或数据注入漏洞。模糊测试常用于

安全测试

并被认为是增强软件稳健性和可靠性的主动措施。

## 相关术语：

- [Security Testing](../S/security-testing.md)
- [Penetration Testing](../P/penetration-testing.md)

### 另请参阅：

- [Wikipedia](https://en.wikipedia.org/wiki/Fuzzing)

## 关于模糊测试的问题？

### 基础知识和重要性

#### 什么是模糊测试？

[Fuzz testing](../F/fuzz-testing.md)，也称为 **模糊**，是一种 [software testing](../S/software-testing.md) 技术，涉及提供无效、意外或随机数据作为计算机程序的输入。然后监视程序是否存在异常，例如崩溃、内置代码断言失败或潜在的内存泄漏。模糊测试有助于发现软件中的编码错误和安全漏洞，特别是在系统无法处理格式错误或意外输入的领域。
  为了实现[fuzz testing](../F/fuzz-testing.md)，测试人员经常使用自动化工具来生成并向系统提交各种输入。这些工具可以是：

- **基于世代**
    ，其中输入是根据被测试的协议或系统认为有效的预定义模式或模型创建的。

- **基于突变**
    ，其中以各种方式更改现有输入以生成新的测试用例。
  [fuzz testing](../F/fuzz-testing.md) 的自动化涉及编写脚本或使用现有的模糊测试框架来生成输入并执行测试，而无需手动干预。常见的模糊测试工具包括 **AFL (American Fuzzy Lop)**、**libFuzzer** 和 **Peach Fuzzer**。
  为了衡量[fuzz testing](../F/fuzz-testing.md) 的有效性，使用[code coverage](../C/code-coverage.md)、发现的[bugs](../B/bug.md) 数量以及已识别漏洞的[severity](../S/severity.md) 等指标。将 [fuzz testing](../F/fuzz-testing.md) 集成到 **CI/CD 管道** 可确保在部署之前对新代码进行漏洞测试，从而保持一致的 [software quality](../S/software-quality.md) 和安全级别。

- **基于世代**
    ，其中输入是根据被测试的协议或系统认为有效的预定义模式或模型创建的。

- **基于突变**
    ，其中以各种方式更改现有输入以生成新的测试用例。

#### 为什么模糊测试在软件测试中很重要？

[Fuzz testing](../F/fuzz-testing.md) 在[software testing](../S/software-testing.md) 中至关重要，因为它**暴露了传统测试方法可能遗漏的漏洞**，特别是在处理**意外或恶意输入**时。它可以有效地发现可能被攻击者利用的**安全缺陷**、**内存泄漏**和**导致崩溃的[bugs](../B/bug.md)**。通过自动生成[test cases](../T/test-case.md)，[fuzz testing](../F/fuzz-testing.md) 可以**模拟各种输入**，包括边缘情况，其速度是[manual testing](../M/manual-testing.md) 无法比拟的。
  此类测试对于与外部系统或不受信任的用户输入交互的应用程序尤其重要，其中稳健性和弹性至关重要。它有助于确保软件能够优雅地处理格式错误的数据，而不会影响安全性或稳定性。
  将 [fuzz testing](../F/fuzz-testing.md) 纳入开发生命周期可以实现**及早发现缺陷**，从而减少修复缺陷所需的成本和工作量。它通过关注**软件在不可预测的条件下的行为**来补充其他测试策略，从而提供对 [software quality](../S/software-quality.md) 的更全面的评估。
  此外，[fuzz testing](../F/fuzz-testing.md) 的自动化能力使其成为集成到**CI/CD 管道**的理想候选者，从而允许持续的安全性和可靠性检查。这种持续的反馈循环可以通过在问题到达生产之前及时发现和解决问题来显着增强软件的安全状况。
  总体而言，[fuzz testing](../F/fuzz-testing.md) 是 [test automation](../T/test-automation.md) 工程师的武器库中不可或缺的工具，它提供了一层防御措施，针对通常最难预测的错误类型，如果未检测到，这些错误类型的破坏性最强。

#### 模糊测试与其他类型的测试有何不同？

[Fuzz testing](../F/fuzz-testing.md)，或**模糊测试**，与其他类型的测试的不同之处主要在于其**随机、非结构化的输入生成方法**。与[unit testing](../U/unit-testing.md) 或[integration testing](../I/integration-testing.md)（使用预定义且通常有效的[test cases](../T/test-case.md)）等系统测试方法不同，模糊测试涉及使用格式错误、意外或随机的数据轰炸系统，以发现漏洞和稳定性问题。
  虽然 **[functional testing](../F/functional-testing.md)** 专注于针对定义要求的特定软件功能，但模糊测试更多的是对软件处理混沌输入的能力进行压力测试。 **[Performance testing](../P/performance-testing.md)** 测量特定工作负载下的响应时间、吞吐量和资源使用情况，而模糊测试并不关心这些指标，而是关心系统在无效或意外条件下的行为方式。
  **[Exploratory testing](../E/exploratory-testing.md)** 依靠测试人员的创造力和直觉来发现没有预定义[test cases](../T/test-case.md) 的问题，类似于模糊测试的不可预测性。然而，[exploratory testing](../E/exploratory-testing.md) 以测试人员的经验为指导，并且不是自动化的，而模糊测试是一个自动化过程，不需要太多的人工干预。
  在 **[security testing](../S/security-testing.md)** 中，[penetration testing](../P/penetration-testing.md) 是一种有针对性的方法，测试人员充当攻击者来查找安全漏洞。模糊测试通过更广泛和自动化的方法来补充这一点，通常会发现并不立即明显的安全缺陷。
  总体而言，[fuzz testing](../F/fuzz-testing.md) 的独特价值在于它能够**主动暴露**结构化测试可能会错过的根深蒂固、经常被忽视的[bugs](../B/bug.md)，使其成为综合测试策略中的重要组成部分。

#### 模糊测试的主要优点是什么？

[Fuzz testing](../F/fuzz-testing.md)，或**模糊测试**，提供了几个关键的好处：

- **发现意外漏洞**：通过生成随机、无效或意外数据作为输入，模糊测试可以揭示结构化测试可能遗漏的安全漏洞。
  - **自动错误检测**：模糊测试可以设置为自动运行，连续不断地用输入轰炸系统来查找故障，无需人工干预。
  - **压力测试软件**：它将应用程序推向极限，确保在异常条件或格式错误的输入下的稳定性。
  - **提高代码质量**：定期模糊测试鼓励开发人员编写更健壮的代码，可以处理各种输入场景。
  - **早期[bug](../B/bug.md)检测**：在开发的早期阶段实施模糊测试可以在错误变得昂贵或危险之前捕获它们。
  - **合规性和标准**：模糊测试有助于满足某些要求严格测试的行业安全标准和法规。
  - **与 CI/CD 集成**：模糊测试可以集成到 CI/CD 管道中，从而实现持续的安全性和可靠性检查。
  通过利用[fuzz testing](../F/fuzz-testing.md)，团队可以显着增强其软件的安全性和可靠性，使其成为[test automation](../T/test-automation.md) 库中的宝贵工具。

- **发现意外漏洞**：通过生成随机、无效或意外数据作为输入，模糊测试可以揭示结构化测试可能遗漏的安全漏洞。
  - **自动错误检测**：模糊测试可以设置为自动运行，连续不断地用输入轰炸系统来查找故障，无需人工干预。
  - **压力测试软件**：它将应用程序推向极限，确保在异常条件或格式错误的输入下的稳定性。
  - **提高代码质量**：定期模糊测试鼓励开发人员编写更健壮的代码，可以处理各种输入场景。
  - **早期[bug](../B/bug.md)检测**：在开发的早期阶段实施模糊测试可以在错误变得昂贵或危险之前捕获它们。
  - **合规性和标准**：模糊测试有助于满足某些要求严格测试的行业安全标准和法规。
  - **与 CI/CD 集成**：模糊测试可以集成到 CI/CD 管道中，从而实现持续的安全性和可靠性检查。

#### 模糊测试可以帮助识别哪些类型的软件错误？

[Fuzz testing](../F/fuzz-testing.md)（或模糊测试）可以有效地发现通过传统测试方法可能无法检测到的各种软件错误。它可以帮助识别：

- **缓冲区溢出**：通过输入超过分配的缓冲区大小的数据，模糊测试可以揭示可能导致崩溃或安全​​漏洞的潜在溢出。
  - **内存泄漏**：意外或随机数据可能导致应用程序在没有正确释放的情况下分配内存，从而导致模糊测试可能暴露的泄漏。
  - **未处理的异常**：模糊测试可以触发边缘情况，导致应用程序无法捕获异常，突出显示需要更好的错误处理的区域。
  - **输入验证问题**：通过使用格式错误或意外的输入，模糊测试可以揭示输入验证例程中的弱点。
  - **安全漏洞**：模糊测试可以发现各种安全漏洞，包括注入漏洞、跨站点脚本（XSS）以及依赖不当输入处理的其他漏洞。
  - **竞争条件**：通过快速改变输入，模糊测试有时会暴露竞争条件，从而导致不一致或不可预测的行为。
  - **崩溃和挂起**：模糊测试可能会导致软件崩溃或挂起，表明需要注意稳定性问题。
  如果不及时发现这些错误，可能会导致软件行为不可预测或被恶意行为者利用。模糊测试通过强制软件处理意外或错误的输入来补充其他测试策略，从而增强应用程序的稳健性和安全性。

- **缓冲区溢出**：通过输入超过分配的缓冲区大小的数据，模糊测试可以揭示可能导致崩溃或安全​​漏洞的潜在溢出。
  - **内存泄漏**：意外或随机数据可能导致应用程序在没有正确释放的情况下分配内存，从而导致模糊测试可能暴露的泄漏。
  - **未处理的异常**：模糊测试可以触发边缘情况，导致应用程序无法捕获异常，突出显示需要更好的错误处理的区域。
  - **输入验证问题**：通过使用格式错误或意外的输入，模糊测试可以揭示输入验证例程中的弱点。
  - **安全漏洞**：模糊测试可以发现各种安全漏洞，包括注入漏洞、跨站点脚本（XSS）以及依赖不当输入处理的其他漏洞。
  - **竞争条件**：通过快速改变输入，模糊测试有时会暴露竞争条件，从而导致不一致或不可预测的行为。
  - **崩溃和挂起**：模糊测试可能会导致软件崩溃或挂起，表明需要注意稳定性问题。

### 实施和技术

#### 模糊测试是如何实施的？

[Fuzz testing](../F/fuzz-testing.md) 是通过首先**选择目标系统**并识别系统处理的输入来实现的。一旦识别出输入，就会选择或开发**模糊测试工具**来生成各种格式错误或意外的输入。
  实施过程通常包括以下步骤：

1. **定义模糊测试范围**：确定将测试软件的哪些部分以及哪些类型的输入有效。
  2. **选择模糊测试技术**：根据目标系统的要求，选择基于生成的模糊测试或基于突变的模糊测试，或两者的组合。
  3. **生成[test cases](../T/test-case.md)** ：使用模糊测试工具创建大量随机或半随机输入。这可以通过自动化脚本或使用模糊测试框架来完成。
  4. **自动化执行**：设置一个测试工具，可以自动将生成的输入提供给系统并监视系统是否崩溃、挂起或其他意外行为。
  5. **监视和记录结果**：实施日志记录以捕获系统对每个输入的响应。这包括指示失败的任何异常、返回代码或系统状态。
  6. **分析故障**：调查模糊测试发现的任何问题的原因，以识别潜在的漏洞或错误。
  7. **迭代和细化**：根据分析，细化模糊测试过程，以更有效地针对特定领域或输入类型。
  为了自动化[fuzz testing](../F/fuzz-testing.md)，工程师通常将模糊测试工具集成到他们的 **CI/CD 管道**中，触发模糊测试在新代码提交上运行或作为预定测试周期的一部分运行。这确保了持续的反馈并允许及时识别和解决问题。

1. **定义模糊测试范围**：确定将测试软件的哪些部分以及哪些类型的输入有效。
  2. **选择模糊测试技术**：根据目标系统的要求，选择基于生成的模糊测试或基于突变的模糊测试，或两者的组合。
  3. **生成[test cases](../T/test-case.md)** ：使用模糊测试工具创建大量随机或半随机输入。这可以通过自动化脚本或使用模糊测试框架来完成。
  4. **自动化执行**：设置一个测试工具，可以自动将生成的输入提供给系统并监视系统是否崩溃、挂起或其他意外行为。
  5. **监视和记录结果**：实施日志记录以捕获系统对每个输入的响应。这包括指示失败的任何异常、返回代码或系统状态。
  6. **分析故障**：调查模糊测试发现的任何问题的原因，以识别潜在的漏洞或错误。
  7. **迭代和细化**：根据分析，细化模糊测试过程，以更有效地针对特定领域或输入类型。

#### 模糊测试中使用了哪些不同的技术？

[Fuzz testing](../F/fuzz-testing.md) 技术各不相同，以覆盖广泛的输入场景并发现不同类型的漏洞。以下是使用的一些技术：

- **智能模糊测试**：也称为“智能模糊测试”，它了解输入的结构并创建[test cases](../T/test-case.md)，通过尊重输入规范或使用启发式更有可能发现问题。
  - **哑模糊测试**：在不了解软件输入规范的情况下随机生成输入。这是一种简单的方法，却可以惊人地发现重大缺陷。
  - **基于协议的模糊测试**：针对特定的通信协议。它对于测试使用明确定义的协议进行通信的网络服务和应用程序非常有用。
  - **文件格式模糊测试**：专注于生成或修改应用程序读取的文件，以测试软件处理各种文件格式（尤其是格式错误的文件格式）的效果。
  - **基于语法的模糊测试**：使用形式语法生成[test cases](../T/test-case.md)，这对于测试处理结构化输入的应用程序（例如编译器或解释器）特别有效。
  - **进化模糊**：应用遗传算法随着时间的推移进化[test cases](../T/test-case.md)，旨在最大化[code coverage](../C/code-coverage.md)或找到更复杂的[bugs](../B/bug.md)。
  - **内存中模糊测试**：直接在应用程序的内存空间中执行，允许快速执行并能够模糊不接受文件或网络输入的目标。
  每种技术都有其优点，并且是根据目标应用程序、预期漏洞的类型以及可用于测试的资源来选择的。结合多种技术通常会产生最佳结果，涵盖更广泛的潜在问题。

- **智能模糊测试**：也称为“智能模糊测试”，它了解输入的结构并创建[test cases](../T/test-case.md)，通过尊重输入规范或使用启发式更有可能发现问题。
  - **哑模糊测试**：在不了解软件输入规范的情况下随机生成输入。这是一种简单的方法，却可以惊人地发现重大缺陷。
  - **基于协议的模糊测试**：针对特定的通信协议。它对于测试使用明确定义的协议进行通信的网络服务和应用程序非常有用。
  - **文件格式模糊测试**：专注于生成或修改应用程序读取的文件，以测试软件处理各种文件格式（尤其是格式错误的文件格式）的效果。
  - **基于语法的模糊测试**：使用形式语法生成[test cases](../T/test-case.md)，这对于测试处理结构化输入的应用程序（例如编译器或解释器）特别有效。
  - **进化模糊**：应用遗传算法随着时间的推移进化[test cases](../T/test-case.md)，旨在最大化[code coverage](../C/code-coverage.md)或找到更复杂的[bugs](../B/bug.md)。
  - **内存中模糊测试**：直接在应用程序的内存空间中执行，允许快速执行并能够模糊不接受文件或网络输入的目标。

#### 基于生成和基于突变的模糊测试有什么区别？

基于生成的[fuzz testing](../F/fuzz-testing.md)涉及根据构成有效输入的模型从头开始创建输入。该方法使用有关系统规范的知识来生成结构有效但内容不同的数据，以测试软件如何处理不同的输入场景。
  相比之下，基于突变的 [fuzz testing](../F/fuzz-testing.md) 从现有输入开始，通常从现实世界的使用或 [test cases](../T/test-case.md) 中捕获，并对它们进行随机更改。这些突变可以像翻转位一样简单，也可以像插入或删除数据块一样复杂。目的是了解软件如何对输入中的意外变化做出反应，而这些输入在结构上可能仍与有效数据相似。
  **基于生成的模糊测试**实施起来通常更加复杂，因为它需要深入了解输入域才能产生有效的[test cases](../T/test-case.md)。然而，它可以更有效地探索以前未考虑过的输入空间。
  **基于突变的模糊测试**设置起来更简单，可以快速生成大量[test cases](../T/test-case.md)。它特别擅长在处理输入时找到大部分正确但包含小错误的边缘情况。
  两种方法是互补的；基于生成的模糊测试对于针对规范进行测试非常有用，而基于突变的模糊测试擅长在处理稍微偏离规范的输入时找到[bugs](../B/bug.md)。结合这两种方法可以更彻底地检查软件如何处理各种输入场景。

#### 如何实现模糊测试自动化？

[Fuzz testing](../F/fuzz-testing.md) 可以通过将模糊测试工具集成到软件开发生命周期中（特别是在 CI/CD 管道中）来实现自动化。自动化涉及以下步骤：

1. **选择符合您的技术堆栈和测试需求的模糊测试工具**。流行的选择包括 AFL、libFuzzer 和 Peach Fuzzer。
  2. **创建模糊目标**，这是模糊器注入格式错误数据的入口点。例如，在 C++ 中：

    ```
    extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
        // Your code to be fuzzed
        return 0;
    }
    ```

3. **如果使用基于生成的模糊器，则生成初始[test cases](../T/test-case.md)**。对于基于突变的模糊器，您通常可以从一组有效输入开始。
  4. 通过脚本或 CI/CD 工具（例如 Jenkins、GitLab CI 或 GitHub Actions），**自动化执行模糊器**。这可以通过在构建管道中添加触发模糊测试过程的步骤来完成。
  5. **使用模糊器的报告机制监控和收集结果**。将这些与您的问题跟踪系统集成，以自动为检测到的异常创建票证。
  6. **自动分类**结果以过滤掉重复项和[false positives](../F/false-positive.md)。这可以使用分析模糊器输出的脚本来完成。
  7. **安排定期模糊测试运行**以确保持续测试。这可以设置为每晚作业或由特定事件触发，例如推送到特定分支。
  8. **随着应用程序的发展更新模糊词典和配置**，以保持 [test cases](../T/test-case.md) 的相关性。
  通过自动化这些步骤，[fuzz testing](../F/fuzz-testing.md) 成为开发过程中无缝且高效的一部分，有助于确保新代码在部署之前经过彻底的漏洞测试。

1. **选择符合您的技术堆栈和测试需求的模糊测试工具**。流行的选择包括 AFL、libFuzzer 和 Peach Fuzzer。
  2. **创建模糊目标**，这是模糊器注入格式错误数据的入口点。例如，在 C++ 中：

    ```
    extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
        // Your code to be fuzzed
        return 0;
    }
    ```

3. **如果使用基于生成的模糊器，则生成初始[test cases](../T/test-case.md)**。对于基于突变的模糊器，您通常可以从一组有效输入开始。
  4. 通过脚本或 CI/CD 工具（例如 Jenkins、GitLab CI 或 GitHub Actions），**自动化执行模糊器**。这可以通过在构建管道中添加触发模糊测试过程的步骤来完成。
  5. **使用模糊器的报告机制监控和收集结果**。将这些与您的问题跟踪系统集成，以自动为检测到的异常创建票证。
  6. **自动分类**结果以过滤掉重复项和[false positives](../F/false-positive.md)。这可以使用分析模糊器输出的脚本来完成。
  7. **安排定期模糊测试运行**以确保持续测试。这可以设置为每晚作业或由特定事件触发，例如推送到特定分支。
  8. **随着应用程序的发展更新模糊词典和配置**，以保持 [test cases](../T/test-case.md) 的相关性。

#### 模糊测试常用的工具有哪些？

[fuzz testing](../F/fuzz-testing.md) 的常用工具包括：

- **AFL（American Fuzzy Lop）**：一种面向安全的模糊器，采用遗传算法来增加代码覆盖率。
  - **LibFuzzer**：用于进程内、覆盖引导的模糊测试的库，特别适合复杂的 C/C++ 代码。
  - **Peach Fuzzer**：使用数据突变和生成执行安全性和可靠性测试的框架。
  - **Boofuzz**：网络协议模糊器，是 Sulley 模糊测试框架的演变。
  - **Radamsa**：一个测试用例生成器，可以以意想不到的方式改变输入，对于鲁棒性测试很有用。
  - **honggfuzz**：一种面向安全、反馈驱动的模糊器，支持硬件辅助功能，如 Intel CPU 的 PT。
  - **ClusterFuzz**：一种可扩展的模糊测试基础设施，可发现软件中的安全性和稳定性问题。
  - **OSS-Fuzz** ：Google 针对与现有 CI/CD 管道集成的开源软件的持续模糊测试服务。
  - **Fuzzilli**：一种 JavaScript 引擎模糊器，专门通过生成有效但复杂的 JavaScript 代码来测试浏览器。
  - **syzkaller** ：针对 Linux 的内核模糊器，支持其他操作系统，专注于发现内核错误。
  每个工具都有自己的优势，并且通常针对特定的测试场景或编程语言进行定制。经验丰富的[test automation](../T/test-automation.md) 工程师应根据目标应用程序的语言、代码库的复杂性以及项目的特定模糊测试需求来评估这些工具。与现有开发工作流程的集成以及自动化模糊测试过程的能力也是关键的考虑因素。

- **AFL（American Fuzzy Lop）**：一种面向安全的模糊器，采用遗传算法来增加代码覆盖率。
  - **LibFuzzer**：用于进程内、覆盖引导的模糊测试的库，特别适合复杂的 C/C++ 代码。
  - **Peach Fuzzer**：使用数据突变和生成执行安全性和可靠性测试的框架。
  - **Boofuzz**：网络协议模糊器，是 Sulley 模糊测试框架的演变。
  - **Radamsa**：一个测试用例生成器，可以以意想不到的方式改变输入，对于鲁棒性测试很有用。
  - **honggfuzz**：一种面向安全、反馈驱动的模糊器，支持硬件辅助功能，如 Intel CPU 的 PT。
  - **ClusterFuzz**：一种可扩展的模糊测试基础设施，可发现软件中的安全性和稳定性问题。
  - **OSS-Fuzz** ：Google 针对与现有 CI/CD 管道集成的开源软件的持续模糊测试服务。
  - **Fuzzilli**：一种 JavaScript 引擎模糊器，专门通过生成有效但复杂的 JavaScript 代码来测试浏览器。
  - **syzkaller** ：针对 Linux 的内核模糊器，支持其他操作系统，专注于发现内核错误。

### 挑战和解决方案

#### 实施模糊测试有哪些挑战？

实施 [fuzz testing](../F/fuzz-testing.md) 会带来一些挑战：

- **资源强度**：模糊测试可能是资源密集型的，需要大量资源
    **CPU 和内存**
    生成并运行大量测试用例。

- **[Test Case](../T/test-case.md) Generation**：制作有效的模糊器需要深入了解输入格式，以生成有意义的测试用例，从而发现细微的错误。
  - **结果解释**：分析模糊测试的输出可能很复杂。需要从真正危险的漏洞中筛选出误报和非关键问题。
  - **环境[Setup](../S/setup.md)**：模糊测试通常需要
    **专用[test environment](../T/test-environment.md)**
    可以处理被测软件的不稳定行为而不影响生产系统。

- **时间消耗**：到达深层代码路径可能非常耗时，需要模糊器运行较长时间（有时是数周或数月）才能有效。
  - **安全专业知识**：了解发现的错误的安全影响需要专业知识，这使得确定问题的优先级和解决问题变得具有挑战性。
  - **与开发流程集成**：将模糊测试集成到现有的开发工作流程（例如 CI/CD 管道）中可能并不简单，需要自定义脚本和自动化。
  为了克服这些挑战，工程师可以：

- 利用
    **基于云的资源**
    扩展模糊测试任务。

- 雇用
    **高级模糊测试工具**
    自动生成测试用例。

- 实施
    **自动分诊系统**
    对发现的结果进行分类和优先排序。

- 设置
    **隔离环境**
    使用容器或虚拟机。

- 时间表
    **长时间运行的模糊测试会话**
    非高峰时段。

- 对开发人员进行培训
    **安全实践**
    更好地理解和解决模糊测试结果。

- 将模糊测试集成到
    **CI/CD 管道**
    使用支持自动化和报告的工具。

- **资源强度**：模糊测试可能是资源密集型的，需要大量资源
    **CPU 和内存**
    生成并运行大量测试用例。

- **[Test Case](../T/test-case.md) Generation**：制作有效的模糊器需要深入了解输入格式，以生成有意义的测试用例，从而发现细微的错误。
  - **结果解释**：分析模糊测试的输出可能很复杂。需要从真正危险的漏洞中筛选出误报和非关键问题。
  - **环境[Setup](../S/setup.md)**：模糊测试通常需要
    **专用[test environment](../T/test-environment.md)**
    可以处理被测软件的不稳定行为而不影响生产系统。

- **时间消耗**：到达深层代码路径可能非常耗时，需要模糊器运行较长时间（有时是数周或数月）才能有效。
  - **安全专业知识**：了解发现的错误的安全影响需要专业知识，这使得确定问题的优先级和解决问题变得具有挑战性。
  - **与开发流程集成**：将模糊测试集成到现有的开发工作流程（例如 CI/CD 管道）中可能并不简单，需要自定义脚本和自动化。
  - 利用
    **基于云的资源**
    扩展模糊测试任务。

- 雇用
    **高级模糊测试工具**
    自动生成测试用例。

- 实施
    **自动分诊系统**
    对发现的结果进行分类和优先排序。

- 设置
    **隔离环境**
    使用容器或虚拟机。

- 时间表
    **长时间运行的模糊测试会话**
    非高峰时段。

- 对开发人员进行培训
    **安全实践**
    更好地理解和解决模糊测试结果。

- 将模糊测试集成到
    **CI/CD 管道**
    使用支持自动化和报告的工具。

#### 如何克服这些挑战？

克服[fuzz testing](../F/fuzz-testing.md) 中的挑战需要采取战略方法：

- **优先考虑[test cases](../T/test-case.md)**：首先关注最关键的领域。使用风险评估来确定应用程序的哪些部分应该彻底模糊。
  - **尽可能实现自动化**：将 [fuzz testing](../F/fuzz-testing.md) 集成到自动化 [test suites](../T/test-suite.md) 和 CI/CD 管道中，以确保定期和系统的测试。
  - **使用全面的工具**：选择提供广泛覆盖范围并支持各种协议和文件格式的模糊测试工具。 AFL、libFuzzer 和 Peach Fuzzer 等工具是流行的选择。
  - **管理[false positives](../F/false-positive.md)**：实施一个流程来快速分类和评估[fuzz testing](../F/fuzz-testing.md)的结果，以区分真实的和[false positives](../F/false-positive.md)。
  - **优化性能**：使用并行处理和分布式系统来扩展[fuzz testing](../F/fuzz-testing.md)工作并减少[test execution](../T/test-execution.md)所需的时间。
  - **利用机器学习**：一些高级模糊测试工具使用机器学习来改进[test cases](../T/test-case.md)的生成，重点关注更有可能导致失败的输入。
  - **持续学习**：随时了解最新的模糊测试技术和工具。该领域正在不断发展，新方法可以提供更好的结果。
  - **协作和分享发现**：鼓励团队内部以及与更广泛的社区共享知识，以学习他人的经验并改进[fuzz testing](../F/fuzz-testing.md) 实践。
  通过解决这些领域的问题，[test automation](../T/test-automation.md) 工程师可以提高[fuzz testing](../F/fuzz-testing.md) 在其软件开发生命周期中的效率和有效性。

- **优先考虑[test cases](../T/test-case.md)**：首先关注最关键的领域。使用风险评估来确定应用程序的哪些部分应该彻底模糊。
  - **尽可能实现自动化**：将 [fuzz testing](../F/fuzz-testing.md) 集成到自动化 [test suites](../T/test-suite.md) 和 CI/CD 管道中，以确保定期和系统的测试。
  - **使用全面的工具**：选择提供广泛覆盖范围并支持各种协议和文件格式的模糊测试工具。 AFL、libFuzzer 和 Peach Fuzzer 等工具是流行的选择。
  - **管理[false positives](../F/false-positive.md)**：实施一个流程来快速分类和评估[fuzz testing](../F/fuzz-testing.md)的结果，以区分真实的和[false positives](../F/false-positive.md)。
  - **优化性能**：使用并行处理和分布式系统来扩展[fuzz testing](../F/fuzz-testing.md)工作并减少[test execution](../T/test-execution.md)所需的时间。
  - **利用机器学习**：一些高级模糊测试工具使用机器学习来改进[test cases](../T/test-case.md)的生成，重点关注更有可能导致失败的输入。
  - **持续学习**：随时了解最新的模糊测试技术和工具。该领域正在不断发展，新方法可以提供更好的结果。
  - **协作和分享发现**：鼓励团队内部以及与更广泛的社区共享知识，以学习他人的经验并改进 [fuzz testing](../F/fuzz-testing.md) 实践。

#### 模糊测试有哪些限制？

[Fuzz testing](../F/fuzz-testing.md) 虽然功能强大，但有几个限制：

- **覆盖率**：模糊测试可能会错过需要特定条件或操作序列的逻辑缺陷或复杂错误，因为它侧重于输入验证而不是逻辑路径。
  - **资源密集型**：它会消耗大量的计算资源，特别是对于大规模或长时间运行的模糊测试活动。
  - **[False Positives](../F/false-positive.md)/Negatives** ：模糊器可能会产生需要手动验证的误报，从而增加工作量。他们还可能错过漏洞，导致错误的安全感。
  - **[Setup](../S/setup.md) 复杂性**：创建有效的模糊环境和测试用例可能很复杂，需要深入了解输入空间和目标系统。
  - **非确定性结果**：模糊测试的随机性意味着它可能不会每次都产生相同的结果，可能会丢失间歇性错误。
  - **受模糊器功能限制**：模糊测试的有效性受到模糊器本身功能的限制，例如生成或变异算法的质量。
  - **分析结果困难**：模糊测试的输出可能很难分析，特别是在处理无法提供清晰信息的崩溃或挂起时。
  为了减轻这些限制，将 [fuzz testing](../F/fuzz-testing.md) 与其他测试方法结合起来，微调模糊测试工具，并使用新的威胁模型定期更新模糊测试器的知识库非常重要。此外，将[fuzz testing](../F/fuzz-testing.md) 集成到更广泛的[security testing](../S/security-testing.md) 框架中有助于确保更全面的覆盖范围。

- **覆盖率**：模糊测试可能会错过需要特定条件或操作序列的逻辑缺陷或复杂错误，因为它侧重于输入验证而不是逻辑路径。
  - **资源密集型**：它会消耗大量的计算资源，特别是对于大规模或长时间运行的模糊测试活动。
  - **[False Positives](../F/false-positive.md)/Negatives** ：模糊器可能会产生需要手动验证的误报，从而增加工作量。他们还可能错过漏洞，导致错误的安全感。
  - **[Setup](../S/setup.md) 复杂性**：创建有效的模糊环境和测试用例可能很复杂，需要深入了解输入空间和目标系统。
  - **非确定性结果**：模糊测试的随机性意味着它可能不会每次都产生相同的结果，可能会丢失间歇性错误。
  - **受模糊器功能限制**：模糊测试的有效性受到模糊器本身功能的限制，例如生成或变异算法的质量。
  - **分析结果困难**：模糊测试的输出可能很难分析，特别是在处理无法提供清晰信息的崩溃或挂起时。

#### 如何衡量模糊测试的有效性？

[fuzz testing](../F/fuzz-testing.md) 的有效性可以通过评估几个关键指标来衡量：

- **[Code Coverage](../C/code-coverage.md)** ：量化模糊测试执行的代码路径、分支和函数的百分比。 gcov 或 lcov 等工具可用于覆盖率分析。

  ```
  gcov -b source_file.c
  ```

- **[Bug](../B/bug.md) 发现率**：跟踪随时间推移识别出的唯一的、可操作的[bugs](../B/bug.md) 的数量。比率越高表明测试越有效。
  - **发现时间**：测量从模糊测试开始到初始 [bug](../B/bug.md) 发现所需的时间。时间越短表明效率越高[test cases](../T/test-case.md)。
  - **崩溃的独特性**：评估崩溃的多样性，以确保发现广泛的问题。重复数据删除工具可以帮助识别独特的崩溃。
  - **[Severity](../S/severity.md) 漏洞**：评估所发现漏洞的严重性。使用通用漏洞评分系统 (CVSS) 评分来确定修复的优先级。
  - **[Test Case](../T/test-case.md) 最小化**：分析模糊测试过程如何将[test cases](../T/test-case.md) 最小化为仍触发[bugs](../B/bug.md) 的最简单形式，从而有助于更快地进行根本原因分析。
  - **资源利用率**：监控 CPU、内存和磁盘使用情况，以确保 [fuzz testing](../F/fuzz-testing.md) 针对可用基础设施进行优化。
  - **模糊测试活动持续时间**：考虑模糊测试活动的长度。较长的活动可能会产生更多结果，但需要平衡资源限制。
  通过跟踪这些指标，[test automation](../T/test-automation.md) 工程师可以完善他们的[fuzz testing](../F/fuzz-testing.md) 策略，更有效地分配资源，并最终提高其软件的安全性和可靠性。

- **[Code Coverage](../C/code-coverage.md)** ：量化模糊测试执行的代码路径、分支和函数的百分比。 gcov 或 lcov 等工具可用于覆盖率分析。
  - **[Bug](../B/bug.md) 发现率**：跟踪随时间推移识别出的唯一的、可操作的[bugs](../B/bug.md) 的数量。比率越高表明测试越有效。
  - **发现时间**：测量从模糊测试开始到初始 [bug](../B/bug.md) 发现所需的时间。时间越短表明效率越高[test cases](../T/test-case.md)。
  - **崩溃的独特性**：评估崩溃的多样性，以确保发现广泛的问题。重复数据删除工具可以帮助识别独特的崩溃。
  - **[Severity](../S/severity.md) 漏洞**：评估所发现漏洞的严重性。使用通用漏洞评分系统 (CVSS) 评分来确定修复的优先级。
  - **[Test Case](../T/test-case.md) 最小化**：分析模糊测试过程如何将 [test cases](../T/test-case.md) 最小化为仍触发 [bugs](../B/bug.md) 的最简单形式，从而有助于更快地进行根本原因分析。
  - **资源利用率**：监控 CPU、内存和磁盘使用情况，以确保 [fuzz testing](../F/fuzz-testing.md) 针对可用基础设施进行优化。
  - **模糊测试活动持续时间**：考虑模糊测试活动的长度。较长的活动可能会产生更多结果，但需要平衡资源限制。

#### 如何将模糊测试集成到持续集成/持续部署（CI/CD）管道中？

将 [fuzz testing](../F/fuzz-testing.md) 集成到 **CI/CD 管道** 涉及设置自动模糊测试以作为构建和部署过程的一部分运行。这是一个简洁的指南：

1. **选择与您的 CI/CD 系统集成的模糊测试工具**。 AFL、libFuzzer 或 OSS-Fuzz 等工具提供[APIs](../A/api.md) 和用于自动化的命令行界面。
  2. **创建模糊测试目标**：专门为模糊测试工具编写[test cases](../T/test-case.md)作为起点。
  3. **自动化构建过程**：确保您的构建系统使用所选模糊工具所需的工具来编译模糊目标。
  4. **配置管道**：
    - 在 CI/CD 管道中添加一个触发模糊测试的阶段。
    - 使用脚本或管道配置针对目标运行模糊测试工具。
    - 设置合理的时间或迭代限制以确保管道效率。
    - 在 CI/CD 管道中添加一个触发模糊测试的阶段。
    - 使用脚本或管道配置针对目标运行模糊测试工具。
    - 设置合理的时间或迭代限制以确保管道效率。
  5. **处理结果**：
    - 收集并分析模糊测试工具的输出。
    - 自动记录检测到的崩溃和故障的错误或问题。
    - 设置重要发现的通知。
    - 收集并分析模糊测试工具的输出。
    - 自动记录检测到的崩溃和故障的错误或问题。
    - 设置重要发现的通知。
  6. **优化**：
    - 使用涵盖最近代码更改的新输入定期更新您的模糊测试语料库。
    - 监控模糊测试的性能和有效性，根据需要调整配置。
    - 使用涵盖最近代码更改的新输入定期更新您的模糊测试语料库。
    - 监控模糊测试的性能和有效性，根据需要调整配置。
  7. **安全和覆盖范围检查**：
    - 集成安全分析工具以进一步分析模糊测试产生的崩溃。
    - 使用覆盖工具来确保测试广泛的输入空间。
    - 集成安全分析工具以进一步分析模糊测试产生的崩溃。
    - 使用覆盖工具来确保测试广泛的输入空间。
  通过遵循这些步骤，[fuzz testing](../F/fuzz-testing.md) 成为开发生命周期的无缝部分，有助于及早发现和解决问题并维护[software quality](../S/software-quality.md)。

1. **选择与您的 CI/CD 系统集成的模糊测试工具**。 AFL、libFuzzer 或 OSS-Fuzz 等工具提供[APIs](../A/api.md) 和用于自动化的命令行界面。
  2. **创建模糊测试目标**：专门为模糊测试工具编写[test cases](../T/test-case.md)作为起点。
  3. **自动化构建过程**：确保您的构建系统使用所选模糊工具所需的工具来编译模糊目标。
  4. **配置管道**：
    - 在 CI/CD 管道中添加一个触发模糊测试的阶段。
    - 使用脚本或管道配置针对目标运行模糊测试工具。
    - 设置合理的时间或迭代限制以确保管道效率。
    - 在 CI/CD 管道中添加一个触发模糊测试的阶段。
    - 使用脚本或管道配置针对目标运行模糊测试工具。
    - 设置合理的时间或迭代限制以确保管道效率。
  5. **处理结果**：
    - 收集并分析模糊测试工具的输出。
    - 自动记录检测到的崩溃和故障的错误或问题。
    - 设置重要发现的通知。
    - 收集并分析模糊测试工具的输出。
    - 自动记录检测到的崩溃和故障的错误或问题。
    - 设置重要发现的通知。
  6. **优化**：
    - 使用涵盖最近代码更改的新输入定期更新您的模糊测试语料库。
    - 监控模糊测试的性能和有效性，根据需要调整配置。
    - 使用涵盖最近代码更改的新输入定期更新您的模糊测试语料库。
    - 监控模糊测试的性能和有效性，根据需要调整配置。
  7. **安全和覆盖范围检查**：
    - 集成安全分析工具以进一步分析模糊测试产生的崩溃。
    - 使用覆盖工具来确保测试广泛的输入空间。
    - 集成安全分析工具以进一步分析模糊测试产生的崩溃。
    - 使用覆盖工具来确保测试广泛的输入空间。

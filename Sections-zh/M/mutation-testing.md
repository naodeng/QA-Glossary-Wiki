# 变异测试 (Mutation Testing)
[Mutation Testing](#mutation-testing) [变异测试 (Mutation Testing)](/wiki/mutation-testing)

## 关于变异测试的常见问题

#### 基础与重要性
- **什么是软件测试中的变异测试？**
  **变异测试 (Mutation Testing)** 是一种通过向程序源代码引入微小修改（即“变异”）来评估软件测试质量的技术。其核心前提是：一个稳健的**测试套件 (Test Suite)** 应该能发现代码中被人为引入的 **Bug**。
  - **变异体 (Mutants)**：代码的修改版本。
  - **杀死变异体 (Kill a mutant)**：如果测试在变异代码上失败，说明变异体被识别并“杀死”。
  - **存活变异体 (Surviving mutant)**：如果所有测试都通过，说明变异体“存活”，暗示测试套件存在缺陷。
  **变异得分 (Mutation Score)**（杀死的变异体数 / 总变异体数）是衡量测试套件强度的定量指标。

- **为什么变异测试很重要？**
  变异测试能对测试套件的有效性进行**深度且严谨的评估**。它衡量的是**测试本身的质量**，而不仅仅是代码覆盖的数量。
  - **揭示弱点**：发现其他测试方法可能遗漏的覆盖漏洞。
  - **提升稳健性**：迫使编写更敏感、更高质量的测试用例。
  - **持续改进**：通过反馈循环指导开发者优化测试策略，确保系统可靠性。

- **变异测试与其他测试有何不同？**
  传统测试（如单元、集成、系统测试）关注的是测试用例能否发现既有错误。而**变异测试**关注的是测试套件识别“人为制造的新错误”的能力。这是一种**白盒测试 (White-box Testing)** 形式，不仅验证软件是否按预期运行，更验证了测试发现错误的能力。

- **变异测试的优点**：
  识别测试套件的薄弱点、提供定量衡量指标、针对边缘情况设计测试、在 **TDD** 环境中驱动开发、增进对代码的理解并鼓励代码重构。

- **变异测试的局限性**：
  计算成本高（对大型代码库极其耗资源）、**等效变异体 (Equivalent Mutants)**（修改后行为与原版一致，无法通过测试杀死，需人工识别）、过程耗时（可能不适用于每次 CI 构建）、学习曲线较陡。

#### 概念与技术
- **核心概念**：
  涉及到通过**变异算子 (Mutation Operators)** 生成变异体，计算变异得分，并采用**选择性变异 (Selective Mutation)**、**采样 (Mutant Sampling)** 和**并行执行**来降低成本。

- **什么是变异体？**
  它们是通过变异算子修改后的代码版本，模拟常见的编程错误。例如，将 `number % 2 === 0` 改为 `number % 2 !== 0`。稳健的测试应该能让这个变异版本运行失败。

- **变异得分及其计算**：
  `变异得分 = (被杀死的变异体数 / (总变异体数 - 等效变异体数)) * 100`
  得分越高，测试套件效能越强。

- **变异算子的类型**：
  - **算术运算符替换 (AOR)**：如 `+` 变 `-`。
  - **关系运算符替换 (ROR)**：如 `>` 变 `>=`。
  - **逻辑运算符替换 (LOR)**：如 `&&` 变 `||`。
  - **条件运算符替换 (COR)**、**语句删除 (STD)**、**变量替换 (VR)**、**边界值更改 (BVC)** 等。

- **降低成本的技术**：
  包括选择性变异、变异采样、等效变异体自动检测、提高执行并行度、增量变异测试（仅针对修改代码）以及在 CI 流水线中错峰运行。

#### 实现与工具
- **实施步骤**：
  1. 选择目标。
  2. 生成变异体。
  3. 运行测试套件。
  4. 确定存活情况。
  5. 分析结果。
  6. 改进测试。
  7. 迭代直到获得满意的得分。

- **常用工具**：
  - **PIT (Pitest)**：Java 的主流工具，与 Maven/Ant 集成良好。
  - **Stryker**：适用于 JS/TS 和 .NET，框架无关且稳健。
  - **MutPy**：Python 变异测试工具。
  - **Infection / Humbug**：PHP 适用。
  - **Mull**：基于 LLVM，适用于 C/C++。

- **如何在 CI 环境中实施变异测试？**
  选择与技术栈兼容的工具，将其整合进构建流水线。设置变异得分阈值（如低于 75% 报错），并优化执行范围（如仅针对核心代码）以兼顾构建时间与质量。

- **最佳实践**：
  优先处理关键代码、由小及大应用、自动化流程、设置合理的阈值（不必追求 100%）、并在团队中普及变异测试的意义。

#### 高级话题
- **高阶变异测试 (Higher Order Mutation Testing)**：
  一种更高级的形式，每次将**多个变异结合**产生一个变异体。这能模拟更复杂的现实错误，并有助于减少等效和琐碎变异体的问题，但计算成本极高。

- **大规模代码库的挑战**：
  面临资源消耗大、执行效率低、变异体规模爆炸、数据管理困难等挑战。通常需要采用增量变异和并行化策略。

- **最新进展**：
  与现代 IDE 深度集成、性能优化（增量化/并行化）、智能变异生成（利用 AI/机器学习）、针对非功能性属性（如安全/性能）的变异扩展、以及基于云的变异测试服务。

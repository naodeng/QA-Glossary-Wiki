# 手动测试

<!-- TOC START -->
- [相关术语：](#相关术语：)
- [有关手动测试的问题吗？](#有关手动测试的问题吗？)
  - [基础知识和重要性](#基础知识和重要性)
    - [什么是手动测试？](#什么是手动测试？)
    - [为什么手动测试很重要？](#为什么手动测试很重要？)
    - [手动测试和自动化测试之间的主要区别是什么？](#手动测试和自动化测试之间的主要区别是什么？)
    - [手动测试的优点和缺点是什么？](#手动测试的优点和缺点是什么？)
    - [手动测试的关键原则是什么？](#手动测试的关键原则是什么？)
  - [手动测试的类型](#手动测试的类型)
    - [手动测试有哪些不同类型？](#手动测试有哪些不同类型？)
    - [什么是黑盒测试？](#什么是黑盒测试？)
    - [什么是白盒测试？](#什么是白盒测试？)
    - [什么是灰盒测试？](#什么是灰盒测试？)
    - [功能测试和非功能测试有什么区别？](#功能测试和非功能测试有什么区别？)
  - [手动测试过程](#手动测试过程)
    - [手动测试生命周期有哪些阶段？](#手动测试生命周期有哪些阶段？)
    - [什么是测试计划以及它涉及什么？](#什么是测试计划以及它涉及什么？)
    - [什么是测试执行以及涉及哪些步骤？](#什么是测试执行以及涉及哪些步骤？)
    - [什么是测试收敛以及它涉及什么？](#什么是测试收敛以及它涉及什么？)
  - [手动测试工具](#手动测试工具)
    - [手动测试使用哪些工具？](#手动测试使用哪些工具？)
    - [测试管理工具在手动测试中的作用是什么？](#测试管理工具在手动测试中的作用是什么？)
    - [缺陷跟踪工具在手动测试中的作用是什么？](#缺陷跟踪工具在手动测试中的作用是什么？)
    - [手动测试工具有哪些示例？](#手动测试工具有哪些示例？)
  - [手动测试最佳实践](#手动测试最佳实践)
    - [手动测试的最佳实践有哪些？](#手动测试的最佳实践有哪些？)
    - [如何使手动测试更加有效？](#如何使手动测试更加有效？)
    - [手动测试中需要避免哪些常见错误？](#手动测试中需要避免哪些常见错误？)
<!-- TOC END -->

手动测试

是根据预期结果手动检查软件功能的过程。

## 相关术语：

- [Automated Testing](../A/automated-testing.md)
- [Test Automation](../T/test-automation.md)

## 有关手动测试的问题吗？

### 基础知识和重要性

#### 什么是手动测试？

[Manual testing](../M/manual-testing.md) 是在不使用自动化工具的情况下手动执行[test cases](../T/test-case.md) 的过程。测试人员通过遵循一组预定义的 [test cases](../T/test-case.md) 来执行此类测试，以确保软件按预期运行。它涉及测试人员与应用程序的界面交互、提供输入并观察输出以验证应用程序行为的正确性。
  由于[manual testing](../M/manual-testing.md) 依赖于人类观察，因此它对于检测可用性问题、了解用户体验以及发现自动化测试可能遗漏的意外行为特别有用。测试人员利用他们的直觉、经验和对软件的理解来探索功能并报告与[expected results](../E/expected-result.md) 的任何差异。
  在[manual testing](../M/manual-testing.md) 中，测试人员充当最终用户并验证应用程序的所有功能是否正常工作。它通常用于[exploratory testing](../E/exploratory-testing.md)、临时测试和[usability testing](../U/usability-testing.md)，其中测试人员的创造力和洞察力至关重要。
  尽管[automated testing](../A/automated-testing.md) 兴起，[manual testing](../M/manual-testing.md) 仍然是软件开发生命周期中不可或缺的一部分，特别是对于难以自动化或需要人工判断的场景。它允许采用更灵活和交互式的测试方法，这在开发的早期阶段以及对于运行频率不足以保证自动化的测试至关重要。

#### 为什么手动测试很重要？

尽管 [test automation](../T/test-automation.md) 取得了进步，但由于以下几个原因，[Manual testing](../M/manual-testing.md) 仍然至关重要：

- **[Exploratory Testing](../E/exploratory-testing.md)** ：它允许测试人员执行探索性测试，他们可以利用自己的直觉和经验来发现脚本测试可能无法捕获的问题。
  - **用户体验**：手动测试对于评估用户体验至关重要，确保软件直观且用户友好。
  - **复杂场景**：一些测试，尤其是那些涉及复杂用户交互或不确定环境的测试，很难自动化，更适合手动执行。
  - **初始开发阶段**：在开发的早期阶段，当功能仍在不断发展时，手动测试可能比尝试为快速变化的代码库维护自动化测试更有效。
  - **成本效益**：对于小型项目或某些测试的频率较低时，手动测试可能比自动化所需的初始投资更具成本效益。
  - **学习和反馈**：手动测试提供有关应用程序的即时反馈和学习机会，这对于新团队成员或熟悉新功能时非常宝贵。
  从本质上讲，[manual testing](../M/manual-testing.md) 通过涵盖不易量化或自动化的方面来补充[automated testing](../A/automated-testing.md)，提供对于提供高质量用户体验至关重要的人性化视角。

- **[Exploratory Testing](../E/exploratory-testing.md)** ：它允许测试人员执行探索性测试，他们可以利用自己的直觉和经验来发现脚本测试可能无法捕获的问题。
  - **用户体验**：手动测试对于评估用户体验至关重要，确保软件直观且用户友好。
  - **复杂场景**：一些测试，尤其是那些涉及复杂用户交互或不确定环境的测试，很难自动化，更适合手动执行。
  - **初始开发阶段**：在开发的早期阶段，当功能仍在不断发展时，手动测试可能比尝试为快速变化的代码库维护自动化测试更有效。
  - **成本效益**：对于小型项目或某些测试的频率较低时，手动测试可能比自动化所需的初始投资更具成本效益。
  - **学习和反馈**：手动测试提供有关应用程序的即时反馈和学习机会，这对于新团队成员或熟悉新功能时非常宝贵。

#### 手动测试和自动化测试之间的主要区别是什么？

[Manual testing](../M/manual-testing.md) 涉及人类测试人员在没有工具或脚本帮助的情况下执行[test cases](../T/test-case.md)。另一方面，[Automated testing](../A/automated-testing.md) 依赖于自动运行的预先编写的测试来将实际结果与预测结果进行比较。
  主要区别包括：

- **速度**：自动化测试的运行速度比手动测试快得多。
  - **可重复性**：自动化测试可以以一致的精度重复运行，而手动测试可能会因人为错误或测试人员焦点的变化而有所不同。
  - **成本**：手动测试需要较少的前期投资，但从长远来看，由于其耗时的性质，成本可能会更高。自动化测试需要对工具和脚本开发进行更高的初始投资，但随着时间的推移会变得更具成本效益。
  - **复杂性**：自动化测试可以比手动测试更有效地处理复杂的测试用例。
  - **[Test Coverage](../T/test-coverage.md)** ：自动化测试可以在短时间内执行大量测试，从而增加测试覆盖率。
  - **可靠性**：自动化测试消除人为错误，提供更可靠的结果。
  - **维护**：自动化测试脚本需要维护以适应应用程序的变化，而手动测试用例可能更灵活地适应变化。
  - **反馈**：自动化测试由于其快速执行，可以为开发人员提供快速反馈。
  - **技能**：自动化测试需要测试人员具备编程知识来编写测试脚本，而手动测试则依赖于分析和探索技能。
  总之，[automated testing](../A/automated-testing.md) 提供速度、可重复性和可靠性，而[manual testing](../M/manual-testing.md) 提供灵活性并且执行时需要较少的技术技能。

- **速度**：自动化测试的运行速度比手动测试快得多。
  - **可重复性**：自动化测试可以以一致的精度重复运行，而手动测试可能会因人为错误或测试人员焦点的变化而有所不同。
  - **成本**：手动测试需要较少的前期投资，但从长远来看，由于其耗时的性质，成本可能会更高。自动化测试需要对工具和脚本开发进行更高的初始投资，但随着时间的推移会变得更具成本效益。
  - **复杂性**：自动化测试可以比手动测试更有效地处理复杂的测试用例。
  - **[Test Coverage](../T/test-coverage.md)** ：自动化测试可以在短时间内执行大量测试，从而增加测试覆盖率。
  - **可靠性**：自动化测试消除人为错误，提供更可靠的结果。
  - **维护**：自动化测试脚本需要维护以适应应用程序的变化，而手动测试用例可能更灵活地适应变化。
  - **反馈**：自动化测试由于其快速执行，可以为开发人员提供快速反馈。
  - **技能**：自动化测试需要测试人员具备编程知识来编写测试脚本，而手动测试则依赖于分析和探索技能。

#### 手动测试的优点和缺点是什么？

[manual testing](../M/manual-testing.md)的优点：

- **灵活性**：手动测试允许在测试人员探索软件并与软件交互时进行即时调整。
  - **人类洞察**：测试人员可以利用他们的直觉和经验来识别自动化测试可能遗漏的问题，例如微妙的 UI 不一致或复杂的用户体验问题。
  - **不需要脚本**：不需要编写测试脚本，这对于探索性测试或应用程序处于开发的早期阶段时是有益的。
  - **小型项目的成本效益**：对于范围有限的小型项目，手动测试比设置自动化测试环境更具成本效益。
  [manual testing](../M/manual-testing.md) 的缺点：

- **耗时**：手动测试需要更多时间来执行，因为每个步骤都需要人工干预。
  - **不太可靠**：人类很容易出错，由于疲劳或疏忽等因素，导致测试结果不一致。
  - **不可扩展**：随着应用程序的增长，手动测试工作量会成倍增加，使得在紧迫的期限内管理和执行变得困难。
  - **覆盖范围有限**：手动执行大量场景复杂的测试用例是不切实际的，导致测试覆盖范围有限。
  - **没有可重用性**：测试用例每次都需要从头开始执行，而不是可以多次运行且几乎不需要额外成本的自动化测试。
  - **反馈缓慢**：手动执行测试所需的时间延迟了向开​​发人员的反馈，可能会减慢开发周期。
  - **灵活性**：手动测试允许在测试人员探索软件并与软件交互时进行即时调整。
  - **人类洞察**：测试人员可以利用他们的直觉和经验来识别自动化测试可能遗漏的问题，例如微妙的 UI 不一致或复杂的用户体验问题。
  - **不需要脚本**：不需要编写测试脚本，这对于探索性测试或应用程序处于开发的早期阶段时是有益的。
  - **小型项目的成本效益**：对于范围有限的小型项目，手动测试比设置自动化测试环境更具成本效益。
  - **耗时**：手动测试需要更多时间来执行，因为每个步骤都需要人工干预。
  - **不太可靠**：人类很容易出错，由于疲劳或疏忽等因素，导致测试结果不一致。
  - **不可扩展**：随着应用程序的增长，手动测试工作量会成倍增加，使得在紧迫的期限内管理和执行变得困难。
  - **覆盖范围有限**：手动执行大量场景复杂的测试用例是不切实际的，导致测试覆盖范围有限。
  - **没有可重用性**：测试用例每次都需要从头开始执行，而不是可以多次运行且几乎不需要额外成本的自动化测试。
  - **反馈缓慢**：手动执行测试所需的时间延迟了向开​​发人员的反馈，可能会减慢开发周期。

#### 手动测试的关键原则是什么？

[manual testing](../M/manual-testing.md) 的关键原则围绕测试人员的专业知识、直觉和对用户体验的理解。 **关注细节**至关重要，因为测试人员必须仔细探索应用程序并与应用程序交互以识别潜在问题。 **了解最终用户的观点**至关重要，因为[manual testing](../M/manual-testing.md) 旨在确保软件直观并满足用户要求。
  **[Test coverage](../T/test-coverage.md)** 是另一个原则，测试人员必须确保所有特性和功能都经过彻底检查。这包括执行 **[exploratory testing](../E/exploratory-testing.md)**，它依赖于测试人员的创造力和经验来发现预定义的 [test cases](../T/test-case.md) 可能无法涵盖的缺陷。
  **文档**发挥着重要作用，测试人员需要维护[test cases](../T/test-case.md)、执行结果和缺陷报告的清晰简洁的记录。这有助于确保测试的**可重复性**，并促进与其他团队成员的沟通。
  **灵活性**至关重要，因为手动测试人员必须能够调整其测试方法，以响应应用程序或其环境中的新见解和变化。这包括接受**反馈**并将其纳入测试过程。
  最后，**批判性思维**和**解决问题的能力**至关重要，因为手动测试人员通常需要确定缺陷的根本原因并了解其对系统的潜在影响。测试人员必须能够超越显而易见的想法并预测各种场景中的用户行为。

### 手动测试的类型

#### 手动测试有哪些不同类型？

不同类型的 [manual testing](../M/manual-testing.md) 包括：

- **[Exploratory Testing](../E/exploratory-testing.md)** ：测试人员在没有预定义测试用例的情况下，依靠他们的经验和直觉探索软件来识别缺陷。
  - **临时测试**：与探索性测试类似，但更加随机和非结构化，侧重于以不太系统的方式发现缺陷。
  - **[Usability Testing](../U/usability-testing.md)** ：通过观察真实用户与应用程序交互时评估用户界面和用户体验。
  - **[Accessibility Testing](../A/accessibility-testing.md)** ：确保软件可供残疾人使用，检查是否符合辅助功能标准。
  - **[Compatibility Testing](../C/compatibility-testing.md)** ：验证软件在不同设备、操作系统、浏览器和网络上是否按预期工作。
  - **[Performance Testing](../P/performance-testing.md)** ：评估软件在各种条件下的响应能力、稳定性、可扩展性和速度。
  - **[Load Testing](../L/load-testing.md)** ：性能测试的子集，用于检查系统在预期负载条件下的行为。
  - **[Stress Testing](../S/stress-testing.md)** ：性能测试的另一个子集，其中系统被推到其正常运行能力之外，以了解它如何处理极端条件。
  - **冒烟测试**：检查应用程序基本功能的初步测试，通常在新构建或发布后执行。
  - **[Sanity Testing](../S/sanity-testing.md)** ：一种集中测试形式，用于验证特定功能或错误修复是否按预期工作。
  - **[Regression Testing](../R/regression-testing.md)** ：确保新代码更改不会对现有功能产生不利影响。
  - **[Acceptance Testing](../A/acceptance-testing.md)** ：确定软件是否满足业务要求并准备好部署，通常由最终用户执行。
  - **[Alpha Testing](../A/alpha-testing.md)** ：在将产品发布给真实用户之前在内部进行以确定所有可能的问题。
  - **[Beta Testing](../B/beta-testing.md)** ：由真实用户在真实环境中执行，以在最终发布之前提供有关产品质量的反馈。
  - **[Exploratory Testing](../E/exploratory-testing.md)** ：测试人员在没有预定义测试用例的情况下，依靠他们的经验和直觉探索软件来识别缺陷。
  - **临时测试**：与探索性测试类似，但更加随机和非结构化，侧重于以不太系统的方式发现缺陷。
  - **[Usability Testing](../U/usability-testing.md)** ：通过观察真实用户与应用程序交互时评估用户界面和用户体验。
  - **[Accessibility Testing](../A/accessibility-testing.md)** ：确保软件可供残疾人使用，检查是否符合无障碍标准。
  - **[Compatibility Testing](../C/compatibility-testing.md)** ：验证软件在不同设备、操作系统、浏览器和网络上是否按预期工作。
  - **[Performance Testing](../P/performance-testing.md)** ：评估软件在各种条件下的响应能力、稳定性、可扩展性和速度。
  - **[Load Testing](../L/load-testing.md)** ：性能测试的子集，用于检查系统在预期负载条件下的行为。
  - **[Stress Testing](../S/stress-testing.md)** ：性能测试的另一个子集，其中系统被推到其正常运行能力之外，以了解它如何处理极端条件。
  - **冒烟测试**：检查应用程序基本功能的初步测试，通常在新构建或发布后执行。
  - **[Sanity Testing](../S/sanity-testing.md)** ：一种集中测试形式，用于验证特定功能或错误修复是否按预期工作。
  - **[Regression Testing](../R/regression-testing.md)** ：确保新代码更改不会对现有功能产生不利影响。
  - **[Acceptance Testing](../A/acceptance-testing.md)** ：确定软件是否满足业务要求并准备好部署，通常由最终用户执行。
  - **[Alpha Testing](../A/alpha-testing.md)** ：在将产品发布给真实用户之前在内部进行以确定所有可能的问题。
  - **[Beta Testing](../B/beta-testing.md)** ：由真实用户在真实环境中执行，以在最终发布之前提供有关产品质量的反馈。

#### 什么是黑盒测试？

[Black box testing](../B/black-box-testing.md) 是[software testing](../S/software-testing.md) 的一种方法，它检查应用程序的功能，而无需查看其内部结构或工作方式。这种技术关注的是软件做什么而不是如何做。 [Test cases](../T/test-case.md) 是根据软件的规范和要求创建的，确保所有功能都从用户的角度进行测试。
  测试人员输入数据并检查输出，但不知道如何以及在何处处理输入。这种方法几乎可以应用于[software testing](../S/software-testing.md)的所有级别：单元、集成、系统和验收。在测试人员无法访问源代码或源代码的复杂性与正在测试的功能无关的情况下，它特别有用。
  [black box testing](../B/black-box-testing.md) 的 **关键方面** 包括：

- **功能有效性**：检查软件是否按预期运行。
  - **错误识别**：在不了解底层代码的情况下查找错误。
  - **用户环境模拟**：模仿用户行为以确保软件满足用户要求。
  由于[black box testing](../B/black-box-testing.md) 不了解内部结构，因此它可能会错过与软件内部逻辑相关的某些类型的缺陷。然而，它是全面测试策略的重要组成部分，是对白盒和[grey box testing](../G/grey-box-testing.md)方法的补充。

- **功能有效性**：检查软件是否按预期运行。
  - **错误识别**：在不了解底层代码的情况下查找错误。
  - **用户环境模拟**：模仿用户行为以确保软件满足用户要求。

#### 什么是白盒测试？

[White box testing](../W/white-box-testing.md)，也称为 **明盒测试**、**[glass box testing](../G/glass-box-testing.md)** 或 **[structural testing](../S/structural-testing.md)**，是 [software testing](../S/software-testing.md) 的一种方法，其中测试人员可以完全了解被测试项目的内部工作情况。与[black box testing](../B/black-box-testing.md) 不同，[black box testing](../B/black-box-testing.md) 专注于外部可观察的行为，[white box testing](../W/white-box-testing.md) 需要了解代码结构、实现细节和编程技能。
  在[white box testing](../W/white-box-testing.md)中，测试人员根据**源代码**设计[test cases](../T/test-case.md)，以验证代码中的输入流、条件循环的功能以及数据结构的处理等。它允许测试人员评估单元内的路径、语句、分支和条件。
  [white box testing](../W/white-box-testing.md) 中使用的常用技术包括：

- **语句覆盖率**：确保代码中的每个语句至少被执行一次。
  - **分支覆盖**：确保每个分支（true/false）都已执行。
  - **路径覆盖**：确保执行通过代码给定部分的每条可能的路线。
  [White box testing](../W/white-box-testing.md) 通常在开发阶段在**单元级别**执行。它可以自动化，并且通常使用代码分析器和调试器等工具来促进该过程。
  测试人员还可以使用[white box testing](../W/white-box-testing.md) 执行**安全审核**，检查代码中的漏洞。
  鉴于观众对 [test automation](../T/test-automation.md) 的专业知识，[white box testing](../W/white-box-testing.md) 可以集成到 CI/CD 管道中，从而可以持续验证代码更改并及早发现问题。

- **语句覆盖率**：确保代码中的每个语句至少被执行一次。
  - **分支覆盖**：确保每个分支（true/false）都已执行。
  - **路径覆盖**：确保执行通过代码给定部分的每条可能的路线。

#### 什么是灰盒测试？

[Grey box testing](../G/grey-box-testing.md) 是一种混合方法，结合了 **黑盒** 和 **[white box testing](../W/white-box-testing.md)** 方法的元素。它需要对应用程序的内部工作原理有部分了解，通常包括对 [database](../D/database.md) 架构和算法流程的理解，但不是完整的源代码。 [grey box testing](../G/grey-box-testing.md) 中的测试人员可以访问详细的设计文档和[database](../D/database.md) 图表，这有助于他们设计[test cases](../T/test-case.md)，从而更有效地发现隐藏的错误。
  该方法在测试 Web 应用程序时特别有用，测试人员可以利用 HTML、JavaScript 和服务器通信知识来设计测试，以探索潜在的安全漏洞或集成问题。 [Grey box testing](../G/grey-box-testing.md) 也适用于[integration testing](../I/integration-testing.md)、[penetration testing](../P/penetration-testing.md)，并用于测试网络协议。
  测试人员使用的工具可以帮助他们与应用程序的界面进行比典型最终用户更深层次的交互，但不需要深入研究 [white box testing](../W/white-box-testing.md) 所要求的代码库。此类工具的示例包括：

  ```
  - Web application proxies
  - Database query tools
  - Code analysis tools
  - Debuggers
  ```[grey box testing](../G/grey-box-testing.md) 的主要优点是它在[black box testing](../B/black-box-testing.md) 的高级视角和[white box testing](../W/white-box-testing.md) 的详细视角之间提供了平衡，使测试人员能够在对底层结构有合理理解的情况下专注于应用程序最关键的区域。这比单独[black box testing](../B/black-box-testing.md) 进行更彻底的测试，而无需投入完整[white box testing](../W/white-box-testing.md) 所需的大量时间。

#### 功能测试和非功能测试有什么区别？

[Functional testing](../F/functional-testing.md) 重点验证软件应用程序的每个功能是否按照需求规范运行。此类测试通过提供适当的输入并根据定义的 [functional requirements](../F/functional-requirements.md) 检查输出来验证应用程序的行为。它包括单元测试、集成测试、系统测试和验收测试等各种测试。
  另一方面，[Non-functional testing](../N/non-functional-testing.md) 指的是与系统的特定行为或功能无关的方面。它检查软件应用程序的非功能方面（性能、可用​​性、可靠性等）。 [Non-functional testing](../N/non-functional-testing.md) 旨在根据[functional testing](../F/functional-testing.md) 从未解决的非功能参数来评估系统的准备情况。 [non-functional testing](../N/non-functional-testing.md) 的类型包括[performance testing](../P/performance-testing.md)、[load testing](../L/load-testing.md)、[stress testing](../S/stress-testing.md)、[security testing](../S/security-testing.md)、[compatibility testing](../C/compatibility-testing.md) 和[usability testing](../U/usability-testing.md)。
  本质上，**[functional testing](../F/functional-testing.md)** 确保软件执行其应做的操作，而 **[non-functional testing](../N/non-functional-testing.md)** 确保软件在各种条件下的用户环境中都能良好运行。两者对于评估软件的整体质量和用户体验都至关重要。

### 手动测试过程

#### 手动测试生命周期有哪些阶段？

[manual testing](../M/manual-testing.md) 生命周期由几个阶段组成：

1. **需求分析**：了解应用程序的功能并确定可测试的需求。
  2. **测试计划**：定义范围和目标，确定资源（时间、人力、工具），并概述测试策略。
  3. **[Test Case](../T/test-case.md) 开发**：创建测试用例和测试脚本，包括定义条件、输入、操作和预期结果。
  4. **[Test Environment](../T/test-environment.md) [Setup](../S/setup.md)** ：准备进行测试的硬件和软件环境，包括任何必要的测试数据。
  5. **[Test Execution](../T/test-execution.md)** ：手动运行测试用例，记录每个测试用例的结果，并报告发现的任何缺陷。
  6. **缺陷记录**：在缺陷跟踪工具中记录测试执行期间发现的任何缺陷或问题的详细信息。
  7. **测试周期结束**：评估测试周期的有效性，确保执行所有测试用例并且修复或确认缺陷，并创建测试结束报告。
  每个阶段对于确保 [manual testing](../M/manual-testing.md) 流程的彻底性和有效性都至关重要。测试人员必须细致且有组织性，因为测试的质量会显着影响软件产品的整体质量。

1. **需求分析**：了解应用程序的功能并确定可测试的需求。
  2. **测试计划**：定义范围和目标，确定资源（时间、人力、工具），并概述测试策略。
  3. **[Test Case](../T/test-case.md) 开发**：创建测试用例和测试脚本，包括定义条件、输入、操作和预期结果。
  4. **[Test Environment](../T/test-environment.md) [Setup](../S/setup.md)** ：准备进行测试的硬件和软件环境，包括任何必要的测试数据。
  5. **[Test Execution](../T/test-execution.md)** ：手动运行测试用例，记录每个测试用例的结果，并报告发现的任何缺陷。
  6. **缺陷记录**：在缺陷跟踪工具中记录测试执行期间发现的任何缺陷或问题的详细信息。
  7. **测试周期结束**：评估测试周期的有效性，确保执行所有测试用例并且修复或确认缺陷，并创建测试结束报告。

#### 什么是测试计划以及它涉及什么？

测试计划是 [software testing](../S/software-testing.md) 生命周期的关键阶段，在此阶段创建详细的蓝图来指导整个测试过程。它涉及定义测试所需的**目标**、**范围**、**方法**和**资源**。 [test plan](../T/test-plan.md) 概述了**[test strategy](../T/test-strategy.md)**、**时间表**、**可交付成果**和**风险管理**计划，以确保全面覆盖和高效执行。
  测试计划的关键组成部分包括：

- **测试目标**：测试要实现的明确目标。
  - **测试范围**：测试和不测试内容的边界。
  - **[Test Strategy](../T/test-strategy.md)** ：关于如何进行测试的高层决策，包括手动测试和自动测试之间的选择，以及要执行的测试类型。
  - **资源分配**：识别和分配测试所需的人员、工具和环境。
  - **时间表和里程碑**：测试活动的时间表，包括测试周期的开始和结束日期。
  - **风险分析**：识别潜在风险并制定缓解策略。
  - **测试交付成果**：要生成的文档，例如测试计划、测试用例、测试脚本和缺陷报告。
  - **进入和退出标准**：开始测试必须满足的条件以及结束测试阶段的标准。
  有效的测试规划可确保测试与项目目标保持一致、有效进行，并提供对 [software quality](../S/software-quality.md) 的宝贵见解。它为[test execution](../T/test-execution.md) 的成功奠定了基础，并帮助管理利益相关者的期望。

- **测试目标**：测试要实现的明确目标。
  - **测试范围**：测试和不测试内容的边界。
  - **[Test Strategy](../T/test-strategy.md)** ：关于如何进行测试的高层决策，包括手动测试和自动测试之间的选择，以及要执行的测试类型。
  - **资源分配**：识别和分配测试所需的人员、工具和环境。
  - **时间表和里程碑**：测试活动的时间表，包括测试周期的开始和结束日期。
  - **风险分析**：识别潜在风险并制定缓解策略。
  - **测试交付成果**：要生成的文档，例如测试计划、测试用例、测试脚本和缺陷报告。
  - **进入和退出标准**：开始测试必须满足的条件以及结束测试阶段的标准。

#### 什么是测试用例设计以及一个好的测试用例的关键要素是什么？

[Test case](../T/test-case.md) 设计是创建一组条件或变量的过程，在这些条件或变量下测试人员将确定被测系统是否满足要求或正常工作。一个好的[test case](../T/test-case.md) 的关键要素包括：

- **明确的目标**：每个测试用例都应该有一个明确的目标，并且应该与特定的要求相关联。
  - **前提条件**：定义执行测试之前必须满足的任何特定条件。
  - **[Test Data](../T/test-data.md)** ：包括将用于测试的必要数据，或对可以找到此类数据的位置的引用。
  - **执行步骤**：提供测试人员需要遵循的详细步骤，确保可重复性和一致性。
  - **[Expected Results](../E/expected-result.md)** ：清楚地说明正确执行测试用例时预期的结果。
  - **[Postconditions](../P/postcondition.md)** ：描述测试用例执行后系统的状态（如果适用）。
  - **可追溯性**：参考需求或用户故事以确保覆盖范围和可追溯性。
  - **明确**：以不留任何解释空间的方式编写测试用例，以保持不同测试人员之间的一致性。
  - **幂等性**：设计测试用例，以便它们可以运行多次并仍然产生相同的结果。
  - **清理**：包括恢复测试期间所做的任何更改的步骤，确保系统返回到测试前的状态。
  精心设计的[test case](../T/test-case.md)不仅有助于验证应用程序的功能，而且还可以作为未来测试周期的文档，促进维护和[regression testing](../R/regression-testing.md)。

- **明确的目标**：每个测试用例都应该有一个明确的目标，并且应该与特定的要求相关联。
  - **前提条件**：定义执行测试之前必须满足的任何特定条件。
  - **[Test Data](../T/test-data.md)** ：包括将用于测试的必要数据，或对可以找到此类数据的位置的引用。
  - **执行步骤**：提供测试人员需要遵循的详细步骤，确保可重复性和一致性。
  - **[Expected Results](../E/expected-result.md)** ：清楚地说明正确执行测试用例时预期的结果。
  - **[Postconditions](../P/postcondition.md)** ：描述测试用例执行后系统的状态（如果适用）。
  - **可追溯性**：参考需求或用户故事以确保覆盖范围和可追溯性。
  - **明确**：以不留任何解释空间的方式编写测试用例，以保持不同测试人员之间的一致性。
  - **幂等性**：设计测试用例，以便它们可以运行多次并仍然产生相同的结果。
  - **清理**：包括恢复测试期间所做的任何更改的步骤，确保系统返回到测试前的状态。

#### 什么是测试执行以及涉及哪些步骤？

软件中的[Test execution](../T/test-execution.md) [test automation](../T/test-automation.md) 是针对被测软件运行自动化脚本以验证其行为是否符合预期的过程。 [test execution](../T/test-execution.md)涉及的步骤如下：

1. **环境[Setup](../S/setup.md)**：确保[test environment](../T/test-environment.md)正确配置所有必要的硬件、软件、网络设置和数​​据。
  2. **[Test Data](../T/test-data.md) 准备**：创建或加载[test cases](../T/test-case.md) 所需的[test data](../T/test-data.md)。
  3. **执行调度**：确定[test cases](../T/test-case.md)的顺序和时间，可能使用持续集成（CI）工具来调度和触发测试。
  4. **运行测试**：使用所选[test automation](../T/test-automation.md) 工具或框架执行自动化[test scripts](../T/test-script.md)。
  5. **监控**：观察[test execution](../T/test-execution.md)以确保测试按预期运行。这可能涉及检查测试运行的状态、监视超时或错误以及确保[test environment](../T/test-environment.md) 保持稳定。
  6. **结果分析**：查看测试运行的输出，包括每个 [test case](../T/test-case.md) 的通过/失败状态、日志、屏幕截图和其他工件。
  7. **缺陷记录**：将 [test execution](../T/test-execution.md) 期间发现的任何故障或问题记录到缺陷跟踪系统中，并提供足够的详细信息以进行调试。
  8. **结果报告**：生成总结 [test execution](../T/test-execution.md) 结果的报告，包括通过率、覆盖率和缺陷计数等指标。
  9. **清理**：将[test environment](../T/test-environment.md)重置为干净状态，为后续测试运行或其他活动做好准备。
  在整个这些步骤中，保持清晰的文档并确保任何与 [expected results](../E/expected-result.md) 的偏差都得到及时调查和解决至关重要。

1. **环境[Setup](../S/setup.md)**：确保[test environment](../T/test-environment.md)正确配置所有必要的硬件、软件、网络设置和数​​据。
  2. **[Test Data](../T/test-data.md) 准备**：创建或加载[test cases](../T/test-case.md) 所需的[test data](../T/test-data.md)。
  3. **执行调度**：确定[test cases](../T/test-case.md)的顺序和时间，可能使用持续集成（CI）工具来调度和触发测试。
  4. **运行测试**：使用所选[test automation](../T/test-automation.md) 工具或框架执行自动化[test scripts](../T/test-script.md)。
  5. **监控**：观察[test execution](../T/test-execution.md)以确保测试按预期运行。这可能涉及检查测试运行的状态、监视超时或错误以及确保[test environment](../T/test-environment.md) 保持稳定。
  6. **结果分析**：查看测试运行的输出，包括每个 [test case](../T/test-case.md) 的通过/失败状态、日志、屏幕截图和其他工件。
  7. **缺陷记录**：将 [test execution](../T/test-execution.md) 期间发现的任何故障或问题记录到缺陷跟踪系统中，并提供足够的详细信息以进行调试。
  8. **结果报告**：生成总结 [test execution](../T/test-execution.md) 结果的报告，包括通过率、覆盖率和缺陷计数等指标。
  9. **清理**：将[test environment](../T/test-environment.md)重置为干净状态，为后续测试运行或其他活动做好准备。

#### 什么是测试收敛以及它涉及什么？

测试结束是测试周期的最后阶段，标志着测试过程的完成。它涉及几项关键活动：

- **评估可交付成果**：确保满足所有测试目标，所有可交付成果均得到考虑并符合标准。
  - **报告**：编写全面的测试总结报告，详细说明测试结果、覆盖范围、缺陷分析和测试对象质量评估。
  - **文档**：存档所有相关的测试工件，例如测试用例、测试数据和缺陷日志，以供将来参考或审核。
  - **经验教训**：召开回顾性会议，讨论哪些进展顺利，哪些进展不佳，并确定未来测试周期的改进措施。
  - **发布标准检查**：验证产品在发布前是否满足测试计划阶段定义的退出标准。
  - **正式结束**：获得利益相关者的正式签字，表明接受测试工作并且产品已准备好发布。
  这些活动确保了测试工作的结构化和可追溯性，为未来的项目提供了宝贵的见解，并保持了测试过程的完整性。

- **评估可交付成果**：确保满足所有测试目标，所有可交付成果均得到考虑并符合标准。
  - **报告**：编写全面的测试总结报告，详细说明测试结果、覆盖范围、缺陷分析和测试对象质量评估。
  - **文档**：存档所有相关的测试工件，例如测试用例、测试数据和缺陷日志，以供将来参考或审核。
  - **经验教训**：召开回顾性会议，讨论哪些进展顺利，哪些进展不佳，并确定未来测试周期的改进措施。
  - **发布标准检查**：验证产品在发布前是否满足测试计划阶段定义的退出标准。
  - **正式结束**：获得利益相关者的正式签字，表明接受测试工作并且产品已准备好发布。

### 手动测试工具

#### 手动测试使用哪些工具？

在[manual testing](../M/manual-testing.md) 中，工具通常没有[automated testing](../A/automated-testing.md) 中使用的工具复杂。它们支持从 [test management](../T/test-management.md) 到缺陷跟踪的各种测试活动。以下是 [manual testing](../M/manual-testing.md) 中常用工具的简明列表：

- **[Test Management](../T/test-management.md) 工具**：TestRail、Zephyr 和 Quality Center 等工具用于组织和管理 [test cases](../T/test-case.md)、计划和运行。它们帮助跟踪进度并报告测试活动的状态。
  - **缺陷跟踪工具**：[Jira](../J/jira.md)、Bugzilla 和 Mantis 是记录、跟踪和管理测试期间发现的缺陷的常用选择。它们促进测试人员和开发人员之间的协作以解决问题。
  - **文档工具**：Microsoft Word 和 Google Docs 用于创建[test plans](../T/test-plan.md)、[test cases](../T/test-case.md) 和测试报告。它们有助于维护测试过程的清晰且可访问的记录。
  - **电子表格工具**：Microsoft Excel 和 Google Sheets 通常用于 [test case management](../T/test-case-management.md)，特别是在没有专用 [test management](../T/test-management.md) 软件的小型项目或组织中。
  - **协作工具**：Slack、Microsoft Teams 和 Confluence 有助于团队成员之间的沟通，这对于协调 [manual testing](../M/manual-testing.md) 工作和分享见解至关重要。
  - **屏幕捕获和注释工具**：Snagit 和 LightShot 用于捕获缺陷的屏幕截图或录制缺陷视频，然后对其进行注释，为开发人员提供视觉证据和上下文。
  这些工具通过增强组织、沟通和文档来支持 [manual testing](../M/manual-testing.md) 流程，但它们不会自动执行测试。

- **[Test Management](../T/test-management.md) 工具**：TestRail、Zephyr 和 Quality Center 等工具用于组织和管理 [test cases](../T/test-case.md)、计划和运行。它们帮助跟踪进度并报告测试活动的状态。
  - **缺陷跟踪工具**：[Jira](../J/jira.md)、Bugzilla 和 Mantis 是记录、跟踪和管理测试期间发现的缺陷的常用选择。它们促进测试人员和开发人员之间的协作以解决问题。
  - **文档工具**：Microsoft Word 和 Google Docs 用于创建 [test plans](../T/test-plan.md)、[test cases](../T/test-case.md) 和测试报告。它们有助于维护测试过程的清晰且可访问的记录。
  - **电子表格工具**：Microsoft Excel 和 Google Sheets 通常用于 [test case management](../T/test-case-management.md)，特别是在没有专用 [test management](../T/test-management.md) 软件的小型项目或组织中。
  - **协作工具**：Slack、Microsoft Teams 和 Confluence 有助于团队成员之间的沟通，这对于协调 [manual testing](../M/manual-testing.md) 工作和分享见解至关重要。
  - **屏幕捕获和注释工具**：Snagit 和 LightShot 用于捕获缺陷的屏幕截图或录制缺陷视频，然后对其进行注释，为开发人员提供视觉证据和上下文。

#### 测试管理工具在手动测试中的作用是什么？

[manual testing](../M/manual-testing.md) 中的**[test management](../T/test-management.md) 工具**充当所有与测试相关的活动的中央存储库。它有助于测试过程的组织、记录和跟踪，确保[manual testing](../M/manual-testing.md) 工作系统化且透明。主要角色包括：

- **测试计划**：帮助定义和管理测试计划，概述测试活动的范围、目标和策略。
  - **[Test Case Management](../T/test-case-management.md)** ：允许创建、存储和维护测试用例，以及将它们映射到需求以确保覆盖范围。
  - **[Test Execution](../T/test-execution.md) 跟踪**：允许记录测试执行结果，提供测试进度和结果的可见性。
  - **[Defect Management](../D/defect-management.md)** ：与缺陷跟踪系统集成或包含缺陷跟踪系统，以记录、分配和跟踪手动测试期间发现的错误。
  - **报告和指标**：生成报告和仪表板，提供对测试过程有效性的见解，突出显示风险和成功领域。
  - **协作**：通过实时共享测试工件和状态更新，促进团队成员之间的沟通和协作。
  通过提供这些功能，[test management](../T/test-management.md) 工具提高了[manual testing](../M/manual-testing.md) 工作的效率、准确性和可追溯性，即使对于偶尔需要执行手动测试的经验丰富的[test automation](../T/test-automation.md) 工程师来说也是如此。

- **测试计划**：帮助定义和管理测试计划，概述测试活动的范围、目标和策略。
  - **[Test Case Management](../T/test-case-management.md)** ：允许创建、存储和维护测试用例，以及将它们映射到需求以确保覆盖范围。
  - **[Test Execution](../T/test-execution.md) 跟踪**：允许记录测试执行结果，提供测试进度和结果的可见性。
  - **[Defect Management](../D/defect-management.md)** ：与缺陷跟踪系统集成或包含缺陷跟踪系统，以记录、分配和跟踪手动测试期间发现的错误。
  - **报告和指标**：生成报告和仪表板，提供对测试过程有效性的见解，突出显示风险和成功领域。
  - **协作**：通过实时共享测试工件和状态更新，促进团队成员之间的沟通和协作。

#### 缺陷跟踪工具在手动测试中的作用是什么？

在[manual testing](../M/manual-testing.md) 中，**缺陷跟踪工具**对于组织和管理识别、记录和解决测试期间发现的缺陷的过程至关重要。它作为所有缺陷相关信息的集中存储库，允许测试人员和开发人员就问题**有效地沟通**。
  缺陷跟踪工具的主要作用包括：

- **记录缺陷**：测试人员记录缺陷的详细信息，例如描述、严重性、重现步骤和屏幕截图。
  - **跟踪进度**：该工具允许监控缺陷从发现到解决的状态。
  - **优先级**：可以根据严重性、频率或影响来确定缺陷的优先​​级，帮助团队首先解决最关键的问题。
  - **分配职责**：可以将缺陷分配给特定的团队成员进行调查和解决。
  - **历史数据**：它提供了缺陷的历史记录，这对于未来的项目和回归测试很有用。
  - **指标和报告**：该工具生成有助于评估软件质量和测试过程效率的报告和指标。
  通过使用缺陷跟踪工具，团队可以确保没有缺陷被漏掉，并且可以提高软件产品的整体质量。它还通过提供缺陷解决工作流程的清晰可视性，促进更好的资源分配和项目管理。

- **记录缺陷**：测试人员记录缺陷的详细信息，例如描述、严重性、重现步骤和屏幕截图。
  - **跟踪进度**：该工具允许监控缺陷从发现到解决的状态。
  - **优先级**：可以根据严重性、频率或影响来确定缺陷的优先​​级，帮助团队首先解决最关键的问题。
  - **分配职责**：可以将缺陷分配给特定的团队成员进行调查和解决。
  - **历史数据**：它提供了缺陷的历史记录，这对于未来的项目和回归测试很有用。
  - **指标和报告**：该工具生成有助于评估软件质量和测试过程效率的报告和指标。

#### 手动测试工具有哪些示例？

[Manual testing](../M/manual-testing.md) 工具通常包含促进[manual testing](../M/manual-testing.md) 过程的各种应用程序和辅助工具。这些工具不会自动化测试过程，但支持测试人员执行和管理测试。示例包括：

- **电子表格和文档**：用于测试用例管理和跟踪结果的 Microsoft Excel 或 Google Sheets。
  - **[Test Case Management](../T/test-case-management.md) 工具**：TestRail、Zephyr 或 TestLink 等工具可帮助组织和管理测试用例、计划测试活动以及报告测试状态。
  - **缺陷跟踪工具**：JIRA、Bugzilla 或 MantisBT 用于报告、跟踪和管理测试期间发现的缺陷。
  - **[Exploratory Testing](../E/exploratory-testing.md) 辅助**：基于会话的测试管理工具（例如 Rapid Reporter）有助于在探索性测试会话期间进行笔记记录和时间管理。
  - **协作工具**：Confluence、Slack 或 Trello 可用于共享信息、协作制定测试计划以及协调测试工作。
  - **屏幕捕获和注释工具**：Snagit 或 Greenshot 用于截取屏幕截图并对其进行注释以突出显示问题。
  - **[API Testing](../A/api-testing.md) 工具**：Postman 或 Insomnia 用于手动 API 测试，允许测试人员发送请求并分析响应。
  - **性能监控工具**：浏览器 DevTools 或 New Relic 等工具用于手动监控和分析性能问题。
  这些工具有助于简化 [manual testing](../M/manual-testing.md) 流程，使其更加高效和有组织，但它们并不能取代人类测试人员执行测试的需要。

- **电子表格和文档**：用于测试用例管理和跟踪结果的 Microsoft Excel 或 Google Sheets。
  - **[Test Case Management](../T/test-case-management.md) 工具**：TestRail、Zephyr 或 TestLink 等工具可帮助组织和管理测试用例、计划测试活动以及报告测试状态。
  - **缺陷跟踪工具**：JIRA、Bugzilla 或 MantisBT 用于报告、跟踪和管理测试期间发现的缺陷。
  - **[Exploratory Testing](../E/exploratory-testing.md) 辅助**：基于会话的测试管理工具（例如 Rapid Reporter）有助于在探索性测试会话期间进行笔记记录和时间管理。
  - **协作工具**：Confluence、Slack 或 Trello 可用于共享信息、协作制定测试计划以及协调测试工作。
  - **屏幕捕获和注释工具**：Snagit 或 Greenshot 用于截取屏幕截图并对其进行注释以突出显示问题。
  - **[API Testing](../A/api-testing.md) 工具**：Postman 或 Insomnia 用于手动 API 测试，允许测试人员发送请求并分析响应。
  - **性能监控工具**：浏览器 DevTools 或 New Relic 等工具用于手动监控和分析性能问题。

### 手动测试最佳实践

#### 手动测试的最佳实践有哪些？

考虑到受众在 [test automation](../T/test-automation.md) 方面的专业知识，[manual testing](../M/manual-testing.md) 的最佳实践包括：

- **优先考虑[test cases](../T/test-case.md)**
    基于风险和影响。首先关注关键功能。

- **保持[test cases](../T/test-case.md)清晰简洁**
    确保它们易于遵循且可重复。

- **使用[exploratory testing](../E/exploratory-testing.md)**
    发现结构化测试可能遗漏的问题。

- **彻底记录缺陷**
    ，包括重现步骤、预期结果与实际结果以及屏幕截图（如果适用）。

- **执行[regression testing](../R/regression-testing.md)**
    经过修复和增强以确保新的更改不会引入新的问题。

- **同行评审[test cases](../T/test-case.md)**
    提高测试覆盖率并发现错误。

- **保持更新**
    使用最新的测试技术和工具来增强手动测试流程。

- **平衡手册和[automated testing](../A/automated-testing.md)**
    通过确定哪些测试最适合自动化以及哪些需要人性化。

- **有效沟通**
    与开发团队合作，确保清楚地了解功能和要求。

- **保持组织良好的[test environment](../T/test-environment.md)**
    以确保测试结果的一致性和可靠性。

- **适应性强**
    并准备随着项目的发展调整测试策略。
  通过集成这些实践，手动测试人员可以补充自动化流程并有助于制定稳健的测试策略。

- **优先考虑[test cases](../T/test-case.md)**
    基于风险和影响。首先关注关键功能。

- **保持[test cases](../T/test-case.md)清晰简洁**
    确保它们易于遵循且可重复。

- **使用[exploratory testing](../E/exploratory-testing.md)**
    发现结构化测试可能遗漏的问题。

- **彻底记录缺陷**
    ，包括重现步骤、预期结果与实际结果以及屏幕截图（如果适用）。

- **执行[regression testing](../R/regression-testing.md)**
    经过修复和增强以确保新的更改不会引入新的问题。

- **同行评审[test cases](../T/test-case.md)**
    提高测试覆盖率并发现错误。

- **保持更新**
    使用最新的测试技术和工具来增强手动测试流程。

- **平衡手册和[automated testing](../A/automated-testing.md)**
    通过确定哪些测试最适合自动化以及哪些需要人性化。

- **有效沟通**
    与开发团队合作，确保清楚地了解功能和要求。

- **保持组织良好的[test environment](../T/test-environment.md)**
    以确保测试结果的一致性和可靠性。

- **适应性强**
    并准备随着项目的发展调整测试策略。

#### 如何使手动测试更加有效？

为了增强[manual testing](../M/manual-testing.md)的有效性，请考虑以下策略：

- **优先考虑[test cases](../T/test-case.md)**
    基于风险和影响。专注于直接影响用户体验的关键功能。

- **利用[exploratory testing](../E/exploratory-testing.md)**
    发现脚本测试可能遗漏的问题。这使得测试人员能够发挥他们的创造力和直觉。

- **使用清单**
    确保所有领域都被覆盖，而没有正式测试用例的僵化。

- **[Pair testing](../P/pair-testing.md)**
    两个测试人员一起工作来发现缺陷可能是有益的；一个人操作软件，另一个人做笔记并思考新的测试场景。

- **实施[session-based testing](../S/session-based-testing.md)**
    管理和跟踪探索性测试工作，确保问责制和覆盖范围。

- **审查和完善**
    定期测试用例以消除冗余并使其与应用程序更改保持同步。

- **利用思维导图**
    可视化测试覆盖范围并识别测试中的差距。

- **不断学习**
    关于被测应用程序；更深入的理解会带来更有洞察力的测试场景。

- **与开发人员合作**
    深入了解可能影响测试的代码更改。

- **收集反馈**
    来自利益相关者的帮助，使测试工作与业务要求和用户需求保持一致。

- **自动化重复任务**
    不需要人工判断（例如数据设置），以便有更多时间进行实际测试。

- **投资测试人员培训**
    保持技能敏锐和知识最新，特别是在新的测试技术或领域专业知识等领域。
  通过应用这些策略，手动测试人员可以最大限度地提高效率并为更高的[software quality](../S/software-quality.md)做出贡献。

- **优先考虑[test cases](../T/test-case.md)**
    基于风险和影响。专注于直接影响用户体验的关键功能。

- **利用[exploratory testing](../E/exploratory-testing.md)**
    发现脚本测试可能遗漏的问题。这使得测试人员能够发挥他们的创造力和直觉。

- **使用清单**
    确保所有领域都被覆盖，而没有正式测试用例的僵化。

- **[Pair testing](../P/pair-testing.md)**
    两个测试人员一起工作来发现缺陷可能是有益的；一个人操作软件，另一个人做笔记并思考新的测试场景。

- **实施[session-based testing](../S/session-based-testing.md)**
    管理和跟踪探索性测试工作，确保问责制和覆盖范围。

- **审查和完善**
    定期测试用例以消除冗余并使其与应用程序更改保持同步。

- **利用思维导图**
    可视化测试覆盖范围并识别测试中的差距。

- **不断学习**
    关于被测应用程序；更深入的理解会带来更有洞察力的测试场景。

- **与开发人员合作**
    深入了解可能影响测试的代码更改。

- **收集反馈**
    来自利益相关者的帮助，使测试工作与业务要求和用户需求保持一致。

- **自动化重复任务**
    不需要人工判断（例如数据设置），以便有更多时间进行实际测试。

- **投资测试人员培训**
    保持技能敏锐和知识最新，特别是在新的测试技术或领域专业知识等领域。

#### 手动测试中需要避免哪些常见错误？

[manual testing](../M/manual-testing.md) 中要避免的常见错误包括：

- **忽略测试文档**：跳过详细测试用例和测试计划的创建可能会导致非结构化测试和遗漏缺陷。
  - **不足[Test Coverage](../T/test-coverage.md)** ：仅关注快乐路径而不考虑边缘情况、错误条件或负面场景可能会导致无法检测到关键错误。
  - **没有明确目标的测试**：在没有清楚了解需求或目标的情况下执行测试可能会导致测试工作无效。
  - **忽略用户体验**：只关注功能而不考虑可用性可能会导致产品满足需求但无法满足用户。
  - **忽略非功能方面**：忽视性能、安全性和兼容性测试可能会导致发布后出现严重问题。
  - **抵抗重复测试**：由于单调而避免重新测试和回归测试可能会导致在进行更改时漏掉缺陷。
  - **不优先考虑[Test Cases](../T/test-case.md)**：未能根据风险和影响确定测试用例的优先级可能会导致重要的测试被搁置到周期中为时已晚。
  - **糟糕的[Bug](../B/bug.md) 报告**：编写模糊或不完整的错误报告可能会阻碍缺陷修复过程并导致误解。
  - **隔离测试**：不与开发人员、业务分析师和其他利益相关者合作可能会导致缺乏共同理解和错过需求。
  - **变得有偏见**：允许假设或先前的知识影响测试可能会导致测试人员忽视缺陷。
  - **不适应变化**：不灵活并且在需求变化时不更新测试用例可能会导致测试不再相关或有效。
  - **忽略测试文档**：跳过详细测试用例和测试计划的创建可能会导致非结构化测试和遗漏缺陷。
  - **不足[Test Coverage](../T/test-coverage.md)** ：仅关注快乐路径而不考虑边缘情况、错误条件或负面场景可能会导致无法检测到关键错误。
  - **没有明确目标的测试**：在没有清楚了解需求或目标的情况下执行测试可能会导致测试工作无效。
  - **忽略用户体验**：只关注功能而不考虑可用性可能会导致产品满足需求但无法满足用户。
  - **忽略非功能方面**：忽视性能、安全性和兼容性测试可能会导致发布后出现严重问题。
  - **抵抗重复测试**：由于单调而避免重新测试和回归测试可能会导致在进行更改时漏掉缺陷。
  - **不优先考虑[Test Cases](../T/test-case.md)**：未能根据风险和影响确定测试用例的优先级可能会导致重要的测试被搁置到周期中为时已晚。
  - **糟糕的[Bug](../B/bug.md) 报告**：编写模糊或不完整的错误报告可能会阻碍缺陷修复过程并导致误解。
  - **隔离测试**：不与开发人员、业务分析师和其他利益相关者合作可能会导致缺乏共同理解和错过需求。
  - **变得有偏见**：允许假设或先前的知识影响测试可能会导致测试人员忽视缺陷。
  - **不适应变化**：不灵活并且在需求变化时不更新测试用例可能会导致测试不再相关或有效。

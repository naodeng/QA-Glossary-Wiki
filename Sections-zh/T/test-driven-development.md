# 测试驱动开发 (Test-Driven Development, TDD)
[测试驱动开发 (Test-Driven Development)](#test-driven-development)

## 关于测试驱动开发 (TDD) 的常见问题？

#### 基础与重要性
- **什么是测试驱动开发 (TDD)？**
  **测试驱动开发 (Test-Driven Development, TDD)** 是一种 **[软件开发方法 (software development approach)](/wiki/test-driven-development)**，其要求在编写用于验证的生产代码之前先编写测试。这是一个循环过程：开发人员先编写一个定义了期望改进或新功能的测试，然后编写最少量的代码使该测试通过，最后将新代码重构成可接受的标准。
  下面是一个使用 TypeScript 的基本示例：
  ```typescript
  // 步骤 1：编写一个失败的测试
  describe('计算器 (Calculator)', () => {
    it('相加两个数字', () => {
      const calculator = new Calculator();
      expect(calculator.add(2, 3)).toEqual(5);
    });
  });

  // 步骤 2：编写刚好足够的代码使测试通过
  class Calculator {
    add(a: number, b: number): number {
      return a + b;
    }
  }

  // 步骤 3：如有必要进行重构
  // 在这个简单的案例中，不需要重构。
  ```
  在 TDD 中，通常使用 **模拟对象 (mock objects)** 来模拟复杂依赖项的行为，从而允许测试专注于正在开发的代码，而不受外部系统的干扰。
  TDD 对 **测试优先开发 (test-first development)** 的强调鼓励了简单的设计并激发了信心。它与敏捷 (Agile) 等各种软件开发方法论兼容，并且可以通过从新功能开始或逐步用测试覆盖遗留代码来集成到现有项目中。
  虽然 TDD 可以带来更高质量的软件，但它需要自律和对其原则的理解，以避免常见的陷阱，例如编写过于宽泛的测试或没有充分重构代码。JUnit (Java)、Mocha (JavaScript) 和 xUnit (.NET) 等工具和框架通过提供结构化的编写和运行测试的方式来促进 TDD 的实施。

- **为什么 TDD 在软件开发中很重要？**
  TDD 在软件开发中很重要，因为它 **确保了编码、测试和设计是同步进行的**，从而提高了 **开发效率** 和 **代码质量**。通过专注于小的增量更改，开发人员可以 **避免范围蔓延**，并确保在继续下一步之前每个功能都得到了适当的测试。TDD 鼓励 **简单的设计** 并 **激发对软件的信心**，因为新功能的添加不会破坏现有功能。这种 **信心** 允许进行 **激进的重构**，从而保持代码库的整洁和可维护性。
  此外，TDD 创建了一个 **全面的单元测试套件**，可以随时运行以检测回归。它还 **有利于更好的文档记录**，因为测试可以作为系统行为的规范。TDD 对 **可测试性** 的强调还带来了更 **模块化且灵活** 的代码，使其更容易适应变化。
  在团队环境中，TDD 有助于 **减少** 集成过程中引入的 **[缺陷 (bugs)](/wiki/bug)**，并提供一个 **安全网**，使多名开发人员能够在同一个代码库上工作，从而降低冲突或回归的风险。最后，TDD 非常契合 **敏捷和迭代开发实践**，符合持续改进和适应的理念。

- **TDD 的核心原则是什么？**
  TDD 的核心原则包括：
  - **测试先行 (Write the Test First)**：在编写功能代码之前，先为新功能创建一个具体的测试。由于功能尚未实现，该测试最初应该失败。
  - **小步快跑 (Small Steps)**：以小的增量工作，一次编写一个测试及对应的代码。这有助于专注于功能的一个方面并降低复杂性。
  - **为失败而测试 (Test for Failure)**：新测试的第一次运行应该导致失败，以验证该测试能够正确检测到新功能的缺失。
  - **快速反馈 (Quick Feedback)**：应频繁运行测试，以便对更改提供即时反馈。这有助于在开发周期的早期识别并修复问题。
  - **自信地重构 (Refactor with Confidence)**：测试通过后，重构代码以改进其结构和可读性。现有测试提供了一个安全网，确保功能保持完好。
  - **持续集成 (Continuous Integration)**：经常将代码集成到主分支并运行测试，以尽早捕获集成问题。
  - **清晰且易懂的测试 (Clear and Understandable Tests)**：测试应写得清晰，并作为代码文档。它们应易于阅读和理解。
  - **每个测试一个逻辑断言 (One Logical Assertion per Test)**：每个测试应验证代码的一个方面，以保持测试的专注和易懂。
  - **避免测试内部实现 (Avoid Testing Internals)**：专注于行为而非内部实现。测试不应因为不影响行为的代码结构更改而失败。
  - **保持测试快速 (Keep Tests Fast)**：测试需要快速运行，以免减慢开发过程。慢速测试可能成为瓶颈，并阻碍开发人员频繁运行 **[测试套件 (test suite)](/wiki/test-suite)**。

- **TDD 如何提高软件质量？**
  TDD 通过确保高 **[测试覆盖率 (test coverage)](/wiki/test-coverage)** 以及在编写代码时兼顾 **可测试性** 来提高 **[软件质量 (software quality)](/wiki/software-quality)**。通过在实际代码之前编写测试，开发人员被迫从一开始就考虑边缘情况和潜在的 **[缺陷 (bugs)](/wiki/bug)**，从而实现更稳健可靠的代码。这种方法还促进了 **更简单、更模块化的设计**，因为难以测试的代码通常意味着结构较差。
  此外，TDD 的 **红-绿-重构循环 (Red-Green-Refactor cycle)** 鼓励 **持续重构**，这有助于维护整洁的代码库并减少技术债。由于测试是先写的，开发人员拥有一个安全网，允许他们自信地重构，因为他们知道任何引入的回归都会立即被捕获。
  TDD 的迭代性质产生了一个 **详细的回归套件**，它随代码库共同增长，提供关于更改影响的 **即时反馈**。该套件成为维护长期质量的宝贵资产，因为它可以在开发周期的早期检测到问题，降低了后期修复 **[缺陷 (bugs)](/wiki/bug)** 的成本和精力。
  TDD 还通过作为系统行为活文档的测试来促进 **更好的文档记录**。这可以提高当前和未来开发人员对代码的理解和 **[可维护性 (maintainability)](/wiki/maintainability)**。
  总之，TDD 通过培养优先考虑测试的开发环境、带来更整洁且更易维护的代码以及减少缺陷进入生产环境的可能性，从而提升了 **[软件质量 (software quality)](/wiki/software-quality)**。

- **传统测试和 TDD 的区别是什么？**
  传统测试通常发生在开发阶段 **之后**，测试人员编写并执行测试来验证已经编写好的代码功能。这种方法通常导致 **测试滞后 (test-last)** 循环，即测试是一个单独的阶段，可能导致在开发过程的后期才发现 **[缺陷 (bugs)](/wiki/bug)**。
  相比之下，**[测试驱动开发 (TDD)](/wiki/test-driven-development)** 是一种 **测试先行 (test-first)** 的方法，即测试在实际代码 **之前** 编写。开发人员先编写一个定义了期望改进或新功能的失败测试，然后编写最少量的代码使该测试通过，最后将新代码重构成可接受的标准。
  关键区别在于：
  - **时机 (Timing)**：传统测试在编码后进行，而 TDD 要求在编码前编写测试。
  - **测试的角色 (Role of Tests)**：在传统测试中，测试作为验证工具；在 TDD 中，它们指导设计和开发。
  - **反馈回路 (Feedback Loop)**：TDD 提供快速反馈回路，及早发现问题，而传统测试可能在周期后期才发现。
  - **设计影响 (Design Influence)**：TDD 影响设计更具模块化和可测试性，而传统测试则是适应现有设计。
  - **缺陷预防 vs. 检测 (Bug Prevention vs. Detection)**：TDD 专注于通过测试先行开发来预防 **[缺陷 (Bug)](/wiki/bug)**，而传统测试则侧重于在实现后检测缺陷。
  TDD 对测试先行开发的强调从根本上转变了测试在软件开发生命周期中的角色，将其集成到软件的设计和构建中，而不是将其视为一个单独的阶段。

#### TDD 过程
- **TDD 流程涉及哪些步骤？**
  TDD 流程涉及以下步骤：
  1. **识别一个需求** 或需要实现的功能。
  2. **编写一个 [测试用例 (test case)](/wiki/test-case)**，该用例因功能尚未实现而失败。这就是“红色 (Red)”阶段，测试将失败，表明新功能尚未存在。
     ```javascript
     it('应该相加两个数字', () => {
       expect(add(1, 2)).toEqual(3);
     });
     ```
  3. **编写使测试通过所需的最少量代码**。这就是“绿色 (Green)”阶段，你的重点是尽可能快地使测试通过，而无需担心代码质量。
     ```javascript
     function add(a, b) {
       return a + b;
     }
     ```
  4. **重构代码**，在不改变其行为的前提下改进其结构、可读性或性能。这就是“重构 (Refactor)”阶段，你在确保所有测试依然通过的同时清理代码。
     ```javascript
     function add(a, b) {
       // 如有必要，进行重构实现
       return a + b;
     }
     ```
  5. **重复** 该循环，处理下一个功能点或需求。
  在整个过程中，每次更改后都要运行所有测试，以确保没有引入回归。这种测试-代码-重构的迭代循环有助于构建一个稳健且经过良好测试的代码库。

- **TDD 中的红-绿-重构循环是什么？**
  **红-绿-重构 (Red-Green-Refactor)** 循环是 TDD 的基本节奏，它促进了一种自律的开发方法：
  1. **红色 (Red)**：编写一个描述预期行为或功能的新测试。运行 **[测试套件 (test suite)](/wiki/test-suite)** 以观察该测试失败（红色），确认该功能尚不存在或行为尚未满足。
     ```javascript
     it('应该相加两个数字', () => {
       expect(add(1, 2)).toEqual(3);
     });
     ```
  2. **绿色 (Green)**：实现使失败测试通过的最简单代码（绿色）。此时的重点是功能而非完美。
     ```javascript
     function add(a, b) {
       return a + b;
     }
     ```
  3. **重构 (Refactor)**：清理新代码，确保它能很好地契合现有代码库。这一步涉及在不改变行为的前提下消除重复、提高可读性并应用设计模式。
     ```javascript
     // 如有必要进行重构，但上述函数已经很简单。
     ```
  增量地为每个新功能或行为重复此循环，确保在重构阶段后测试始终通过。此过程有助于维护整洁的代码库，并提供关于更改影响的即时反馈。

- **在 TDD 中如何编写一个失败的测试？**
  在 TDD 中编写失败测试涉及以下步骤：
  1. **识别一个具体的需求** 或应用程序需要实现的功能点。
  2. **编写一个 [测试用例 (test case)](/wiki/test-case)** 来断言该功能的预期行为。由于功能尚未实现，该测试最初应设计为失败。
  3. 为你的测试函数使用 **描述性命名 (descriptive naming)**，清晰描述其测试内容。
  4. 在测试主体中，**设置任何必要的 [测试数据 (test data)](/wiki/test-data)** 或模拟依赖项。
  5. 使用测试数据 **调用你打算实现的方法** 或函数。
  6. **断言预期结果**。这可以是检查返回值、状态更改或与模拟对象的交互。
  下面是一个使用 **[Jest](/wiki/jest)** 的 TypeScript 示例：
  ```typescript
  test('应该相加两个数字', () => {
    // 准备 (Arrange)
    const calculator = new Calculator();

    // 执行 (Act)
    const result = calculator.add(1, 2);

    // 断言 (Assert)
    expect(result).toBe(3);
  });
  ```
  在这个例子中，`Calculator` 类及其 `add` 方法尚未实现。运行此测试会导致失败，这正是红-绿-重构循环中红色阶段预期的结果。在失败测试就绪后，你接下来将编写最小量的代码使测试通过，进入绿色阶段。

- **在 TDD 中如何使失败的测试通过？**
  要使 TDD 中的失败测试通过，请遵循以下步骤：
  1. **分析** 失败的测试，以理解当前实现未满足的预期行为。
  2. **编写能使测试通过的最简单代码**。此代码不需要完美或最终定稿，它只需满足测试的断言。
  3. **运行 [测试套件 (test suite)](/wiki/test-suite)** 以确保新代码使之前失败的测试通过，而不导致任何其他测试失败。
  4. 为清晰性、性能和 **[可维护性 (maintainability)](/wiki/maintainability)** 进行 **重构**，同时确保所有测试继续通过。这可能涉及清理你刚刚编写的代码，或改进受更改影响的代码库其他部分。
  5. 为每个新测试 **重复** 该循环，渐进式地构建并改进代码库。
  下面是一个简单的 TypeScript 示例：
  ```typescript
  // 两个数字相加函数的初始失败测试
  test('adds 1 + 2 to equal 3', () => {
    expect(add(1, 2)).toBe(3);
  });

  // 使测试通过的实现
  function add(a: number, b: number): number {
    return a + b; // 通过测试的最简单实现
  }
  ```
  记住，目标是编写刚好足够通过测试的代码，不要预测未来的需求或添加额外功能。这能保持开发专注并避免过度工程。

- **在 TDD 中“重构”意味着什么？**
  在 TDD 中，重构是指改善现有代码内部结构而不改变其外部行为的过程。这是 **红-绿-重构循环 (Red-Green-Refactor)** 中测试通过（绿色阶段）后的关键步骤。目标是增强代码可读性、降低复杂性并提高 **[可维护性 (maintainability)](/wiki/maintainability)**，同时确保系统的功能保持不变。
  在重构期间，你可能会：
  - **简化代码**：分解复杂方法。
  - **消除重复**：遵守 DRY (Don't Repeat Yourself) 原则。
  - **改进命名**：为变量、方法和类使用更能反映其用途的名字。
  - **重新组织代码**：改善其逻辑结构。
  - **优化性能**：在不影响结果的前提下更改算法。
  现有测试的“安全网”支持着重构，代码更改后测试必须继续通过。这确保了重构不会引入新 **[缺陷 (bugs)](/wiki/bug)**。这是一个迭代过程，增量地改进代码库，使其随着时间的推移更容易扩展和维护。
  下面是一个简单的 TypeScript 示例：
  ```typescript
  // 重构前
  function calculateArea(diameter) {
    return Math.PI * (diameter / 2) * (diameter / 2);
  }

  // 重构后
  function calculateRadius(diameter) {
    return diameter / 2;
  }

  function calculateArea(diameter) {
    const radius = calculateRadius(diameter);
    return Math.PI * radius * radius;
  }
  ```
  在这个例子中，`calculateArea` 函数被重构为使用新的 `calculateRadius` 函数，提高了可读性，并使 `calculateRadius` 的逻辑潜在具有可重用性。

#### TDD 实践
- **实施 TDD 的一些最佳实践有哪些？**
  实施 TDD 的最佳实践：
  - **从小处着手 (Start small)**：从简单的测试开始，然后再逐步过渡到更复杂的场景。这有助于理解流程，并保持对一次解决一个问题的专注。
  - **每个测试验证一个概念 (Test one concept per test)**：确保每个 **[测试用例 (test case)](/wiki/test-case)** 专注于单一行为或功能，以简化调试并提供清晰的意图。
  - **保持测试快速 (Keep tests fast)**：优化 **[测试执行 (test execution)](/wiki/test-execution)** 时间以鼓励频繁运行测试，这对于即时反馈至关重要。
  - **使用描述性的测试名称 (Use descriptive test names)**：清晰地命名测试以传达其目的和预期结果，辅助 **[可维护性 (maintainability)](/wiki/maintainability)** 和可读性。
  - **自信地重构 (Refactor with confidence)**：进入绿色阶段后，在保持测试通过的同时重构代码，以在不改变行为的前提下提高代码质量。
  - **隔离测试 (Isolate tests)**：避免测试之间的依赖关系，以确保它们可以独立且按任何顺序运行。
  - **测试接口而非实现 (Test the interface, not the implementation)**：关注预期行为而非内部工作机制，以避免在重构时产生脆弱的测试。
  - **使用版本控制 (Use version control)**：在每个通过的测试循环后提交代码，以记录开发过程并在必要时方便回滚。
  - **结对编程 (Pair programming)**：与另一名开发人员协作，获取不同视角并增强 **[测试覆盖率 (test coverage)](/wiki/test-coverage)**。
  - **持续集成 (CI)**：将 TDD 与 CI 系统集成，在每次提交时自动运行测试，确保立即检测到集成问题。
  - **保持自律 (Stay disciplined)**：严格遵守红-绿-重构循环，以保持 TDD 流程的完整性。
  - **审查与调整 (Review and adapt)**：定期评估你的测试和 TDD 方法的有效性，并对调整策略以改进结果保持开放态度。

- **如何将 TDD 集成到现有项目中？**
  将 TDD 集成到现有项目需要战略性的方法。
  - **选择一小块易处理的应用程序部分**：从新功能或需要重构的模块开始应用 TDD。这允许团队在不感到压力的情况下适应 TDD 工作流。
  - **培训团队**：如果团队尚不熟悉，请开展 TDD 实践教育。确保每个人都理解测试先行和红-绿-重构循环的重要性。鼓励结对编程以在团队内传播 TDD 知识和实践。
  - **设置专用分支**：为 TDD 工作设置一个专门的分支，以避免干扰主代码库。这允许在不影响进行中开发的前提下进行实验和学习。
  - **持续集成**：定期将 TDD 分支合并回主代码库。这有助于及早发现集成问题，并降低与主开发努力偏离过远的风险。
  - **增量重构遗留代码**：当你需要在现有代码中添加功能或修复 **[缺陷 (bug)](/wiki/bug)** 时，先为该特定部分编写测试，然后再进行更改。随着时间的推移，这将增加遗留代码的 **[测试覆盖率 (test coverage)](/wiki/test-coverage)**。
  - **自动化构建和 [测试过程 (test process)](/wiki/test-process)**：使用 CI/CD 工具确保测试自动且频繁运行，提供关于代码健康状况的即时反馈。
  - **监控并调整**：利用复盘会议讨论什么运作良好，什么不奏效，并据此调整方法。持续改进是成功将 TDD 集成到现有项目的关键。

- **TDD 中常见的陷阱有哪些，如何避免它们？**
  TDD 中的常见陷阱包括：
  - **过度依赖单元测试**：虽然单元测试至关重要，但它们无法捕获集成问题。应平衡 TDD 与更高级别的测试，以确保全系统的功能。
  - **重构不足**：跳过重构步骤会导致代码债务和维护问题。务必分配时间进行重构以保持代码质量。
  - **预先编写太多测试**：这会导致代码过于僵化而难以重构。应只编写足够的测试来驱动下一小部分功能的开发。
  - **测试内部实现**：专注于行为而非内部结构，以避免随代码结构更改而断裂的脆弱测试。
  - **未测试边缘情况**：确保测试覆盖广泛的输入，包括边缘情况，以防止在不太常见的场景中出现 **[缺陷 (bugs)](/wiki/bug)**。
  - **忽视测试的 [可维护性 (maintainability)](/wiki/maintainability)**：测试代码应像生产代码一样整洁且易维护。使用描述性名称，并结构化测试以利于理解和修改。
  - **缺乏持续集成**：将 TDD 与 CI/CD 流水线集成，以及早捕获问题并确保测试被频繁运行。
  通过以下方式避免这些陷阱：
  - 平衡不同层级的测试（单元、集成、系统）。
  - 定期重构，并像对待生产代码一样尊重测试代码。
  - 增量地编写测试，并关注代码行为。
  - 频繁运行测试，并将其集成到 CI/CD 工作流中。
  - 审查并维护测试，以保持其有效性和相关性。

- **TDD 如何与其他的软件开发方法论结合使用？**
  TDD 可以与各种软件开发方法论无缝集成，以增强其有效性并从一开始就确保 **[质量保证 (quality assurance)](/wiki/quality-assurance)**。
  - 在 **敏捷 (Agile)** 环境中，TDD 补充了迭代开发，允许为小的增量功能编写测试，确保每个 **[迭代 (iteration)](/wiki/iteration)** 都能产生一个通过所有测试的潜在可交付产品。这种协同作用通过提供即时反馈来支持持续集成和交付。
  - 在 **[Scrum](/wiki/scrum)** 中，TDD 通过在开发开始前将验收标准定义为测试来与 Sprint 保持一致。这确保了 Sprint 目标的达成，并使开发的功能得到充分测试，为 Sprint 评审贡献可演示的工作软件。
  - 在 **[极限编程 (Extreme Programming, XP)](/wiki/extreme-programming)** 中，TDD 是一项核心实践。它与 XP 对频繁发布和简洁性的强调相吻合，确保代码在短循环中经过彻底测试和重构，从而增强代码质量和 **[可维护性 (maintainability)](/wiki/maintainability)**。
  - 对于 **看板 (Kanban)**，TDD 提供了维持流动效率的手段。通过防止缺陷流向更下游，TDD 有助于减少与 **[缺陷 (bug)](/wiki/bug)** 修复和返工相关的瓶颈，从而支持看板对持续流动的关注。
  - 在 **精益软件开发 (Lean Software Development)** 中，TDD 通过在开发过程早期预防缺陷来帮助消除浪费。这种积极主动的方法符合精益原则，避免了后期缺陷治理带来的额外成本和延迟。
  将 TDD 与这些方法论集成需要转变观念以优先考虑测试，并承诺维护一个稳健的自动化测试套件。通过这样做，团队可以跨不同的开发实践利用 TDD 的优势，从而提升整体 **[软件质量 (software quality)](/wiki/software-quality)** 和团队敏捷性。

- **适用于 TDD 的工具和框架有哪些？**
  多种工具和框架在不同编程语言和平台上促进了 TDD：
  - **JUnit**：广泛使用的 Java 单元测试框架。
  - **[NUnit](/wiki/nunit)**：类似于 JUnit，但用于 .NET 环境。
  - **TestNG**：提供更高级的功能，如注解、参数化测试以及对数据驱动测试的支持（Java）。
  - **RSpec**：专注于 BDD 的 Ruby 工具，提供可读的语言来描述测试。
  - **Mocha**：灵活且支持异步测试的 JavaScript 框架，常与 Chai 等断言库配合使用。
  - **[Jest](/wiki/jest)**：因 React 应用而流行，包含快照测试和交互式监测模式（JavaScript）。
  - **pytest**：支持 Python 的简单单元测试和复杂功能测试。
  - **xUnit**：用于 .NET 框架的开源单元测试工具。
  - **PHPUnit**：面向程序员的 PHP 测试框架。
  - **Quick**：用于 Swift 和 Objective-C 的 BDD 框架。
  Java 中 JUnit 的使用示例：
  ```java
  import static org.junit.Assert.assertEquals;
  import org.junit.Test;

  public class CalculatorTest {
      @Test
      public void testAddition() {
          Calculator calculator = new Calculator();
          assertEquals(5, calculator.add(2, 3));
      }
  }
  ```
  这些工具通常与 CI/CD 流水线集成，由于在构建和部署过程中支持自动化 **[测试执行 (test execution)](/wiki/test-execution)**。选择合适的工具取决于语言、项目需求以及个人或团队偏好。

#### 高级概念
- **模拟对象 (Mock objects) 在 TDD 中的作用是什么？**
  模拟对象在 **[测试驱动开发 (TDD)](/wiki/test-driven-development)** 中发挥着至关重要作用，它以受控方式模拟真实对象的行为。当由于以下原因导致将实际对象纳入测试不切实际时，就会使用模拟对象：
  - 测试编写时该对象尚不存在。
  - 设置起来高度复杂或因难。
  - 性能缓慢会阻碍测试执行。
  - 网络或数据库依赖性使得测试可靠性或确定性降低。
  在 TDD 中，测试在生产代码之前编写。模拟允许在与依赖项隔离的情况下测试代码单元。这在遵循 **红-绿-重构 (Red-Green-Refactor)** 循环时尤为重要，因为它使开发人员能够专注于业务逻辑，而无需在初始阶段担心集成部分。
  通过使用模拟对象，你可以：
  - **指定预期的交互**：在测试中定义模拟对象应该如何被调用以及应该返回什么。
  - **验证系统交互**：确认被测系统按预期与模拟对象交互，确保使用正确的参数调用了正确的方法。
  - **测试不同场景**：通过配置模拟对象返回各种输出或抛出异常，这有助于实现彻底的测试覆盖。
  模拟对象对于维护一套快速且可靠的测试套件（这是 TDD 的基石）至关重要。它们有助于确保每个测试保持专注于单一功能，并且整个套件可以快速且确定地运行。

- **TDD 如何处理复杂系统和依赖项的测试？**
  TDD 通过强调 **增量开发** 和组件 **隔离** 来处理复杂系统和依赖项。对于复杂系统，在实现相应代码之前，先为小的、可管理的功点编写测试。这种方法确保了在集成到更大的系统之前，每个组件都在隔离状态下经过彻底测试。
  依赖项使用 **模拟 (mocks)** 或 **桩 (stubs)** 进行管理，以模拟复杂依赖模块的行为。这允许开发人员编写专注于目标单元而不会受外部因素影响的测试。例如：
  ```javascript
  // 在测试中使用模拟对象的示例
  it('应该调用依赖方法', () => {
    const mockDependency = { dependencyMethod: jest.fn() };
    const systemUnderTest = new SystemUnderTest(mockDependency);

    systemUnderTest.performAction();

    expect(mockDependency.dependencyMethod).toHaveBeenCalled();
  });
  ```
  通过使用模拟，测试可以验证与依赖项的交互，而不需要实际的实现就在场。当涉及外部服务、**[数据库 (databases)](/wiki/database)** 或其他在 **[测试环境 (test environment)](/wiki/test-environment)** 中不易控制或复制的系统时，此技术特别有用。
  对于 TDD 背景下的 **[集成测试 (integration testing)](/wiki/integration-testing)**，开发人员可能会使用 **契约测试 (contract tests)** 来确保系统不同部分之间的交互符合约定的接口。这有助于在开发周期的早期捕获集成问题。
  总体而言，TDD 的迭代特性结合模拟和契约测试的使用，可以有效管理并测试复杂系统及其依赖项。

- **什么是行为驱动开发 (BDD)，它与 TDD 有什么关系？**
  **[行为驱动开发 (BDD)](/wiki/bdd)** 是 **[测试驱动开发 (TDD)](/wiki/test-driven-development)** 的扩展，它强调开发人员、QA 团队以及软件项目中的非技术人员或业务参与者之间的协作。**[BDD](/wiki/bdd)** 的核心是通过对话和具体的例子，获得对期望软件行为的清晰理解，然后将其转化为一套自动化测试（通常以类似自然语言的格式表达）。
  **[BDD](/wiki/bdd)** 与 TDD 的关系在于它也提倡在编写实现功能的代码之前先编写测试。然而，TDD 的测试通常基于开发人员的视角且多处于单元级别，而 **[BDD](/wiki/bdd)** 的测试则是源于用户的视角，更多是关乎系统行为。这些测试通常被称为“场景”或“规范”，并使用一种可转化为自动化测试的领域专用语言编写。
  下面是一个 **[BDD](/wiki/bdd)** 场景示例：
  ```gherkin
  功能：用户登录
    场景：使用有效凭据成功登录
      假设 用户在登录页面
      当 用户输入有效凭据
      那么 用户被重定向到主页
  ```
  Cucumber 或 SpecFlow 等 **[BDD](/wiki/bdd)** 工具会解释这些场景并将其链接到底层测试代码。这些场景促进了利益相关者之间的沟通，并确保各方对功能及其预期行为有共同的理解。这种对齐有助于防止误解，并确保构建的软件符合业务的需求和预期。

- **什么是验收测试驱动开发 (ATDD)，它与 TDD 有什么关系？**
  **验收测试驱动开发 (ATDD)** 是一种让团队共同讨论带有案例的验收标准，并在开发开始前将其提炼为一套具体的验收测试的方法。这是一种让用户、测试人员和开发人员共同定义自动化验收标准的协作实践。ATDD 确保所有利益相关者对需求有着共同的理解。
  ATDD 与 TDD 密切相关，但 TDD 侧重于开发人员视角下的 **[单元测试 (unit testing)](/wiki/unit-testing)**，而 ATDD 更多是关乎客户和系统功能。在 ATDD 中，验收测试是从用户故事中创建的，这些测试指导整个开发过程，就像单元测试在 TDD 中所起的作用一样。
  以下是 ATDD 如何补充 TDD 的方式：
  - **TDD**：编写一个失败的单元测试 -> 使其通过 -> 重构。
  - **ATDD**：编写一个失败的验收测试 -> 实现功能（在此过程中使用 TDD 处理各单元） -> 使验收测试通过 -> 重构。
  ATDD 通常涉及在编写代码之前为用户故事创建一个详细的自动化测试，而 TDD 则是为一小部分功能（通常在类或方法级别）编写测试，然后编写代码以通过测试。这两项实践都旨在确保代码库的稳健和无回归，但 ATDD 将验证扩展到了功能或系统级别，确保软件满足了业务需求。

- **在 TDD 中处理遗留代码的一些策略有哪些？**
  在利用 TDD 处理 **遗留代码 (legacy code)** 时，请考虑以下策略：
  - **从编写特征描述测试 (characterization tests) 开始**：以捕捉系统的当前行为。这些测试作为未来更改的安全网。
    ```javascript
    test('表征遗留函数的行为', () => {
      expect(legacyFunction(input)).toEqual(expectedOutput);
    });
    ```
  - **识别代码中的接缝 (seams)**：在这些位置，你可以在不改变行为的前提下引入测试。所谓接缝是指在不修改某处代码的情况下可以更改代码行为的地方。
  - **谨慎重构**：以避免破坏现有功能。进行小的增量更改，并频繁运行测试。
  - **使用萌芽方法 (Sprout Method)**：来添加新功能。在新的方法中编写新代码（你可以使用 TDD 进行测试），而不是直接修改遗留代码。
  - **应用包装方法 (Wrap Method)**：当你需要更改遗留代码时，创建一个委托给旧代码的包装器，然后主逐渐将功能移入新的包装器，并边做边测。
  - 使用模拟或桩来 **隔离外部依赖**，以便在隔离状态下测试代码。
  - **针对高风险或变更频繁的区域优先进行 [测试覆盖 (test coverage)](/wiki/test-coverage)**：以最大化你的努力价值。
  - **邀请利益相关者参与**：以理解遗留系统的预期行为，确保你的测试反映了真实世界的使用情况。
  - **培训你的团队**：了解在遗留系统演进过程中维护新测试并遵循 TDD 实践的重要性。
  通过结合这些策略，你可以将 TDD 的优势带到遗留系统中，提高其 **[可维护性 (maintainability)](/wiki/maintainability)** 和可靠性。

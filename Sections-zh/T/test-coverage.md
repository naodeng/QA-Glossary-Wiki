# 测试覆盖率

<!-- TOC START -->
- [相关术语：](#相关术语：)
- [关于测试覆盖率的问题？](#关于测试覆盖率的问题？)
  - [基础知识和重要性](#基础知识和重要性)
    - [软件测试中的测试覆盖率是什么？](#软件测试中的测试覆盖率是什么？)
    - [为什么测试覆盖率在软件测试中很重要？](#为什么测试覆盖率在软件测试中很重要？)
    - [高测试覆盖率的主要好处是什么？](#高测试覆盖率的主要好处是什么？)
    - [测试覆盖率如何影响软件质量？](#测试覆盖率如何影响软件质量？)
    - [代码覆盖率和测试覆盖率有什么区别？](#代码覆盖率和测试覆盖率有什么区别？)
  - [测试覆盖率类型](#测试覆盖率类型)
    - [测试覆盖率有哪些不同类型？](#测试覆盖率有哪些不同类型？)
    - [函数覆盖率与语句覆盖率有何不同？](#函数覆盖率与语句覆盖率有何不同？)
    - [什么是分支覆盖以及如何使用它？](#什么是分支覆盖以及如何使用它？)
    - [测试覆盖率中的条件覆盖率是什么？](#测试覆盖率中的条件覆盖率是什么？)
    - [决策覆盖率如何影响整体测试覆盖率？](#决策覆盖率如何影响整体测试覆盖率？)
  - [测量和工具](#测量和工具)
    - [测试覆盖率是如何衡量的？](#测试覆盖率是如何衡量的？)
    - [衡量测试覆盖率常用的工具有哪些？](#衡量测试覆盖率常用的工具有哪些？)
    - [覆盖率指标在测试覆盖率中的作用是什么？](#覆盖率指标在测试覆盖率中的作用是什么？)
    - [如何在测试覆盖范围中使用覆盖图？](#如何在测试覆盖范围中使用覆盖图？)
    - [使用工具衡量测试覆盖率的最佳实践有哪些？](#使用工具衡量测试覆盖率的最佳实践有哪些？)
  - [策略和最佳实践](#策略和最佳实践)
    - [可以使用哪些策略来提高测试覆盖率？](#可以使用哪些策略来提高测试覆盖率？)
    - [如何确保我的测试覆盖范围全面？](#如何确保我的测试覆盖范围全面？)
    - [在追求高测试覆盖率时需要避免哪些常见陷阱？](#在追求高测试覆盖率时需要避免哪些常见陷阱？)
    - [如何平衡高测试覆盖率的需求和快速交付软件的需求？](#如何平衡高测试覆盖率的需求和快速交付软件的需求？)
    - [随着时间的推移保持高测试覆盖率有哪些最佳实践？](#随着时间的推移保持高测试覆盖率有哪些最佳实践？)
<!-- TOC END -->

测试覆盖率

测量测试的程序代码部分。它标识了期间执行的代码部分

测试用例

，确保全面评估。

## 相关术语：

- [Code Coverage](../C/code-coverage.md)

## 关于测试覆盖率的问题？

### 基础知识和重要性

#### 软件测试中的测试覆盖率是什么？

[software testing](../S/software-testing.md) 中的[Test coverage](../T/test-coverage.md) 指的是[test suite](../T/test-suite.md) 评估被测应用程序的程度。它是一种通过考虑各种标准（例如功能数量、代码路径或测试检查的条件）来量化执行的测试量的指标。 **[code coverage](../C/code-coverage.md)** 专门衡量测试期间执行了多少代码库，而 **[test coverage](../T/test-coverage.md)** 涵盖了更广泛的视角，包括需求、风险和用户场景。
  为了确保 [test coverage](../T/test-coverage.md) 是全面的，将测试映射到需求并识别关键功能可能未得到充分测试的任何差距至关重要。这涉及彻底分析应用程序以确定所有可能的[use cases](../U/use-case.md)，然后编写测试来执行这些场景。
  **覆盖率指标**可作为衡量 [test suite](../T/test-suite.md) 有效性的指南。常见指标包括**函数覆盖率**、**语句覆盖率**、**分支覆盖率**和**条件覆盖率**，每个指标侧重于代码和应用程​​序行为的不同方面。
  使用工具来测量[test coverage](../T/test-coverage.md)有助于自动化该过程，并为缺乏足够测试的区域提供视觉反馈。 Istanbul、JaCoCo 或 Clover 等工具是与持续集成管道集成的流行选择，可增强 [test automation](../T/test-automation.md) 工程师的反馈循环。
  为了随着时间的推移保持高[test coverage](../T/test-coverage.md)，请定期审查和更新测试，以适应新功能、代码更改和不断变化的用户需求。避免常见的陷阱，例如以牺牲测试质量为代价追求 100% 覆盖率，或者忽略测试不太明显但关键的系统行为。战略性地增加[test coverage](../T/test-coverage.md)涉及优先考虑高风险领域、重构测试以获得更好的[maintainability](../M/maintainability.md)以及持续监控覆盖率指标以深入了解潜在的改进。

#### 为什么测试覆盖率在软件测试中很重要？

[Test coverage](../T/test-coverage.md) 对于识别代码库中未经测试的部分至关重要，确保检查每个功能并尽早发现潜在缺陷。它作为衡量 [test suite](../T/test-suite.md) 覆盖其要验证的代码的有效性的指标。高[test coverage](../T/test-coverage.md) 可以降低[bugs](../B/bug.md) 投入生产的风险，从而实现更稳定的版本并增强对软件可靠性的信心。
  虽然争取 100% [test coverage](../T/test-coverage.md) 通常是不切实际的，但争取高百分比可以确保关键路径和边缘情况不会被忽视。它还有助于随着时间的推移保持代码质量，因为它要求测试与代码更改一起更新，从而防止回归。
  [Test coverage](../T/test-coverage.md) 也是重构决策中的一个关键因素，因为它提供了一个安全网，可以在不引入新的[bugs](../B/bug.md) 的情况下促进更改。它可以突出显示代码中过于复杂或未充分利用的区域，指导开发人员进行改进和优化。
  在持续集成环境中，可以随着时间的推移跟踪[test coverage](../T/test-coverage.md) 指标以监控代码库的运行状况。明智地解释这些指标非常重要，重点关注测试的质量而不仅仅是数量。覆盖范围应与其他质量实践（例如代码审查、静态分析和[manual testing](../M/manual-testing.md)）相补充，以确保全面的测试策略。

#### 高测试覆盖率的主要好处是什么？

高[test coverage](../T/test-coverage.md) 具有几个主要优点：

- **早期[Bug](../B/bug.md) 检测**：随着测试的代码库越来越多，在开发周期的早期捕获[bugs](../B/bug.md) 的机会就更大，从而减少以后修复它们的成本和工作量。
  - **重构信心**：高覆盖率提供了一个安全网，有利于信心十足的重构。工程师可以进行更改，因为他们知道测试会发现任何意外后果。
  - **文档**：测试充当文档的一种形式，显示系统的行为方式。高覆盖率意味着更多的行为被记录下来。
  - **设计反馈**：为高覆盖率编写测试通常会突出设计问题，例如紧密耦合或缺乏内聚力，从而改进软件设计。
  - **风险缓解**：它降低了回归风险，因为更改后会验证更多功能。
  - **利益相关者信心**：它可以增强利益相关者对应用程序经过彻底测试且可靠的信心。
  - **持续集成 (CI) 效率**：在 CI 管道中，高覆盖率可确保每次集成时都会检查大多数代码路径，从而使管道更加健壮。
  - **代码质量**：它通常与更高的代码质量相关，因为编写测试所需的规则可以带来更好的编码实践。
  请记住，虽然高 [test coverage](../T/test-coverage.md) 是有益的，但它本身并不是目的。目标是创建一套有意义的测试，为软件的行为提供价值和信心。

- **早期[Bug](../B/bug.md) 检测**：随着测试的代码库增多，在开发周期的早期捕获[bugs](../B/bug.md) 的机会就更大，从而减少了以后修复它们的成本和工作量。
  - **重构信心**：高覆盖率提供了一个安全网，有利于信心十足的重构。工程师可以进行更改，因为他们知道测试会发现任何意外后果。
  - **文档**：测试充当文档的一种形式，显示系统的行为方式。高覆盖率意味着更多的行为被记录下来。
  - **设计反馈**：为高覆盖率编写测试通常会突出设计问题，例如紧密耦合或缺乏内聚力，从而改进软件设计。
  - **风险缓解**：它降低了回归风险，因为更改后会验证更多功能。
  - **利益相关者信心**：它可以增强利益相关者对应用程序经过彻底测试且可靠的信心。
  - **持续集成 (CI) 效率**：在 CI 管道中，高覆盖率可确保每次集成时都会检查大多数代码路径，从而使管道更加健壮。
  - **代码质量**：它通常与更高的代码质量相关，因为编写测试所需的规则可以带来更好的编码实践。

#### 测试覆盖率如何影响软件质量？

[Test coverage](../T/test-coverage.md) 会暴露未经测试的代码区域，从而直接影响**软件质量**，这些区域可能包含未检测到的[bugs](../B/bug.md) 或问题。高 [test coverage](../T/test-coverage.md) 通常与较低的缺陷率相关，因为根据需求验证了更多代码路径并探索了潜在的边缘情况。然而，重要的是要明白，[test coverage](../T/test-coverage.md) 本身并不是灵丹妙药。测试的有效性同样重要。测试需要精心设计以断言正确的行为，并且覆盖率指标应该用于指导质量工作，而不是定义它们。
  覆盖率差距可以作为可能需要额外测试的地方的指南，但要注意 **以 100% 覆盖率为目标的陷阱**。它可能会导致错误的安全感，并且可能不具有成本效益。相反，重点关注**基于风险的覆盖范围**，优先考虑具有更高业务影响或更容易出错的关键路径和功能。
  请记住，高 [test coverage](../T/test-coverage.md) 可以降低 **回归** 的可能性，因为更多代码正在接受自动检查的审查。这可以实现更安全的重构，并可以通过尽早发现问题来加快开发过程。然而，平衡是关键；维持与项目目标和时间表相一致的 [test coverage](../T/test-coverage.md) 战略方法。使用覆盖率数据就测试工作的重点做出明智的决定，确保应用程序最重要的方面得到彻底测试，并且[test automation](../T/test-automation.md)仍然是维护[software quality](../S/software-quality.md)的宝贵资产。

#### 代码覆盖率和测试覆盖率有什么区别？

[Code coverage](../C/code-coverage.md) 和[test coverage](../T/test-coverage.md) 是在[software testing](../S/software-testing.md) 中经常互换使用的术语，但它们具有不同的含义。
  **[Code coverage](../C/code-coverage.md)** 是一个量化 [test suite](../T/test-suite.md) 运行时执行的代码量的指标。它通常以百分比来衡量，并且可以分为各种类型，例如语句覆盖率、分支覆盖率和函数覆盖率。 [Code coverage](../C/code-coverage.md) 提供了测试已执行哪些代码行的精细技术视图。

  ```
  // Example: A simple function and test case
  function add(a, b) {
    return a + b;
  }
  // Test case covering the add function
  test('adds 1 + 2 to equal 3', () => {
    expect(add(1, 2)).toBe(3);
  });
  ```在上面的示例中，`add` 函数的 [test case](../T/test-case.md) 将导致 `add` 的 100% 函数覆盖率，但如果代码库中有更多函数未被测试覆盖，则总体函数覆盖率将会较低。
  另一方面，**[Test coverage](../T/test-coverage.md)** 是一个更广泛的术语，涵盖了评估测试有效性的所有努力。它包括 [code coverage](../C/code-coverage.md) 作为其指标之一，但也考虑了测试的质量和范围，包括是否进行了不同类型的测试（如单元、集成、系统）以及它们是否涵盖了应用程序功能、用户场景和需求的各个方面。
  本质上，[code coverage](../C/code-coverage.md) 关注的是代码本身，而 [test coverage](../T/test-coverage.md) 则关注测试验证软件功能和需求的程度。两者对于理解[test suite](../T/test-suite.md) 的有效性都很重要，但[test coverage](../T/test-coverage.md) 提供了该软件的[quality assurance](../Q/quality-assurance.md) 的更全面的视图。

### 测试覆盖率类型

#### 测试覆盖率有哪些不同类型？

不同类型的 [test coverage](../T/test-coverage.md) 包括：

- **路径覆盖**：确保执行代码给定部分的每条可能的路线。这包括循环和条件路径。
  - **数据流覆盖**：重点关注变量接收值的点以及使用这些值的点。
  - **进入/退出覆盖**：测试程序流程中所有可能的调用和返回行为是否被执行。
  - **循环覆盖**：确保循环执行零次迭代、一次迭代和多次迭代。
  - **状态覆盖**：验证软件是否正确处理有限状态机内的每个状态。
  - **参数值覆盖**：测试采用多个参数的方法、构造函数或系统的参数值的所有组合。
  - **错误处理覆盖率**：确保触发并正确处理所有可能的错误或异常情况。
  - **手动[Test Coverage](../T/test-coverage.md)** ：跟踪软件的哪些部分已经通过手动测试进行了测试。
  - **自动化[Test Coverage](../T/test-coverage.md)** ：指示自动化测试测试的代码库的范围。
  - **UI 覆盖**：确保所有用户界面元素都经过功能和可用性测试。
  - **安全覆盖**：重点测试代码是否存在安全威胁和漏洞。
  - **性能覆盖率**：测试系统的性能，包括负载、压力和可扩展性测试。
  每种类型的覆盖范围都针对软件的不同方面，以确保全面的测试策略。组合多种覆盖类型可以更全面地了解软件的可靠性和稳健性。

- **路径覆盖**：确保执行代码给定部分的每条可能的路线。这包括循环和条件路径。
  - **数据流覆盖**：重点关注变量接收值的点以及使用这些值的点。
  - **进入/退出覆盖**：测试程序流程中所有可能的调用和返回行为是否被执行。
  - **循环覆盖**：确保循环执行零次迭代、一次迭代和多次迭代。
  - **状态覆盖**：验证软件是否正确处理有限状态机内的每个状态。
  - **参数值覆盖**：测试采用多个参数的方法、构造函数或系统的参数值的所有组合。
  - **错误处理覆盖率**：确保触发并正确处理所有可能的错误或异常情况。
  - **手动[Test Coverage](../T/test-coverage.md)** ：跟踪软件的哪些部分已经通过手动测试进行了测试。
  - **自动化[Test Coverage](../T/test-coverage.md)** ：指示自动化测试测试的代码库的范围。
  - **UI 覆盖**：确保所有用户界面元素都经过功能和可用性测试。
  - **安全覆盖**：重点测试代码是否存在安全威胁和漏洞。
  - **性能覆盖率**：测试系统的性能，包括负载、压力和可扩展性测试。

#### 函数覆盖率与语句覆盖率有何不同？

函数覆盖率和语句覆盖率都是用于评估测试所执行的代码范围的指标，但它们侧重于代码库的不同粒度。
  **函数覆盖率**衡量代码中的每个函数（或方法）在测试过程中是否被调用。它不考虑函数的内部逻辑测试得有多彻底，只考虑它至少被执行过一次。

  ```
  function add(a, b) {
    return a + b;
  }
  function subtract(a, b) {
    // This function's coverage is not fulfilled if never called during tests
    return a - b;
  }
  ```相反，**语句覆盖率**评估代码中的每个单独语句是否已被执行。它提供了比函数覆盖更精细的细节，因为它要求运行函数中的每个语句。

  ```
  function calculate(a, b, operation) {
    if (operation === 'add') {
      return a + b; // Statement 1
    } else if (operation === 'subtract') {
      return a - b; // Statement 2
    }
    return 0; // Statement 3
  }
  ```如果 [test suite](../T/test-suite.md) 仅检查“add”操作，则函数覆盖率将为 100%，因为调用了 `calculate` 函数，但语句覆盖率将低于 100%，因为语句 2 和语句 3 从未执行。
  总之，函数覆盖率是一个更广泛的指标，确保每个函数都经过测试，而语句覆盖率需要更彻底的检查，确保这些函数中的每一行代码都被执行。

#### 什么是分支覆盖以及如何使用它？

分支覆盖，也称为**决策覆盖**，确保每个决策点的每个可能的分支至少执行一次。例如，在 `if` 语句的上下文中，应该测试 true 和 false 分支。
  要应用分支覆盖，请识别代码中的所有决策点，例如 `if`、`else`、`switch` 和循环语句。然后，创建遍历每个可能路径的[test cases](../T/test-case.md)。这比语句覆盖范围更细化，语句覆盖范围可能不需要测试条件的所有分支。
  考虑以下伪代码：

  ```
  if (condition) {
    // Branch 1
  } else {
    // Branch 2
  }
  ```为了实现完整的分支覆盖，您需要编写满足`condition`及其否定的测试，确保两个分支都被执行。
  分支覆盖率用于：

- 检测语句覆盖可能遗漏的特定分支中的缺陷。
  - 确保错误处理和边缘情况经过测试。
  - 提高测试套件的稳健性。
  虽然分支覆盖可以提高测试质量，但这并不是灵丹妙药。它不保证所有路径的执行（路径覆盖）或分支内所有逻辑条件的测试（条件覆盖）。它是用于评估测试工作彻底性的几个指标之一。 [Test automation](../T/test-automation.md) 工程师应将其与其他覆盖类型结合起来以创建全面的[test suite](../T/test-suite.md)。

- 检测语句覆盖可能遗漏的特定分支中的缺陷。
  - 确保错误处理和边缘情况经过测试。
  - 提高测试套件的稳健性。

#### 测试覆盖率中的条件覆盖率是什么？

条件覆盖率也称为谓词覆盖率，是 [test coverage](../T/test-coverage.md) 中的一个度量标准，用于评估决策点内的每个布尔子表达式是否已被评估为 `true` 和 `false`。这与决策覆盖不同，决策覆盖侧重于评估 `true` 和 `false` 的决策点本身。
  例如，考虑代码中基于两个条件的决策：

  ```
  if (conditionA && conditionB) {
      // do something
  }
  ```为了实现完整的条件覆盖，测试必须设计为独立评估 `conditionA` 和 `conditionB` 这两个结果。这至少需要以下场景：

1.`conditionA`
    是
    `true`
    ,
    `conditionB`
    是
    `true`
    。

2.`conditionA`
    是
    `false`
    ,
    `conditionB`
    没关系。

3.`conditionA`
    没关系，
    `conditionB`
    是
    `true`
    。

4.`conditionA`
    没关系，
    `conditionB`
    是
    `false`
    。
  条件覆盖比决策覆盖更精细，可以揭示决策覆盖可能遗漏的问题，例如复杂决策中的错误逻辑。但是，实现 100% 条件覆盖率并不能保证检测到与决策逻辑相关的所有[bugs](../B/bug.md)，因为它没有覆盖所有可能的条件组合（这是通过多个条件覆盖来解决的）。
  在实践中，条件覆盖有助于识别边缘情况，并通过确保条件表达式的每个部分都经过独立测试来提高 [test suites](../T/test-suite.md) 的稳健性。

1.`conditionA`
    是
    `true`
    ,
    `conditionB`
    是
    `true`
    。

2.`conditionA`
    是
    `false`
    ,
    `conditionB`
    没关系。

3.`conditionA`
    没关系，
    `conditionB`
    是
    `true`
    。

4.`conditionA`
    没关系，
    `conditionB`
    是
    `false`
    。

#### 决策覆盖率如何影响整体测试覆盖率？

决策覆盖率也称为**分支覆盖率**，通过确保每个决策点的每个可能的分支至少执行一次，增强了整体[test coverage](../T/test-coverage.md)。这意味着每个决策语句的所有真/假结果（例如 `if` 条件）都会在测试期间进行评估。
  与仅确认每行代码已执行的**语句覆盖**相比，决策覆盖通过验证所有分支是否都产生正确的结果来提供更细粒度的测试。这很重要，因为它有助于发现特定条件可能导致错误或意外行为的场景。
  例如，考虑以下伪代码：

  ```
  if (conditionA) {
      // Branch 1
  } else {
      // Branch 2
  }
  ```为了实现决策覆盖，必须设计测试来评估`conditionA`、`true`（分支1）和`false`（分支2）。这确保了处理两种情况的逻辑都是正确的，并且识别出潜在的[bugs](../B/bug.md)。
  通过关注决策点，[test automation](../T/test-automation.md) 工程师可以创建更强大的[test suites](../T/test-suite.md)，以更好地评估软件的逻辑和决策能力。这有助于实现高 [test coverage](../T/test-coverage.md) 的总体目标，即降低缺陷风险并提高软件的可靠性。

### 测量和工具

#### 测试覆盖率是如何衡量的？

[Test coverage](../T/test-coverage.md) 通过确定[test suite](../T/test-suite.md) 已使用的软件比例来量化。这通常是通过使用监控和报告各种覆盖标准的专用工具来完成的。以下是测量 [test coverage](../T/test-coverage.md) 的简明方法：

1. **选择覆盖标准**：决定与您的项目相关的覆盖类型，例如语句、分支或路径覆盖。
  2. **检测代码**：使用工具检测代码库，它将跟踪测试期间执行的代码部分。
  3. **运行[test suite](../T/test-suite.md)**：针对检测的代码执行自动化测试。
  4. **收集数据**：该工具将收集有关代码的哪些部分被执行的数据。
  5. **分析结果**：查看工具生成的覆盖率报告，以确定覆盖率方面的差距。
  6. **相应地调整测试**：编写额外的测试以覆盖未覆盖的代码或删除冗余测试。
  例如，在 JavaScript 项目中，您可以使用 Istanbul (nyc) 来测量覆盖范围：

  ```
  nyc --reporter=html --reporter=text mocha
  ```此命令运行 Mocha [test suite](../T/test-suite.md) with Istanbul 收集覆盖率数据，输出 HTML 和文本摘要。
  请记住，虽然高覆盖率可以表明进行了彻底的测试，但它并不能保证不存在缺陷。覆盖范围应与其他质量衡量标准相平衡，例如良好的[test case](../T/test-case.md) 设计、同行评审和[manual testing](../M/manual-testing.md)。

1. **选择覆盖标准**：决定与您的项目相关的覆盖类型，例如语句、分支或路径覆盖。
  2. **检测代码**：使用工具检测代码库，它将跟踪测试期间执行的代码部分。
  3. **运行[test suite](../T/test-suite.md)**：针对检测的代码执行自动化测试。
  4. **收集数据**：该工具将收集有关代码的哪些部分被执行的数据。
  5. **分析结果**：查看工具生成的覆盖率报告，以确定覆盖率方面的差距。
  6. **相应地调整测试**：编写额外的测试以覆盖未覆盖的代码或删除冗余测试。

#### 衡量测试覆盖率常用的工具有哪些？

用于测量[test coverage](../T/test-coverage.md)的常用工具包括：

- **JaCoCo** ：与 Maven、Ant 和 Gradle 集成的 Java 代码覆盖库。
  - **Cobertura**：另一个报告行、分支和包覆盖率的 Java 工具。
  - **伊斯坦布尔（纽约）**：与 Node.js 配合使用并支持 ES6 的 JavaScript 覆盖工具。
  - **SimpleCov** ：对于 Ruby，通常与 RSpec 测试框架一起使用。
  - **gcov** ：与 GCC 一起分析 C/C++ 代码覆盖率的工具。
  - **lcov** ：gcov 的图形前端，提供 HTML 报告。
  - **Clover**：具有 IDE 集成的商业 Java 工具，现已由 Atlassian 开源。
  - **OpenCover** ：.NET 框架代码覆盖率工具，通常与 ReportGenerator 一起使用以生成可视化报告。
  - **dotCover**：与 ReSharper 和 Visual Studio 集成的 .NET 覆盖工具。
  - **EMMA**：一种较旧的 Java 代码覆盖工具，很大程度上已被 JaCoCo 取代。
  - **Slather** ：用于在 Swift 和 Objective-C 中生成测试覆盖率报告。
  - **Codecov**：一种在线服务，可以处理多种语言的覆盖率报告，并与 GitHub、Bitbucket 和 GitLab 集成。
  - **Coveralls** ：与 Codecov 类似，它与 GitHub 集成以跟踪一段时间内的代码覆盖率。
  这些工具可以集成到 CI/CD 管道中以自动生成覆盖率报告。他们通常通过仪表板、详细的文件细分和历史数据跟踪来提供见解。选择正确的工具取决于编程语言、现有的开发环境以及与其他开发工具所需的集成级别。

- **JaCoCo** ：与 Maven、Ant 和 Gradle 集成的 Java 代码覆盖库。
  - **Cobertura**：另一个报告行、分支和包覆盖率的 Java 工具。
  - **伊斯坦布尔（纽约）**：与 Node.js 配合使用并支持 ES6 的 JavaScript 覆盖工具。
  - **SimpleCov** ：对于 Ruby，通常与 RSpec 测试框架一起使用。
  - **gcov** ：与 GCC 一起分析 C/C++ 代码覆盖率的工具。
  - **lcov** ：gcov 的图形前端，提供 HTML 报告。
  - **Clover**：具有 IDE 集成的商业 Java 工具，现已由 Atlassian 开源。
  - **OpenCover** ：.NET 框架代码覆盖率工具，通常与 ReportGenerator 一起使用以生成可视化报告。
  - **dotCover**：与 ReSharper 和 Visual Studio 集成的 .NET 覆盖工具。
  - **EMMA**：一种较旧的 Java 代码覆盖工具，很大程度上已被 JaCoCo 取代。
  - **Slather** ：用于在 Swift 和 Objective-C 中生成测试覆盖率报告。
  - **Codecov**：一种在线服务，可以处理多种语言的覆盖率报告，并与 GitHub、Bitbucket 和 GitLab 集成。
  - **Coveralls** ：与 Codecov 类似，它与 GitHub 集成以跟踪一段时间内的代码覆盖率。

#### 覆盖率指标在测试覆盖率中的作用是什么？

覆盖率指标作为[test suite](../T/test-suite.md) 对软件评估程度的定量指标。它们提供了一个**数值**，反映了测试所执行的代码库的比例，提供了一种衡量测试工作有效性的方法。
  这些指标对于识别应用程序的**未经测试的部分**至关重要，这些部分可能隐藏着未检测到的[bugs](../B/bug.md)。通过突出显示覆盖率低的区域，他们将注意力转移到需要额外测试的潜在风险区域。
  此外，覆盖率指标可用于随着时间的推移**跟踪进度**，确保[test suite](../T/test-suite.md) 与应用程序一起发展。它们通过告知决策将测试资源集中在哪里以获得最大影响，帮助保持测试彻底性和开发速度之间的平衡。
  在持续集成 (CI) 环境中，覆盖率指标可以集成到构建过程中，为开发人员提供**实时反馈**。这种集成有助于防止代码更改，从而减少合并到代码库中的覆盖范围。
  然而，重要的是要记住，高覆盖率并不能保证不存在缺陷。覆盖率指标应与其他质量衡量标准相辅相成，例如**同行评审**、**[manual testing](../M/manual-testing.md)** 和 **[exploratory testing](../E/exploratory-testing.md)**，以确保全面的质量策略。
  总之，覆盖率指标是强大[test automation](../T/test-automation.md) 策略的重要组成部分，提供有助于优化[test coverage](../T/test-coverage.md) 和维护[software quality](../S/software-quality.md) 的见解。

#### 如何在测试覆盖范围中使用覆盖图？

**覆盖图**是一种视觉或数据驱动的表示形式，显示您的 [test cases](../T/test-case.md) 与其所覆盖的应用程序的要求或部分之间的关​​系。在[test coverage](../T/test-coverage.md) 中使用覆盖图可确保所有功能都经过测试，并有助于识别[test suite](../T/test-suite.md) 中的差距。
  要有效地使用覆盖图，请按照下列步骤操作：

1. **识别组件**：将应用程序分解为其组件、模块或功能。
  2. **将测试映射到组件**：将每个测试用例链接到它验证的组件。这可以手动完成或在测试管理工具的帮助下完成。
  3. **分析覆盖范围**：查看地图以识别未测试的组件或测试用例不足的区域。
  4. **根据风险确定优先级**：重点关注对应用程序性能至关重要或具有高故障风险的组件。
  5. **填补空白**：为未充分覆盖的组件创建额外的测试用例。
  6. **避免重复**：使用地图来发现并消除冗余测试，优化测试套件。
  7. **持续更新**：随着应用程序的发展，通过添加新组件和测试来保持覆盖图最新。
  在实践中，覆盖图可能看起来像一个表格或矩阵，一个轴上列出了组件，另一个轴上列出了[test cases](../T/test-case.md)，标记每个测试的应用位置。或者，更复杂的工具可能提供交互式可视化。

  ```
  // Example of a simple coverage map structure in code comments
  // Component: Login Functionality
  // Test Cases: TC_Login_001, TC_Login_002, TC_Login_003
  ```通过将覆盖图集成到您的[test strategy](../T/test-strategy.md)中，您可以确保采用结构化方法来实现全面的[test coverage](../T/test-coverage.md)，这可以带来更强大、更可靠的软件。

1. **识别组件**：将应用程序分解为其组件、模块或功能。
  2. **将测试映射到组件**：将每个测试用例链接到它验证的组件。这可以手动完成或在测试管理工具的帮助下完成。
  3. **分析覆盖范围**：查看地图以识别未测试的组件或测试用例不足的区域。
  4. **根据风险确定优先级**：重点关注对应用程序性能至关重要或具有高故障风险的组件。
  5. **填补空白**：为未充分覆盖的组件创建额外的测试用例。
  6. **避免重复**：使用地图来发现并消除冗余测试，优化测试套件。
  7. **持续更新**：随着应用程序的发展，通过添加新组件和测试来保持覆盖图最新。

#### 使用工具衡量测试覆盖率的最佳实践有哪些？

将覆盖率工具集成到您的 **CI/CD 管道**中，以确保每次构建的覆盖率测量保持一致。使用**预提交挂钩**或类似机制在合并代码之前检查覆盖率。
  为可接受的覆盖级别设置**阈值**，并通过构建过程强制执行它们。如果覆盖率低于一定百分比，则构建无法维持标准。
  专注于**有意义的报道**。确保测试覆盖关键路径和边缘情况，而不是瞄准任意百分比。使用覆盖率报告来识别代码库中未经测试的部分，但根据风险和重要性确定测试的优先级。
  采用**增量覆盖率跟踪**来确保新代码在编写时得到测试。这有助于防止与测试相关的技术债务。
  结合多种形式的覆盖范围（例如语句、分支、路径）以获得全面的视图。依赖单一指标可能会产生误导。
  定期**审查和重构测试**。随着代码的发展，测试也应该随之发展。删除冗余测试并更新现有测试以反映代码库中的更改。
  使用**覆盖率数据来指导代码审查**。突出显示在审查过程中未充分测试的代码区域。
  利用 **test [impact analysis](../I/impact-analysis.md) 工具** 仅运行受最近代码更改影响的测试，在保持覆盖范围的同时优化反馈循环。
  请记住，[test coverage](../T/test-coverage.md) 是达到目的的手段，而不是目的本身。低质量测试的高覆盖率可能比精心设计的测试的低覆盖率更糟糕。始终致力于有效验证代码行为的测试。

### 策略和最佳实践

#### 可以使用哪些策略来提高测试覆盖率？

要增加软件[test automation](../T/test-automation.md)中的[test coverage](../T/test-coverage.md)，请考虑以下策略：

- **优先考虑[risk-based testing](../R/risk-based-testing.md)**：重点关注故障风险最高或对用户影响最大的领域。使用历史数据和专家判断来识别这些区域。
  - **实施参数化测试**：创建可以使用不同输入数据集运行的测试，使您可以用更少的 [test cases](../T/test-case.md) 覆盖更多场景。
  - **利用测试设计技术**：利用[equivalence partitioning](../E/equivalence-partitioning.md)、边界值分析和成对测试来确保涵盖广泛的输入和条件。
  - **扩展自动化范围**：在自动化套件中包括集成、系统和端到端测试，而不仅仅是单元测试。
  - **使用模拟和存根**：模拟依赖关系以隔离测试组件并覆盖更多执行路径。
  - **执行[exploratory testing](../E/exploratory-testing.md)**：将自动化测试与手动[exploratory testing](../E/exploratory-testing.md)相结合，以发现自动化测试可能遗漏的区域。
  - **定期审查和更新测试**：随着应用程序的发展，更新您的测试以涵盖新功能并弃用过时的测试。
  - **与 CI/CD 集成**：作为持续集成/持续部署管道的一部分运行自动化测试，以确保覆盖每个构建。
  - **监控[flaky tests](../F/flaky-test.md)**：识别并修复可能削弱您对[test suite](../T/test-suite.md) 覆盖范围的信心的非确定性测试。
  - **利用覆盖工具**：Istanbul、JaCoCo 或 Clover 等工具可以帮助识别未经测试的代码路径。
  - **与开发者合作**：鼓励开发者编写单元测试并参与测试评审，以确保全面覆盖。
  - **从测试角度进行代码审查**：在代码审查期间寻找未经测试的逻辑和潜在的边缘情况。
  - **采用[Test-Driven Development](../T/test-driven-development.md) (TDD)**：在代码之前编写测试可以带来更好的[test coverage](../T/test-coverage.md) 和设计。
  通过实施这些策略，您可以系统地增加[test coverage](../T/test-coverage.md)并提高软件的质量。

- **优先考虑[risk-based testing](../R/risk-based-testing.md)**：重点关注故障风险最高或对用户影响最大的领域。使用历史数据和专家判断来识别这些区域。
  - **实施参数化测试**：创建可以使用不同输入数据集运行的测试，使您可以用更少的 [test cases](../T/test-case.md) 覆盖更多场景。
  - **利用测试设计技术**：利用[equivalence partitioning](../E/equivalence-partitioning.md)、边界值分析和成对测试来确保涵盖广泛的输入和条件。
  - **扩展自动化范围**：在自动化套件中包括集成、系统和端到端测试，而不仅仅是单元测试。
  - **使用模拟和存根**：模拟依赖关系以隔离测试组件并覆盖更多执行路径。
  - **执行[exploratory testing](../E/exploratory-testing.md)**：将自动化测试与手动[exploratory testing](../E/exploratory-testing.md)相结合，以发现自动化测试可能遗漏的区域。
  - **定期审查和更新测试**：随着应用程序的发展，更新您的测试以涵盖新功能并弃用过时的测试。
  - **与 CI/CD 集成**：作为持续集成/持续部署管道的一部分运行自动化测试，以确保覆盖每个构建。
  - **监控[flaky tests](../F/flaky-test.md)**：识别并修复可能削弱您对[test suite](../T/test-suite.md) 覆盖范围的信心的非确定性测试。
  - **利用覆盖工具**：Istanbul、JaCoCo 或 Clover 等工具可以帮助识别未经测试的代码路径。
  - **与开发者合作**：鼓励开发者编写单元测试并参与测试评审，以确保全面覆盖。
  - **从测试角度进行代码审查**：在代码审查期间寻找未经测试的逻辑和潜在的边缘情况。
  - **采用[Test-Driven Development](../T/test-driven-development.md) (TDD)**：在代码之前编写测试可以带来更好的[test coverage](../T/test-coverage.md) 和设计。

#### 如何确保我的测试覆盖范围全面？

为了确保 [test automation](../T/test-automation.md) 中的全面 [test coverage](../T/test-coverage.md)，请遵循以下策略：

- **优先考虑[risk-based testing](../R/risk-based-testing.md)** ：重点关注故障风险最高或对用户影响最大的领域。使用历史数据和专家判断来识别这些区域。
  - **实施[equivalence partitioning](../E/equivalence-partitioning.md)和边界值分析**：这有助于减少测试用例的数量，同时确保覆盖不同的输入范围。
  - **利用决策表**：它们有助于覆盖复杂的业务规则和逻辑条件。
  - **使用[state transition testing](../S/state-transition-testing.md)** ：这对于具有有限状态的应用程序至关重要，确保覆盖所有可能的转换。
  - **采用成对测试**：这是使用正交数组测试输入组合的有效方法，确保覆盖参数之间的相互作用。
  - **合并[exploratory testing](../E/exploratory-testing.md)** ：自动化测试可能会错过意外问题。通过手动探索性测试来补充它们，以发现隐藏的错误。
  - **利用基于模型的测试**：创建系统的抽象模型以生成覆盖所有可能路径的测试用例。
  - **执行组合测试**：使用工具生成涵盖输入参数所有可能组合的测试用例。
  - **定期审查和更新测试**：随着软件的发展，测试也应该如此。定期审查测试用例的相关性和完整性。
  - **与持续集成/持续部署 (CI/CD) 集成**：这可确保频繁运行测试并持续监控覆盖范围。
  请记住，目标不是实现 100% [test coverage](../T/test-coverage.md)，而是有效覆盖应用程序最关键的方面。

- **优先考虑[risk-based testing](../R/risk-based-testing.md)** ：重点关注故障风险最高或对用户影响最大的领域。使用历史数据和专家判断来识别这些区域。
  - **实施[equivalence partitioning](../E/equivalence-partitioning.md)和边界值分析**：这有助于减少测试用例的数量，同时确保覆盖不同的输入范围。
  - **利用决策表**：它们有助于覆盖复杂的业务规则和逻辑条件。
  - **使用[state transition testing](../S/state-transition-testing.md)** ：这对于具有有限状态的应用程序至关重要，确保涵盖所有可能的转换。
  - **采用成对测试**：这是使用正交数组测试输入组合的有效方法，确保覆盖参数之间的相互作用。
  - **合并[exploratory testing](../E/exploratory-testing.md)** ：自动化测试可能会错过意外问题。通过手动探索性测试来补充它们，以发现隐藏的错误。
  - **利用基于模型的测试**：创建系统的抽象模型以生成覆盖所有可能路径的测试用例。
  - **执行组合测试**：使用工具生成涵盖输入参数所有可能组合的测试用例。
  - **定期审查和更新测试**：随着软件的发展，测试也应该如此。定期审查测试用例的相关性和完整性。
  - **与持续集成/持续部署 (CI/CD) 集成**：这可确保频繁运行测试并持续监控覆盖范围。

#### 在追求高测试覆盖率时需要避免哪些常见陷阱？

在追求高[test coverage](../T/test-coverage.md)时要避免常见的陷阱，需要注意以下几点：

- **错误的安全感**：高测试覆盖率并不能保证不存在错误。关注测试的质量和意义，而不仅仅是数量。
  - **忽视维护**：随着代码的发展，测试必须更新。过时的测试可能会导致误报或误报。
  - **过度模拟**：过度使用模拟可能会导致测试通过，尽管实际集成点存在问题。确保测试验证真实场景。
  - **测试实现细节**：测试应该关注行为而不是实现的细节，这可能导致脆弱的测试，任何代码更改都会中断。
  - **忽略[flaky tests](../F/flaky-test.md)** ：不稳定的测试破坏了对测试套件的信心。及时解决不稳定的根本原因。
  - **注重数量而非质量**：编写大量低价值测试可能不如一组较小的高价值、有针对性的测试有益。
  - **省略负面测试**：确保测试不仅涵盖预期用例，还涵盖错误条件和边缘情况。
  - **缺乏优先级**：优先测试对用户体验具有较高风险或影响的关键路径和功能。
  - **重构不足**：定期重构测试以提高清晰度并减少冗余，这有助于保持高测试覆盖率。
  - **忽略[non-functional testing](../N/non-functional-testing.md)** ：性能、安全性和可用性测试也至关重要，在追求高测试覆盖率时不应忽视。
  请记住，我们的目标是创建一个强大且可靠的 [test suite](../T/test-suite.md) 来有效支持开发过程，而不是实现任意的覆盖率指标。

- **错误的安全感**：高测试覆盖率并不能保证不存在错误。关注测试的质量和意义，而不仅仅是数量。
  - **忽视维护**：随着代码的发展，测试必须更新。过时的测试可能会导致误报或误报。
  - **过度模拟**：过度使用模拟可能会导致测试通过，尽管实际集成点存在问题。确保测试验证真实场景。
  - **测试实现细节**：测试应该关注行为而不是实现的细节，这可能导致脆弱的测试，任何代码更改都会中断。
  - **忽略[flaky tests](../F/flaky-test.md)** ：不稳定的测试破坏了对测试套件的信心。及时解决不稳定的根本原因。
  - **注重数量而非质量**：编写大量低价值测试可能不如一组较小的高价值、有针对性的测试有益。
  - **省略负面测试**：确保测试不仅涵盖预期用例，还涵盖错误条件和边缘情况。
  - **缺乏优先级**：优先测试对用户体验具有较高风险或影响的关键路径和功能。
  - **重构不足**：定期重构测试以提高清晰度并减少冗余，这有助于保持高测试覆盖率。
  - **忽略[non-functional testing](../N/non-functional-testing.md)** ：性能、安全性和可用性测试也至关重要，在追求高测试覆盖率时不应忽视。

#### 如何平衡高测试覆盖率的需求和快速交付软件的需求？

在高[test coverage](../T/test-coverage.md)与快速软件交付之间取得平衡需要采取战略方法：

- **优先考虑[test cases](../T/test-case.md)**
    基于风险和影响。重点关注最有可能发生故障或发生重大问题的关键路径和功能。

- 实施
    **[test automation](../T/test-automation.md)**
    用于重复且耗时的测试以加快该过程。使用 Selenium、Jest 或 Cypress 等工具实现高效自动化。

- 采用
    **持续集成（CI）**
    和
    **持续部署 (CD)**
    频繁集成和部署代码，确保在开发周期的早期经常运行测试。

- 利用
    **[test-driven development](../T/test-driven-development.md) (TDD)**
    或
    **行为驱动开发 ([BDD](../B/bdd.md))**
    确保测试是在代码之前编写的，这可以导致更彻底的覆盖范围和更快的开发周期。

- 杠杆
    **[risk-based testing](../R/risk-based-testing.md)**
    以确定需要更彻底测试的区域和可以接受较低覆盖范围的区域。

- 使用
    **代码分析工具**
    识别未经测试或无效的代码。 Istanbul 或 JaCoCo 等工具可以帮助突出覆盖范围差距。

- **审查和重构测试**
    定期消除冗余并确保测试套件保持高效和相关。

- 鼓励
    **开发人员和测试人员之间的协作**
    分担质量责任并确保测试与代码更改保持一致。

- **监控和分析测试结果**
    确定趋势和需要改进的领域，从而有针对性地增加覆盖范围。
  通过关注这些策略，您可以在实现高[test coverage](../T/test-coverage.md) 和快速交付软件之间保持平衡。

- **优先考虑[test cases](../T/test-case.md)**
    基于风险和影响。重点关注最有可能发生故障或发生重大问题的关键路径和功能。

- 实施
    **[test automation](../T/test-automation.md)**
    用于重复且耗时的测试以加快该过程。使用 Selenium、Jest 或 Cypress 等工具实现高效自动化。

- 采用
    **持续集成（CI）**
    和
    **持续部署 (CD)**
    频繁集成和部署代码，确保在开发周期的早期经常运行测试。

- 利用
    **[test-driven development](../T/test-driven-development.md) (TDD)**
    或
    **行为驱动开发 ([BDD](../B/bdd.md))**
    确保测试是在代码之前编写的，这可以导致更彻底的覆盖范围和更快的开发周期。

- 杠杆
    **[risk-based testing](../R/risk-based-testing.md)**
    以确定需要更彻底测试的区域和可以接受较低覆盖范围的区域。

- 使用
    **代码分析工具**
    识别未经测试或无效的代码。 Istanbul 或 JaCoCo 等工具可以帮助突出覆盖范围差距。

- **审查和重构测试**
    定期消除冗余并确保测试套件保持高效和相关。

- 鼓励
    **开发人员和测试人员之间的协作**
    分担质量责任并确保测试与代码更改保持一致。

- **监控和分析测试结果**
    确定趋势和需要改进的领域，从而有针对性地增加覆盖范围。

#### 随着时间的推移保持高测试覆盖率有哪些最佳实践？

要长期保持高[test coverage](../T/test-coverage.md)，请遵循以下最佳实践：

- **定期审查和更新测试**
    以适应新功能和代码更改。过时的测试可能会导致误报并降低承保范围的有效性。

- **重构测试**
    更新代码以保持其干净、可读和可维护。这使得随着应用程序的增长更容易扩展覆盖范围。

- **优先测试**
    基于关键路径和风险领域。重点关注对应用程序性能和用户体验影响最大的功能。

- **尽可能自动化**
    ，但要有选择性。自动执行重复且耗时的测试，但避免对需要人工判断的复杂场景进行自动化。

- **将测试集成到 CI/CD 管道中**
    确保每次构建时自动运行测试。这有助于及早发现问题并保持一致的覆盖范围。

- **监控[flaky tests](../F/flaky-test.md)**
    并解决根本原因，以防止它们破坏测试覆盖率的可靠性。

- **使用覆盖工具**
    找出覆盖范围的差距并针对这些领域进行改进。工具可以深入了解代码库的哪些部分未经过测试。

- **鼓励测试文化**
    开发人员为他们的代码编写单元测试，有助于整体覆盖。

- **执行定期代码审查**
    重点关注测试覆盖率，以确保新代码附带相应的测试。

- **设定覆盖目标**
    并跟踪进度，但避免以 100% 覆盖为目标，因为这可能不具有成本效益。相反，目标是提供有意义的覆盖范围，以提供对应用程序稳定性的信心。
  通过实施这些实践，您可以维持高[test coverage](../T/test-coverage.md)，以适应软件的发展并保持其可靠性。

- **定期审查和更新测试**
    以适应新功能和代码更改。过时的测试可能会导致误报并降低承保范围的有效性。

- **重构测试**
    更新代码以保持其干净、可读和可维护。这使得随着应用程序的增长更容易扩展覆盖范围。

- **优先测试**
    基于关键路径和风险领域。重点关注对应用程序性能和用户体验影响最大的功能。

- **尽可能自动化**
    ，但要有选择性。自动执行重复且耗时的测试，但避免对需要人工判断的复杂场景进行自动化。

- **将测试集成到 CI/CD 管道中**
    确保每次构建时自动运行测试。这有助于及早发现问题并保持一致的覆盖范围。

- **监控[flaky tests](../F/flaky-test.md)**
    并解决根本原因，以防止它们破坏测试覆盖率的可靠性。

- **使用覆盖工具**
    找出覆盖范围的差距并针对这些领域进行改进。工具可以深入了解代码库的哪些部分未经过测试。

- **鼓励测试文化**
    开发人员为他们的代码编写单元测试，有助于整体覆盖。

- **执行定期代码审查**
    重点关注测试覆盖率，以确保新代码附带相应的测试。

- **设定覆盖目标**
    并跟踪进度，但避免以 100% 覆盖为目标，因为这可能不具有成本效益。相反，目标是提供有意义的覆盖范围，以提供对应用程序稳定性的信心。

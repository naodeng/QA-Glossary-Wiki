# 再次测试 (Retesting)
[再次测试](#retesting) [再次测试 (Retesting)](/wiki/retesting)

## 关于再次测试的常见问题？

#### 再次测试基础
- **什么是软件测试中的再次测试？**
  再次测试是验证早期测试中发现的缺陷是否已成功修复的过程。它涉及在开发团队解决缺陷后，重新运行最初因缺陷而失败的相同**测试用例 (Test Cases)**。再次测试的首要重点是确保特定问题已解决，且更正后的功能现在表现符合预期。
  与检查应用程序其他地方是否存在意外副作用的**回归测试 (Regression Testing)** 不同，再次测试是有针对性的，且仅限于已知的问题区域。它是一种验证活动，确认原始缺陷已修复，且不再存在于软件中。
  再次测试通常根据缺陷的**严重程度 (Severity)** 和影响进行优先级排序。在测试自动化框架中加入再次测试可以显著提高效率，特别是在处理频繁的代码更改和**迭代 (Iterations)** 时。自动化再次测试可以作为持续集成 (CI) 流水线的一部分。
  如果不进行再次测试，可能会导致发布带有未解决缺陷的软件，从而损害用户信任。

- **再次测试与回归测试有何不同？**
  再次测试和回归测试是软件[测试自动化](/wiki/test-automation)中不同的过程。
  **再次测试**涉及在初次发现缺陷后验证特定缺陷是否已修复。它是一种有针对性的测试，侧重于之前导致失败的确切条件。
  相比之下，**回归测试**的范围更广。它旨在确认最近的更改（如错误修复或功能添加）没有对现有功能产生不利影响。
  在测试周期中，再次测试通常在回归测试之前进行。一旦失败的测试用例重新执行并通过，就可以进行回归测试以确保没有引入新问题。
  简而言之，**再次测试是修复验证，而回归测试是变更影响评估**。

- **再次测试的主要目的是什么？**
  主要目的是验证在早期测试周期中发现的缺陷或 **Bug** 已成功修复，且特定问题不再存在。再次测试通过确认 Bug 已修复，直接影响软件的**可靠性**和**功能性**，确保最终产品符合质量标准。

- **再次测试应在软件测试生命周期的什么时候进行？**
  应在缺陷修复后进行。当开发人员解决了问题且新代码已集成时，必须进行再次测试。
  再次测试也适用于以下情况：
  - **代码更改**：响应其他缺陷或功能增强。
  - **环境更改**：可能影响软件行为。
  - **配置更改**：可能影响功能或性能。
  - **新版本**：包含 Bug 修复，需要确认问题已解决。
  在 **CI/CD** 流水线中，再次测试可以在代码提交并合并到主分支后自动触发。

- **再次测试过程涉及哪些步骤？**
  1. **识别缺陷**：从初始测试报告的缺陷列表开始。
  2. **优先级排序**：基于严重性、频率和影响。
  3. **与开发沟通**：确保他们理解缺陷。
  4. **验证修复**：确认修复已部署到测试环境。
  5. **准备测试用例**：选择与缺陷相关的相同用例。
  6. **执行测试用例**：在相同条件下验证。
  7. **记录结果**：记录缺陷是否已修复。
  8. **更新测试状态**：在跟踪系统中更新。
  9. **回归测试**：进行快速回归测试以防引入新 Bug。
  10. **沟通结果**：分享给团队和利益相关者。
  11. **关闭或重新打开缺陷**。
  12. **按需再次测试**：如果缺陷被重新打开，循环继续。

#### 再次测试的重要性
- **为什么在软件开发过程中再次测试很重要？**
  它确保早期识别的**特定缺陷**已**成功解决**。这种有针对性的方法有助于确认代码更改未在更正区域引入新问题。再次测试专注于应用程序中**已更改或受影响的部分**，是受控且预设有测试用例的验证过程，其结果能提供关于近期更改**稳定性的反馈**。

- **再次测试如何提高软件的整体质量？**
  - **确认修复有效性**。
  - **防止故障掩盖**（修复一个 Bug 可能会掩盖另一个）。
  - **维持软件可靠性**。
  - **提升用户满意度**。

- **不进行再次测试的潜在后果：**
  - **未检测到的 Bug**。
  - **质量差**。
  - **用户不满意**。
  - **增加成本**（后期修复成本更高）。
  - **名誉受损**。
  - **合规性问题**。
  - **发布延迟**。

#### 再次测试策略与技术
- **常见的再次测试策略与技术：**
  - **测试用例优先级排序**。
  - **测试环境隔离**。
  - **数据管理**：使用能复现缺陷的特定数据。
  - **版本控制**。
  - **冒烟测试 (Smoke Testing)**。
  - **测试用例变体**：覆盖相关的边界情况。
  - **文档更新**。
  - **明确缺陷定义**。
  - **自动化再次测试脚本**。
  - **持续监控**。
  - **反馈循环**。

- **如何确定哪些测试用例需要再次测试？**
  分析软件的**特定更改**。侧重于：
  - **缺陷修复**：之前失败的用例。
  - **代码更改**：检查源码提交影响的路径。
  - **需求更新**。
  - **影响分析**：理解依赖关系。
  - **风险评估**。
  - **测试用例历史**。
  使用自动化工具或**测试用例管理系统**可以简化选择过程。

- **规划再次测试时应考虑哪些因素？**
  缺陷修复情况、测试用例优先级、环境、数据准备、资源可用性、测试覆盖率、依赖关系、文档、时间限制和反馈循环。

#### 再次测试工具与自动化
- **常用的再次测试工具有哪些？**
  [Selenium](/wiki/selenium)、TestComplete、QTP/UFT、Ranorex、Appium、JUnit/TestNG、[Cypress](/wiki/cypress)、Robot Framework。
  自动化工程师根据被测应用、语言框架和再次测试的具体需求来选择。

- **如何应用自动化进行再次测试？**
  通过识别需要重跑的特定用例，并将其自动化以确保问题已解决。
  步骤：**选择用例**、**更新脚本**、**利用框架**、**与构建工具集成**（如 Jenkins）、**利用版本控制系统**。
  ```typescript
  // 使用 TypeScript 编写的简单自动化再次测试脚本示例
  import { expect } from 'chai';
  import { browser } from 'protractor';

  describe('再次测试示例', () => {
    it('应该验证 Bug 修复', async () => {
      await browser.get('http://example.com/bug-fix-page');
      const result = await browser.findElement(...).getText();
      expect(result).to.equal('Bug 修复后的预期结果');
    });
  });
  ```
  自动化能确保**一致性**、**效率**和**快速反馈**。

- **自动化再次测试的优缺点：**
  - **优点**：效率高、一致性好、可重用、扩大覆盖范围、资源优化。
  - **挑战**：初始投资大、维护成本高、学习曲线、测试不稳定性 (Flakiness)、复杂性。

#### Agile 和 DevOps 中的再次测试
- **Agile 方法中如何处理再次测试？**
  再次测试被视为迭代开发过程的一部分，通常在识别缺陷的同一 Sprint 内完成。Agile 团队注重快速修复反馈，常通过**用户故事**、**完成定义 (DoD)**、**持续集成 (CI)** 和**测试用例管理工具**来促进再次测试，以维持**零 Bug 政策 (Zero Bug Policy)**。

- **再次测试在 DevOps 中扮演什么角色？**
  在 DevOps 中，再次测试对于维持**持续反馈循环**至关重要。通过提示再次测试已修复的问题，团队可以快速验证并将修复合并到主分支，支持 **CI/CD**。它还有助于**风险管理**、维护**代码质量**和**稳定性**，防止技术债的积累。

- **如何将再次测试集成到 CI/CD 流水线中？**
  1. 自动化再次测试用例。
  2. 与版本控制集成。
  3. 配置 CI 服务器。
  4. 使用容器化。
  5. 并行执行。
  6. **测试数据管理**。
  7. 结果报告。
  8. 反馈循环。
  9. 分支策略。
  10. 质量门禁 (Gatekeeping)。
  11. 持续监控。

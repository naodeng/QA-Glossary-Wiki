# 回归测试 (Regression Testing)
[回归测试](#regression-testing) [回归测试 (Regression Testing)](/wiki/regression-testing)

### 相关术语：
- [发布测试 (Release Testing)](/glossary/release-testing)
- [再测试 (Retesting)](/glossary/retesting)

### 参见：
- [维基百科 (Wikipedia)](https://en.wikipedia.org/wiki/Regression_testing)

## 关于回归测试的常见问题？

#### 基础与重要性
- **什么是回归测试？**
  回归测试是一种[质量保证](/wiki/quality-assurance)实践，涉及重新运行功能和非功能测试，以确保先前开发和测试过的软件在更改后仍能正常运行。当添加新功能或修复 [Bug](/wiki/bug) 时，回归测试确认这些更新没有对现有功能产生不利影响。
  测试用例的选择基于代码更改的性质和产生副作用的可能性。[测试套件](/wiki/test-suite)通常会根据优先级排序，首先运行最关键的测试。自动化在该过程中起着关键作用，允许频繁且全面的回归测试，而不会显著增加时间和资源。
  自动化回归测试通常使用能够对应用程序执行预编写[测试用例](/wiki/test-case)的框架或工具。这些工具范围广泛，从 [Selenium](/wiki/selenium) 和 JUnit 等开源解决方案到 QTP/UFT 和 TestComplete 等商业产品。选择工具取决于各种因素，包括技术栈、测试用例的复杂性以及与开发流水线中其他工具的集成能力。
  为了确保效率，回归测试可以通过**测试套件最小化**、**优先级排序**和**选择性执行**等技术进行优化。这些策略有助于在缩短执行时间的同时运行最具影响力的测试。
  有效的回归测试需要对[测试用例](/wiki/test-case)进行持续维护，以适应应用程序的变化。定期审查和更新测试对于避免[误报 (False Positives)](/wiki/false-positive) 和漏报至关重要，从而确保回归套件始终可靠且相关。

- **为什么回归测试在软件开发中很重要？**
  回归测试在软件开发中至关重要，它确保最近的代码更改没有对现有功能产生负面影响。它充当了一个“安全网”，可以捕获在新功能开发、[Bug](/wiki/bug) 修复或任何代码改动期间可能引入的问题。通过定期进行回归测试，团队可以维护软件的完整性，防止潜在缺陷流向生产环境。
  在持续集成和持续部署 (CI/CD) 的背景下，回归测试变得更加重要。它通过提供关于更改影响的快速反馈，支持快速**迭代**和频繁发布。这种实践有助于在整个开发过程中保持高标准的[软件质量](/wiki/software-quality)。
  此外，回归测试有助于验证增强或优化没有破坏应用程序的任何部分，这对于用户满意度和信任至 meters 关重要。它通过确保对代码库的改进不会引入新问题来支持重构工作。
  鉴于其重复性的性质，回归测试是自动化的首选候选。自动化回归测试可以快速且频繁地运行，为开发人员提供即时反馈，并显著缩短发布时间。这种自动化是实现现代敏捷和 DevOps 实践所需的速度和效率的关键。

- **回归测试的关键益处：**
  - **维持软件质量**：确保代码更改不影响现有功能。
  - **早期 Bug 探测**：在缺陷引入后立即识别，降低修复成本。
  - **风险缓解**：通过捕获可能破坏关键功能的变更，降低生产环境风险。
  - **对变更的信心**：让开发人员和利益相关者确信代码修改不会降低应用质量。
  - **支持重构**：允许开发人员优化性能而不必担心引入错误。
  - **改进文档**：作为功能预期运作方式的一种文档形式，帮助新成员。
  - **持续改进**：促进软件的持续优化。
  - **发布就绪性**：根据现有功能的稳定性确定软件是否准备好发布。

- **回归测试如何融入软件开发生命周期 (SDLC)？**
  回归测试主要在 **[软件开发生命周期 (SDLC)](/wiki/software-development-life-cycle) 的维护阶段** 整合，但在任何代码变更或添加后也同样适用。
  - **传统瀑布模型**：回归测试在开发阶段之后、部署阶段之前进行。它是 Bug 修复、增强或修改后验证软件按预期运行的关键步骤。
  - **敏捷与 CI/CD 环境**：回归测试更加动态。它频繁执行（通常在每次重大提交甚至特定提交集之后），以确保迭代变更不会破坏软件。这符合敏捷的**持续反馈**和**快速迭代**原则。
  - **DevOps 实践**：回归测试是自动化流水线的一部分。自动化回归测试作为构建过程的一部分运行，提供即时反馈。
  总之，回归测试不仅是一次性活动，而是一个随软件发展的持续过程。它是软件开发中**风险管理**和**质量保证**策略的重要组成部分。

- **再测试 (Retesting) 与回归测试的区别？**
  **再测试**是验证在测试期间发现的**特定**缺陷已被修复的过程。它涉及重新运行由于这些缺陷而失败的相同[测试用例](/wiki/test-case)，以确保问题已解决。
  另一方面，**回归测试**是一项更广泛的活动，旨在确认最近的更改（如 Bug 修复或新功能）没有对现有功能产生负面影响。它涉及重新执行所有测试用例的子集，或在某些情况下重新执行整个测试套件。
  核心区别在于**范围**和**目的**：
  - **再测试**：高度集中且仅限于特定缺陷的修复。
  - **回归测试**：全面的，关注变动后的整体软件稳定性。
  实践中，通常先进行再测试以确认已知问题的解决，待修复验证通过后，再进行回归测试以确保这些修复没有在应用程序的其他地方引入新问题。

#### 技术与类型
- **回归测试有哪些不同类型？**
  - **纠正性回归测试 (Corrective Regression Testing)**：专注于软件未更改的区域，确保新变动不影响它们。
  - **渐进性回归测试 (Progressive Regression Testing)**：测试新功能和变更，确保它们不破坏现有功能。
  - **全量回归测试 (Retest-All Regression Testing)**：对修改后的应用重新执行所有测试用例，属于资源密集型。
  - **部分回归测试 (Partial Regression Testing)**：仅重新执行与更改相关的测试用例子集。
  - **单元回归测试 (Unit Regression Testing)**：更改后测试单个单元或组件。
  - **集成回归测试 (Integration Regression Testing)**：确保更改没有破坏集成组件间的交互。
  - **系统回归测试 (System Regression Testing)**：修改后验证整个系统。
  - **负载回归测试 (Load Regression Testing)**：检查更改后系统在负载下的性能是否维持。
  - **冒烟回归测试 (Smoke Regression Testing)**：更改后运行的一组快速测试，以确认基本功能正常。

- **回归测试中使用的技术：**
  - **测试用例优先级排序**：根据重要性、探测 Bug 的可能性或更改影响对[测试用例](/wiki/test-case)排序。
  - **测试套件最小化**：通过消除冗余或过时测试来减少测试数量，同时维持[测试覆盖率](/wiki/test-coverage)。
  - **影响分析 (Impact Analysis)**：识别受更改影响的软件部分并选择相关测试。
  - **等价类划分 (Equivalence Partitioning)**：将输入数据划分为等价组。
  - **边界值分析 (Boundary Value Analysis)**：关注输入域边界上的值。
  - **判定表测试 (Decision Table Testing)**：涵盖所有可能的业务逻辑场景。
  - **状态转换测试 (State Transition Testing)**：验证触发状态更改后的行为。
  - **组合测试 (Combinatorial Testing)**：涵盖不同输入参数之间的交互。

- **什么是选择性回归测试 (Selective Regression Testing)？**
  这是一种策略，即仅执行回归测试的一个子集用于验证变更。其目的是通过关注最相关或最高风险的区域来节省时间和资源。选择标准通常包括：代码更改、风险评估、测试覆盖率、历史缺陷和依赖关系。

- **单元回归测试与全量回归测试的区别？**
  单元回归测试是狭窄且集中的，由开发人员在单元级别执行；全量回归测试是全面的，涉及测试套件中的所有用例（包括集成、系统和验收级别），通常在重大发布前执行。

- **回归测试在敏捷环境中如何执行？**
  在敏捷环境中，它被整合到 CI/CD 流水线中。新代码提交后会自动触发回归测试套件。敏捷团队通常采用**基于风险的测试**进行优先级排序，并使用 **TDD** 或 **BDD** 确保测试与功能开发同步。

#### 工具与自动化
- **常用的回归测试工具有哪些？**
  - **Selenium**：Web 浏览器自动化的行业标准。
  - **QTP/UFT**：成熟的商业功能和回归测试工具。
  - **TestComplete**：支持多种脚本语言的功能测试工具。
  - **Ranorex**：适用于桌面、Web 和移动端的易用工具。
  - **Katalon Studio**：集成 Selenium 和 Appium 的一站式自动化方案。
  - **Appium**：移动应用自动化。
  - **Cypress**：现代、基于 JS 的端到端测试框架。
  - **Postman**：用于服务层面的回归测试。

- **如何实现回归测试自动化？**
  1. **识别测试用例**：专注于受更改影响可能性最大的用例。
  2. **编写测试脚本**：脚本应模块化、可重用且易于维护。
  3. **搭建测试环境**：镜像生产环境。
  4. **集成 CI 系统**：代码提交后自动触发或定时运行。
  5. **数据驱动技术**：使用不同数据集增强覆盖率。
  6. **并行执行**：跨环境同步运行以缩短时间。

- **自动化回归测试的益处：**
  一致性与准确性（减少人为错误）、速度、长期成本效益、支持频繁执行、即时反馈、更广的覆盖率、脚本可重用性。

#### 挑战与最佳实践
- **回归测试中的挑战：**
  - **测试套件维护**：随着应用演进而不断过时。
  - **测试覆盖率**：难以识别所有受影响区域。
  - **资源分配**：可能是资源密集型的。
  - **不稳定性 (Flakiness)**：间歇性成功或失败。
  - **测试数据管理**：复杂且需反映多态。
  - **环境一致性**：镜像生产环境的难度。

- **最佳实践：**
  - 基于影响和历史缺陷对用例排序。
  - 维持结构良好、独立的测试用例。
  - 使用版本控制管理测试脚本。
  - 实施 CI 自动运行。
  - 采用基于风险的方法。
  - 定期评审和重构测试套件，移除过时用例。
  - 平衡手工与自动化测试，保留人类洞察力。

- **如何衡量回归测试的有效性？**
  使用**关键绩效指标 (KPIs)**：测试覆盖率、捕获的缺陷数、测试通过率、执行时间、平均探测时间 (MTTD)、平均修复时间 (MTTR) 和投资回报率 (ROI)。

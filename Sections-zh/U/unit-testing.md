# 单元测试 (Unit Testing)
[单元测试 (Unit Testing)](#unit-testing)

### 相关术语：
- [集成测试 (Integration Testing)](/glossary/integration-testing)
- [测试驱动开发 (Test-Driven Development)](/glossary/test-driven-development)
- [NUnit](/glossary/nunit)
- [JUnit 测试 (JUnit Testing)](/glossary/junit-testing)

## 关于单元测试 (Unit Testing) 的常见问题？

#### 基础与重要性
- **什么是单元测试？**
  **单元测试** 是指对应用程序中最小的可测试部分（通常是函数或方法）进行隔离测试的实践。这些测试由开发人员编写和执行，以确保代码库的特定部分按预期运行。
  在 **单元测试** 中，每个单元都使用 **存根 (Stubs)** 和 **模拟 (Mocks)** 进行隔离测试，以模拟不属于测试一部分的依赖模块的行为。这允许在早期阶段检测问题，使其更容易解决。
  一个好的单元测试应该是：
  - **聚焦的 (Focused)**：它应该只测试一个函数或方法，并测试好。
  - **快速的 (Fast)**：它应该运行得很快，以免拖慢开发或 CI/CD 管道。
  - **独立的 (Independent)**：它不应依赖于外部系统或其他测试的状态。
  - **可重复的 (Repeatable)**：在给定相同输入的情况下，每次运行都应产生相同的结果。
  - **自我验证的 (Self-validating)**：它应该清楚地显示测试是通过还是失败，而无需人工分析。
  单元测试通常使用与被测代码相同的编程语言编写，并在开发过程中频繁运行。当单元测试失败时，表明存在需要解决的问题，然后才能继续。
  流行的 **单元测试框架** 包括 Java 的 **JUnit**、.NET 的 **NUnit**、Python 的 **unittest** 和 JavaScript 的 **Jest**。这些工具提供了一种结构化的方式来编写和运行单元测试，通常具有模拟和断言功能。

  ```typescript
  // TypeScript 中的简单单元测试示例
  import { add } from './math';

  test('adds 1 + 2 to equal 3', () => {
    expect(add(1, 2)).toBe(3);
  });
  ```

- **为什么单元测试很重要？**
  **单元测试** 至关重要，因为它确保软件的各个组件在隔离状态下按预期工作。通过单独测试这些组件，开发人员可以：
  - **早期检测和修复 Bug**：在开发过程中发现问题比在更高级别的测试或部署后发现问题更具成本效益。
  - **自信地重构代码**：知道测试会通过，如果更改破坏了现有功能，测试会揭示出来，从而可以放心地重构。
  - **文档化代码**：单元测试可以作为如何使用 API 的示例。
  - **设计更好的代码结构**：可测试的代码通常会导致更模块化和灵活的设计。
  - **促进集成**：经过独立测试的单元更有可能无缝集成。
  - **加快开发过程**：自动化测试可以快速且频繁地运行。
  - **提高代码覆盖率**：彻底的单元测试可以运行代码中的所有路径和条件。
  单元测试通常由开发人员编写和运行，经常使用持续集成系统来确保持续的代码健康状况。当单元测试失败时，表明代码库中发生了未预期或未考虑到的更改，提示立即进行调查和修复。这种即时反馈循环对于维护稳健的代码库（尤其是在敏捷和快节奏的开发环境中）至关重要。

- **单元测试有什么好处？**
  **单元测试** 提供了多种好处，可提高软件的质量和 **可维护性**：
  - **隔离 (Isolation)**：隔离测试各个组件，确保每个部分都能独立正常运行。
  - **回归检测 (Regression Detection)**：当更改破坏现有功能时快速识别回归，允许立即修复。
  - **设计改进 (Design Improvement)**：鼓励更好的设计和架构，因为组件必须是可隔离测试的，通常会导致更模块化的代码。
  - **重构信心 (Refactoring Confidence)**：提供安全网，促进自信的重构，因为知道测试会捕获任何引入的错误。
  - **文档 (Documentation)**：充当系统的活文档。开发人员可以查看测试以了解单元的预期行为。
  - **调试效率 (Debugging Efficiency)**：通过精确定位受测单元内的缺陷位置，简化调试。
  - **开发速度 (Development Speed)**：通过尽早捕获错误，减少调试和手动测试所花费的时间，从而加快开发过程。
  - **代码质量 (Code Quality)**：通常会导致更高的代码质量和更少的 Bug，因为开发人员在编写代码时会考虑可测试性和边缘情况。
  - **降低成本 (Cost Reduction)**：通过在开发周期的早期（修复成本通常较低）捕获 Bug 来降低修复 Bug 的成本。
  通过将 **单元测试** 集成到开发工作流程中，团队可以实现更可靠、可维护和稳健的代码库，最终带来更成功的软件项目。

- **单元测试与其他类型的测试有什么区别？**
  **单元测试** 是指对应用程序中最小的可测试部分（通常是函数或方法）进行隔离测试的实践。其他类型的测试（如 **集成测试**、**系统测试** 和 **验收测试**）在范围和重点上有所不同：
  - **集成测试 (Integration Testing)**：评估不同单元或组件之间的交互，以确保它们按预期协同工作。它比 **单元测试** 高一级，识别集成组件之间的接口和交互中的问题。
  - **系统测试 (System Testing)**：考虑整个系统的行为，旨在验证完整的、集成的软件产品是否符合规定的要求。这是一个更高级别的测试，包含完整的、集成的软件，以评估系统是否符合其规定的要求。
  - **验收测试 (Acceptance Testing)**：执行以确定系统是否准备好发布。它通常由最终用户或客户执行，以根据业务需求验证功能和性能。验收测试面向用户，重点关注系统是否满足用户的需求。
  **单元测试** 的独特之处在于它专注于软件的最小部分，而其他类型的测试则解决系统更全面的方面，从组件如何协同工作到系统在现实场景中的表现。了解这些差异有助于 **测试自动化** 工程师设计和执行适当级别的测试，以确保稳健可靠的软件产品。

- **单元测试如何融入软件开发生命周期？**
  **单元测试** 是软件开发生命周期 (SDLC) 的组成部分，通常嵌入在 **编码阶段**。随着开发人员编写代码，他们同时创建单元测试以验证每个函数或模块的正确性。这种做法确保新代码不会破坏现有功能，并从一开始就遵守规定的要求。
  在 **敏捷方法** 中，**单元测试** 更为关键，因为它支持 **持续集成 (CI)** 和 **持续交付 (CD)**。开发人员经常将他们的更改合并到共享存储库中，在该存储库中运行自动化构建和测试。单元测试作为第一道防线，在问题传播到后续阶段或生产环境之前及早捕获问题。
  **单元测试** 也在 **重构** 中发挥作用。在改进或优化代码时，单元测试提供了一个安全网，确认行为保持一致。这允许自信的代码更改，并鼓励更清洁、更易于维护的代码库。
  在 **维护** 期间，单元测试有助于识别更改的影响，确 **Bug** 修复或新功能添加不会引入新问题。它们充当代码预期行为的活文档。
  总之，**单元测试** 贯穿整个 SDLC，从最初的开发到维护，支持软件项目的质量、敏捷性和可靠性。它使开发人员能够更高效地工作，降低引入错误的风险，并有助于在软件的生命周期内保持高代码质量。

#### 单元测试技术
- **单元测试中使用了哪些不同的技术？**
  **单元测试** 中的不同技术包括：
  - **黑盒测试 (Black-box Testing)**：关注单元的功能，而不考虑其内部代码结构。测试基于规范和需求。
  - **白盒测试 (White-box Testing)**：涉及查看被测代码的结构。测试基于代码语句、分支、路径和条件的覆盖率。
  - **灰盒测试 (Gray-box Testing)**：黑盒测试和白盒测试的结合，测试人员对应用程序的内部工作原理有的了解。
  - **正向测试 (Positive Testing)**：确保单元在给定有效输入时按预期运行。
  - **负向测试 (Negative Testing)**：确保单元优雅地处理无效输入或条件。
  - **边界测试 (Boundary Testing)**：关注输入域的边缘条件，测试分区之间的边界。
  - **等价划分 (Equivalence Partitioning)**：将输入数据划分为可以以类似方式测试的等价分区，从而减少所需的测试总数。
  - **基于状态的测试 (State-based Testing)**：检查单元在经历一系列状态变化时的行为。
  - **变异测试 (Mutation Testing)**：修改代码的某些部分以检查现有单元测试是否可以检测到更改；它有助于评估测试的质量。
  - **基于属性的测试 (Property-based Testing)**：根据指定的属性生成随机输入数据，并检查单元在各种输入下是否行为正确。
  - **错误猜测 (Error Guessing)**：依靠测试人员的经验来猜测单元中最可能出现错误的区域，并专门为这些容易出错的区域编写测试。
  每种技术都可以独立使用或组合使用，以确保单元测试的全面覆盖率和稳健性。

- **什么是测试驱动开发？**
  **测试驱动开发 (TDD)** 是一种软件开发过程，依赖于非常短的开发周期的重复。开发人员首先编写一个定义所需改进或新功能的 **自动化测试用例**，然后生成通过该测试的 **最少量的代码**，最后将新代码 **重构** 为可接受的标准。
  TDD 主要是一种 **设计哲学**，强调用在代码库中编写相应功能之前编写测试。该过程从为最小的功能单元（通常在函数或方法级别）开发 **测试用例** 开始。这些测试最初预计会失败，这是 TDD 的“红-绿-重构”周期的关键方面：
  1. **红 (Red)**：编写一个反映所需更改或新功能的失败测试。
  2. **绿 (Green)**：实现使测试通过的代码。
  3. **重构 (Refactor)**：清理代码，同时确所有测试仍然通过。
  TDD 鼓励简单的设计，并激发对软件功能的信心。它还确保从一开始就对代码进行了测试，因为测试是在需要通过测试的代码之前编写的。

  ```javascript
  function add(a, b) {
    return a + b;
  }

  // 'add' 函数的测试用例
  test('adds 1 + 2 to equal 3', () => {
    expect(add(1, 2)).toBe(3);
  });
  ```
  在上面的示例中，`add` 函数的测试是在函数本身实现之前编写的。在创建函数并通过测试后，可以重构代码以改进其结构或效率，并通过测试确保函数的行为保持正确。

- **什么是行为驱动开发？**
  **行为驱动开发 (BDD)** 是一种敏捷软件开发过程，鼓励软件项目中的开发人员、QA 以及非技术或业务参与者之间的协作。它专注于通过与利益相关者的讨论来清楚地了解所需的软件行为。BDD 扩展了 **测试驱动开发 (TDD)**，它是用非程序员可以阅读的自然语言编写 **测试用例**。
  BDD 中的测试基于用户故事，并使用一种称为 **Gherkin** 的语言进行描述。Gherkin 使用一组特殊关键字为可执行规范赋予结构和意义。最重要的关键字是：
  - **Feature (功能)**：系统的一个显著方面。
  - **Scenario (场景)**：特定的行为或用例。
  - **Given (给定)**：场景开始时的初始上下文。
  - **When (当)**：触发场景的事件。
  - **Then (那么)**：给定上下文和事件后的预期结果。

  以下是 BDD **测试用例** 的示例：
  ```gherkin
  Feature: User login

  Scenario: Existing user successfully logs in
    Given the user has navigated to the login page
    When they enter their correct username and password
    Then they should be granted access to their dashboard
  ```
  Cucumber、SpecFlow 或 Behat 等 BDD 工具会解析这些规范并将其作为测试执行。结果告知软件是否按预期运行。BDD 有助于确保所有利益相关者对需求有共同的理解，并且软件满足这些需求。它弥合了技术团队成员和非技术团队成员之间的差距，促进了更好的沟通和协作。

- **如何编写好的单元测试？**
  编写好的单元测试涉及遵守几个关键原则：
  - **隔离 (Isolation)**：确保测试仅覆盖一个工作单元，避免依赖其他单元。使用模拟或存根来模拟外部依赖项。
  - **可读性 (Readability)**：编写易于理解的测试。为测试函数使用清晰的命名约定，描述预期结果和被测条件。
  - **断言性 (Assertiveness)**：每个测试关注单元的一个行为或方面。应避免针对不同行为的多个断言。
  - **可重复性 (Repeatability)**：无论在何种环境中运行，测试都应产生相同的结果。避免依赖外部状态或数据。
  - **可自动化 (Automatability)**：确保测试可以自动运行，无需手动步骤。
  - **速度 (Speed)**：保持测试快速，以维持快速的反馈循环。
  - **稳健性 (Robustness)**：测试不应因单元实现的微小更改而中断。针对单元的公共 **API** 进行测试，避免测试内部结构。
  - **维护 (Maintenance)**：编写易于维护的测试。必要时重构测试，使其与代码库保持同步。

  ```typescript
  // 使用 Jest 的 TypeScript 简单单元测试示例
  import { add } from './math';

  test('adds 1 + 2 to equal 3', () => {
    expect(add(1, 2)).toBe(3);
  });
  ```
  记住定期 **重构** 测试并使它们与代码更改保持 **最新**。当测试失败时，在更正代码或测试之前 **分析** 失败原因，确保测试继续发挥其验证正确性的作用。

- **模拟对象在单元测试中的作用是什么？**
  模拟对象在 **单元测试** 中通过模拟真实对象的行为发挥着至关重要的作用。它们用于创建一个受控环境，在此环境中，测试仅关注工作单元，而无需外部依赖项（如 **数据库**、网络调用或其他服务）。
  通过使用模拟对象，您可以：
  - **隔离 (Isolate)** 被测代码单元，确保失败是由于单元本身的问题，而不是由于与外部系统或依赖项的交互。
  - **指定 (Specify)** 与模拟对象的预期交互，允许您验证代码单元是否与其依赖项正确交互。
  - **控制 (Control)** 测试环境，通过模拟各种场景（包括错误条件、边缘情况或难以用实际依赖项重现的罕见情况）。
  - **提高测试性能**，因为与模拟对象的交互通常比与实际依赖项的交互快，从而缩短测试执行时间。

  模拟对象通常使用模拟框架创建，这些框架允许您轻松设置预期行为和断言。以下是使用 TypeScript 模拟框架的示例：
  ```typescript
  import { it, describe } from 'mocha';
  import { expect } from 'chai';
  import { mock, instance, when, verify } from 'ts-mockito';

  describe('UserService', () => {
    it('should create a new user', () => {
      const mockRepository = mock(UserRepository);
      const userService = new UserService(instance(mockRepository));
      const user = new User('test@example.com', 'password123');

      when(mockRepository.save(user)).thenReturn(Promise.resolve(user));

      await userService.create(user);

      verify(mockRepository.save(user)).once();
      expect(await mockRepository.save(user)).to.equal(user);
    });
  });
  ```
  在这个例子中，`UserRepository` 被模拟以专注于测试 `UserService.create` 方法，而无需实际访问 **数据库**。模拟确保测试保持快速、可靠，并具有可预测的结果。

#### 单元测试工具
- **有哪些流行的单元测试工具？**
  流行的 **单元测试** 工具因编程语言和开发环境而异。以下是一些广泛使用的选项：
  - **JUnit**：Java 开发人员的主要工具，提供注解和断言以简化测试。
  - **NUnit**：类似于 JUnit，但针对 .NET 框架，支持并行测试并拥有强大的社区。
  - **TestNG**：另一个基于 Java 的工具，它提供更灵活的测试配置并支持数据驱动测试。
  - **PHPUnit**：PHP 的首选工具，易于与 CI 工具集成并支持数据库测试。
  - **RSpec**：Ruby 的行为驱动开发 (BDD) 框架，以其可读的语法而闻名。
  - **MSTest**：Microsoft 的测试框架，与 Visual Studio 集成，方便 .NET 开发人员使用。
  - **xUnit.net**：用于 .NET 的开源工具，支持理论测试和简洁的执行模型。
  - **pytest**：功能强大的 Python 工具，语法简单，可通过插件扩展。
  - **Jest**：在 JavaScript 世界中很流行，尤其对于 React 应用程序，它提供快照测试。
  - **Mocha**：另一个 JavaScript 框架，灵活且支持异步测试。
  - **QUnit**：专为 jQuery 设计，可用于在任何环境中测试 JavaScript。
  - **Google Test**：针对 C++ 开发人员，跨平台并支持模拟对象等高级功能。
  每种工具都提供独特的功能，例如 **代码覆盖率** 分析、**测试发现** 和 **与开发环境的集成**。选择正确的工具通常取决于项目的具体需求和开发团队的偏好。

- **如何选择合适的单元测试工具？**
  选择合适的 **单元测试** 工具涉及评估几个因素，以确保其符合您的项目需求：
  - **语言支持 (Language Support)**：确保工具支持项目中使用的编程语言。
  - **集成 (Integration)**：寻找可以与您的开发环境和 CI/CD 管道无缝集成的工具。
  - **性能 (Performance)**：考虑测试的执行速度，因为它会影响开发人员的反馈循环。
  - **可用性 (Usability)**：拥有用户友好界面和清晰文档的工具可以减少学习曲线并提高采用率。
  - **功能 (Features)**：评估工具是否提供必要的功能，如测试覆盖率分析、测试用例分组和并行测试执行。
  - **社区和支持 (Community and Support)**：强大的社区和可用的支持对于故障排除和保持工具更新非常宝贵。
  - **成本 (Cost)**：评估工具的成本（包括许可证和潜在培训）与您的预算。
  - **可扩展性 (Extensibility)**：添加自定义功能或与其他工具集成的能力对于复杂项目可能至关重要。
  - **维护 (Maintenance)**：考虑工具的更新频率以及代码库更改时更新测试的难易程度。
  根据这些标准评估工具，并考虑在完全承诺之前进行小规模试用，以确保其满足您项目的特定要求。

- **好的单元测试工具有哪些特点？**
  好的 **单元测试** 工具应具有以下特点：
  - **易于集成**：它应该易于与开发环境和构建过程集成。
  - **支持多种语言和框架**：与使用的语言和框架兼容。
  - **测试用例隔离**：能够模拟或存根外部依赖项，以确保测试是隔离的。
  - **测试运行器**：内置或兼容的测试运行器，可以执行测试并报告结果。
  - **断言库**：一套全面的断言来验证测试结果。
  - **测试覆盖率分析**：用于测量和报告代码覆盖率的工具，以识别代码库中未测试的部分。
  - **性能和可扩展性**：即使测试数量增加，也能高效执行测试。
  - **并行测试执行**：支持并行运行测试以加快进程。
  - **自动化测试发现**：自动检测新测试和现有测试，以确保所有测试都得到执行。
  - **持续集成 (CI) 兼容性**：与 CI/CD 管道无缝集成以进行自动化测试。
  - **调试功能**：有助于诊断和修复失败测试的功能。
  - **重构支持**：如果行为保持不变，测试不应因重构代码而中断。
  - **文档和社区支持**：全面的文档和强大的社区以进行故障排除和支持。
  - **可扩展性**：能够根据需要使用插件或其他框架扩展工具。
  - **许可和成本**：考虑与工具相关的许可条款和成本。
  选择具有这些功能的 **单元测试** 工具将有助于制定稳健高效的 **测试自动化** 策略。

- **如何使用单元测试工具？**
  使用 **单元测试** 工具通常涉及以下步骤：
  1. **设置测试环境**：安装 **单元测试** 工具并配置它以与您的开发环境配合使用。
  2. **创建测试用例**：编写关注代码小单元的测试方法。使用断言定义预期结果。
     ```javascript
     function testAddition() {
       assertEquals(2 + 2, 4);
     }
     ```
  3. **安排、执行和断言 (AAA) 模式**：使用 **设置 (Arrange)**、调用 **(Act)** 和 **验证 (Assert)** 来构建您的测试。
     ```javascript
     // Arrange
     let calculator = new Calculator();
     // Act
     let result = calculator.add(2, 2);
     // Assert
     assertEquals(result, 4);
     ```
  4. **运行测试**：使用工具的 **测试运行器** 执行您的测试。这通常可以从命令行或在 IDE 中完成。
  5. **审查测试结果**：分析工具提供的输出，查看哪些测试通过或失败。
  6. **重构并重复**：如果测试失败，请重构您的代码并再次运行测试。继续此过程，直到所有测试通过。
  7. **与构建集成**：通过将单元测试集成到构建过程中来自动化您的单元测试，确保它们定期运行。
  8. **监控代码覆盖率**：使用工具的 **代码覆盖率** 功能确保您的测试覆盖了代码库的很大一部分。
  请记住隔离工作单元，使用模拟对象或框架模拟依赖项，并保持测试独立且可重复。定期审查和重构测试以保持其有效性和可维护性。

#### 最佳实践
- **单元测试的最佳实践有哪些？**
  **单元测试** 的最佳实践包括：
  - **编写清晰、描述性的测试名称**：您的测试名称应记录测试正在做什么。例如，`testIsEmptyListReturnedWhenNoElementsAdded()` 比 `testList()` 更具信息量。
  - **保持测试独立**：每个测试都应独立于其他测试运行。避免测试之的共享状态，以防止可能导致 **片状测试 (Flaky Tests)** 的相互依赖。
  - **每个测试测试一个概念**：专注于单元的单个行为或方面。这使得在测试失败时更容易确定哪里出了问题。
  - **使用安排-执行-断言 (AAA) 模式**：使用 **设置 (Arrange)**、调用被测行为 **(Act)** 和断言 **(Assert)** 来构建您的测试。
  - **断言预期结果**：确保您的测试检查单元是否按预期运行。使用有意义的断言，而不是像 `assertNotNull()` 这样的通用断言。
  - **测试边界条件**：包括针对边缘情况和边界条件的测试，以捕获潜在的差一错误和其他与边界相关的 **Bug**。
  - **保持测试快速**：单元测试应快速执行，以鼓励频繁运行测试。
  - **重构测试**：将与生产代码相同的质量标准应用于您的测试代码。重构测试以保持其清洁和可维护。
  - **使用代码覆盖率工具**：以高 **代码覆盖率** 为目标，但不要盲目追求 100%。专注于测试关键路径和复杂逻辑。
  - **避免测试实现细节**：测试单元的公共接口。测试实现可能会导致脆弱的测试，这些测试会在任何重构时中断。
  - **处理预期异常**：如果单元在特定条件下应抛出异常，请编写测试以断言抛出了该异常。
  - **明智地使用模拟对象**：模拟依赖项以隔离被测单元，但不要过度使用模拟，因为它们可能会隐藏问题并创建紧密耦合的测试。
  请记住，**单元测试** 的目标是创建一个可靠且可维护的 **测试套件**，以提供对单元行为的信心。

- **应该多久运行一次单元测试？**
  单元测试应 **尽可能频繁地** 运行，理想情况下是在每次更改代码库时运行。这通常通过 **持续集成 (CI)** 系统来实现，该系统会在每次提交或推送到版本控制存储库时自动运行测试。频繁运行单元测试有助于：
  - 立即 **捕获回归**。
  - **验证代码更改** 并确保它们不会破坏现有功能。
  - **促进重构**，因为来自测试的即时反馈可以指导开发人员。
  - **加快开发过程**，因为问题被及早发现和修复。

  实际上，这意味着为单元测试设置 **自动触发器**：
  - **在每次提交时**：确保新代码与现有代码库良好集成。
  - **在合并分支之前**：有助于保持主开发分支的稳定性。
  - **作为拉取请求审查的一部分**：防止将缺陷引入代码库。
  - **定期**：捕获基于事件的触发器可能遗漏的问题，例如夜间构建。

  在 **测试驱动开发 (TDD)** 环境中，单元测试运行得更加频繁，因为它们是红-绿-重构周期的一部分：
  1. 编写一个失败的单元测试 (红)。
  2. 编写最少的代码以通过测试 (绿)。
  3. 重构代码 (并再次运行测试)。
  通过将单元测试集成到开发工作流程中并利用自动化，您可以确保它们发挥提供有关代码库运行状况的快速可靠反馈的作用。

- **如何维护单元测试？**
  维护单元测试对于确保它们随着代码库的发展而保持有效和相关至关重要。以下是一些策略：
  - **更新代码时重构测试**：保持测试清洁和可读，使维护更容易。
  - **删除过时的测试**：删除不再适用于代码库当前状态的测试。
  - **保持测试隔离**：避免依赖关系，以免在单个功能更改时破坏多个测试。
  - **使用版本控制**：跟踪测试的更改以及代码的更改。
  - **定期运行测试**：理想情况下通过持续集成来及早发现问题。
  - **在修复 Bug 之前更新测试**：确保测试捕获 Bug 并验证修复。
  - **记录测试意图**：必要时使用清晰的命名约定和注释。
  - **避免测试实现细节**：专注于行为，以减少重构代码时更改测试的需要。
  - **审查测试**：在代码审查期间确保测试符合最佳实践并保持最新。
  - **监控测试覆盖率**：确保测试新代码并识别冗余或缺失的测试。
  - **参数化测试**：使用单个测试用例覆盖一系列输入，使其更易于扩展和维护。
  遵循这些准则，您可以使您的单元测试在软件项目的整个生命周期内保持稳健、相关和有价值。

- **当单元测试失败时应该做什么？**
  当单元测试失败时，**立即调查** 原因。遵循以下步骤：
  1. **审查测试用例**：确保其设计正确且正在测试其应测试的内容。
  2. **再次运行测试**：检查是否由于非确定性行为或外部依赖项而导致的片状测试。
  3. **检查失败消息** 和堆栈跟踪以获取线索。
  4. **调试测试**：逐步执行代码并确定它在何处偏离了预期行为。
  5. **检查最近的更改**：使用版本控制历史记录检查可能影响测试的代码库更改。
  6. **隔离问题**：如有必要，编写额外的测试以查明问题。
  7. **修复代码**：修复导致测试失败的代码，而不是测试本身，除非测试有缺陷。
  8. **重构代码**：如果修复增加了复杂性或重复逻辑，请重构代码，确保所有测试仍然通过。
  9. **运行完整的测试套件**：确认更改没有破坏其他任何内容。
  10. **提交修复和测试** 到版本控制系统。
  11. **记录问题** 和解决方案（如果它是一个经常出现的问题或可能对团队有益）。
  请记住，失败的单元测试是一个有价值的信号，表明代码中存在需要注意的问题。将其视为改进代码库和预防未来问题的机会。

# 用例 (Use Case)
[用例 (Use Case)](#use-case)
### 相关术语：
- 用例测试 (Use Case Testing)
[用例测试 (Use Case Testing)](/glossary/use-case-testing)
## 关于用例 (Use Case) 的常见问题？

#### 基础与重要性
- **在软件测试中，什么是用例？**
  在 **软件测试** 中，**用例 (Use Case)** 是参与者（用户或其他系统）对系统特定使用的描述。它概述了参与者与系统之间实现特定目标所需的交互序列。**用例** 在 **功能测试** 中起着重要作用，因为它们从最终用户的角度定义了系统必须满足的需求。
  **用例** 通常包括 **主要成功场景**——事件的标准流程——并且还可能描述 **替代流程** 和 **异常流程**，涵盖不同的使用场景和错误条件。这种全面的覆盖确保了源自 **用例** 的测试可以验证系统在各种条件下是否正常运行。
  **用例** 不仅仅是关于 **快乐路径**；它们还封装了场景开始前必须满足的 **前置条件** 和场景完成后应为真的 **后置条件**。这有助于设置 **测试环境** 和评估 **测试执行** 的结果。
  在 **测试自动化** 中，**用例** 指导自动化 **测试脚本** 的创建。这些脚本模拟参与者的动作和输入以验证系统的响应。通过自动化 **用例**，测试人员可以有效地重复这些场景进行 **回归测试**，确保新更改不会破坏现有功能。
  虽然 **用例** 侧重于用户交互，但它们也可以通过突出性能和可用性考虑因素来告知 **非功能测试**。例如，描述大容量交易场景的 **用例** 可以导致模拟重负载条件的性能测试。

- **为什么用例在软件开发中很重要？**
  **用例** 在软件开发中至关重要，因为它们提供了一种 **结构化的方式来捕获功能需求**。它们描述了用户如何与系统交互，提供了预期行为和结果的清晰图景。这有助于 **定义系统的范围**，并确保考虑所有利益相关者的期望。
  在 **测试自动化** 的背景下，**用例** 作为创建 **综合测试计划** 的基础。它们有助于识别要测试的关键路径，并确保系统在真实用户使用时按预期运行。通过关注用户交互，**用例** 使测试人员能够优先考虑并设计涵盖 **关键功能** 的测试。
  此外，**用例** 通过提供易于理解的共同语言来促进团队成员之间的 **沟通**。这在成员可能具有不同专业领域的 **跨职能团队** 中尤为重要。**用例** 有助于弥合技术和非技术利益相关者之间的差距，确保每个人对系统应该做什么有共同的理解。
  总之，**用例** 很重要，因为它们：
  - 定义系统范围和功能。
  - 协助为自动化创建有效的测试计划。
  - 根据用户交互对测试进行优先排序。
  - 增强团队之间的沟通和理解。
  通过关注用户交互和结果，**用例** 有助于开发健壮的、以用户为中心的软件系统以及创建有效的自动化测试。

- **用例的关键组成部分是什么？**
  **用例** 的关键组成部分包括：
  - **标题 (Title)**：封装用例目的的清晰、描述性名称。
  - **主要参与者 (Primary Actor)**：发起用例的主要实体，通常是用户角色或外部系统。
  - **利益相关者和利益 (Stakeholders and Interests)**：对用例结果有既得利益的其他实体列表。
  - **前置条件 (Preconditions)**：在用例开始之前必须为真的条件。
  - **后置条件 (Postconditions)**：用例成功完成后必须为真的条件。
  - **主要成功场景 (Main Success Scenario)**：描述实现目标的事件标准流程的逐步叙述。
  - **扩展 (Extensions)**：可能发生的替代流程，包括异常和错误条件。
  - **特殊需求 (Special Requirements)**：任何相关的非功能需求或约束，例如性能标准或法规遵从性。
  - **使用频率 (Frequency of Use)**：用例可能被发起的频率指示。
  - **杂项 (Miscellaneous)**：任何其他相关信息，例如数据变体或相关业务规则。
  这些组件确保 **用例** 是全面的，并提供对参与者与系统之间交互的清晰理解。它们作为创建验证系统预期行为的 **测试用例** 和场景的基础。

- **用例如何帮助理解系统功能？**
  **用例** 通过提供用户如何与系统交互以实现特定目标的 **结构化描述**，促进了对系统功能的 **更深入理解**。它们提供了一个 **叙述**，引导测试人员完成一系列步骤，揭示系统在各种条件下的 **预期行为**。这种叙述有助于测试人员 **设想** 用户的观点并 **验证** 系统支持所有预期的 **用例**，确保满足 **功能需求**。
  通过概述用户（参与者）与系统之间的 **交互**，**用例** 有助于 **识别** 需要彻底测试的 **关键路径**。它们还 **突出** 系统不同部分之间的 **依赖关系** 和 **交互**，这对于设计 **集成测试** 至关重要。
  在 **测试自动化** 中，**用例** 在 **定义自动化测试范围** 方面起着重要作用。它们可以直接转换为模拟用户操作的 **自动化测试脚本**，为通过或未通过测试提供 **明确的标准**。**用例** 与自动化测试之间的这种对齐确保了自动化工作是 **集中的** 并且 **相关** 于用户的需求。
  此外，**用例** 可用于通过将自动化测试与全范围的 **用例** 进行比较来 **检测测试覆盖率中的差距**。这种比较可以揭示 **未测试的路径** 或 **场景**，提示创建额外的自动化测试以覆盖这些区域。
  总之，**用例** 是理解系统功能并确保 **测试自动化** 工作与用户需求和系统行为 **保持一致** 的 **重要工具**。

- **用例和测试用例有什么区别？**
  **用例** 是从最终用户的角度对系统功能的高级描述。它概述了参与者（用户或其他系统）与系统之间实现目标的交互。**用例** 侧重于系统行为的 **意图** 和 **目的**，而不详细说明实现它的具体步骤。
  相比之下，**测试用例** 是一组条件和变量，测试人员通过这些条件和变量确定被测系统是否满足需求或工作正常。**测试用例** 更细粒度，包括详细的输入、执行步骤和 **预期结果**。它们旨在验证软件的实现，确保其符合指定的需求。
  **用例** 是关于系统应该做 **什么**，而 **测试用例** 是关于 **如何** 验证系统做它应该做的事情。**测试用例** 源自 **用例** 和其他规范，例如 **功能需求**。它们对于系统测试至关重要，通常包括正面和负面场景以确保全面覆盖。
  总之，**用例** 描述 **期望的系统交互** 并作为创建 **测试用例** 的基础，测试用例是验证这些交互的 **实际步骤**。**测试自动化** 工程师使用 **用例** 来理解系统功能的范围和上下文，然后开发 **测试用例** 来自动化该功能的 **验证**。

#### 用例图
- **什么是用例图？**
  **用例图** 是 **外部参与者** 和正在开发的 **系统** 之间交互的视觉表示。它勾勒出用户（参与者）与系统交互以实现目标的各种方式，从外部角度突出系统的功能。
  在 **测试自动化** 的上下文中，**用例图** 用作识别 **测试场景** 的高级指南。它包括 **参与者**（用户或其他系统）、**用例**（参与者想要实现的目标）和 **关联**（连接参与者与他们参与的 **用例** 的线）。可选地，它还可以描绘 **系统边界**（以划定系统的范围），以 **包含 (include)** 或 **扩展 (extend)** 关系（显示 **用例** 之间的共享或条件步骤）。
  通过可视化交互和关系，该图有助于确保在 **测试用例** 创建期间考虑所有功能路径。它还可以揭示可能影响测试策略的复杂性和依赖性。
  这是一个 **用例图** 语法的简单示例：
  ```plantuml
  @startuml
  left to right direction
  actor Customer
  actor Bank

  rectangle BankingSystem {
    Customer -- (Withdraw Money)
    Customer -- (Deposit Money)
    (Transfer Funds) .> (Withdraw Money) : extends
    Bank -- (Create Account)
  }

  @enduml
  ```
  此 UML (统一建模语言) 片段将生成一个图表，显示客户与银行系统交互以取款和存款，以及可以创建账户的银行参与者。“转账” **用例** 扩展了“取款” **用例**，表明转账包括取款的步骤。

- **用例图的元素有哪些？**
  **用例图** 的元素包括：
  - **参与者 (Actors)**：代表与系统交互的外部实体，例如用户或其他系统。
  - **用例 (Use Cases)**：描述参与者与系统之间为实现目标而进行的交互的椭圆。
  - **系统边界 (System Boundary)**：框定用例的矩形，定义系统的范围。
  - **关联 (Associations)**：连接参与者与用例的线，表示参与交互。
  - **包含 (Include)**：带有虚线的定向箭头，显示一个用例包含另一个用例的功能。
  - **扩展 (Extend)**：带有虚线的定向箭头，表示一个用例在特定条件下扩展另一个用例。
  - **泛化 (Generalization)**：带有空心箭头的实线，说明参与者或用例之间的继承关系。
  **用例图** 是指定系统内参与者和 **用例** 之间关系和交互的视觉表示。它们充当讨论和管理系统需求的工具。

- **如何创建用例图？**
  创建 **用例图** 涉及以下步骤：
  1. **识别系统边界**：定义系统的内部和外部，通常由矩形表示。
  2. **确定参与者**：列出与系统交互的所有外部实体。参与者可以是用户或其他系统。
  3. **查找用例**：枚举系统应为每个参与者执行的所有功能。
  4. **连接参与者与用例**：在参与者及其各自的 **用例** 之间画线以显示交互。
  5. **包含关系**：必要时使用包含、扩展或泛化关系来显示 **用例** 之间的依赖关系。
  6. **审查和验证**：确保图表准确代表所有用户交互和系统功能。
  这是一个使用文本描述的 Markdown 简单示例：
  ```markdown
  # 用例图示例

  ## 系统边界
  矩形：在线购物系统

  ## 参与者
  - 客户
  - 支付网关

  ## 用例
  - 浏览商品
  - 将商品添加到购物车
  - 结账
  - 付款

  ## 连接
  - 客户 -> 浏览商品
  - 客户 -> 将商品添加到购物车
  - 客户 -> 结账
  - 结账 -> 付款
  - 付款 -> 支付网关

  ## 关系
  - 结账 -> 付款 (包含)
  ```
  记得保持图表 **简单** 并 **专注** 于用户交互。避免堆砌过多的细节，这些细节可以保留给更详细的 **用例场景** 或其他图表。

- **参与者在用例图中的作用是什么？**
  在 **用例图** 中，**参与者** 代表与系统交互的角色，包括用户和其他系统。它们是通过请求系统执行功能来发起 **用例** 的外部实体。参与者有助于定义系统的边界并阐明谁或什么将与其交互。它们不是系统本身的一部分，但对于指定系统的上下文和需求至关重要。在 **测试自动化** 中，理解参与者对于识别应该测试系统的不同角度至关重要，确保在 **测试用例** 中考虑所有用户交互。

- **用例图如何帮助系统设计？**
  **用例图** 通过提供系统功能从用户角度的 **视觉表示** 来帮助系统设计。它有助于识别各种参与者与系统之间的 **交互**，确保在设计中考虑所有用户交互。这个可视化工具突出了 **系统的范围**，阐明了哪些功能包含在内，哪些在系统边界之外。
  通过映射 **用例**，设计人员可以发现系统不同部分之间的 **冗余** 和 **依赖关系**，这可以导致更 **模块化** 和 **可扩展** 的架构。它还促进了利益相关者之间的 **沟通**，因为技术和非技术团队成员都很容易理解图表，从而弥合了用户需求与系统开发人员之间的差距。
  在 **测试自动化** 的上下文中，图表作为创建与用户交互一致的 **测试计划** 和 **测试脚本** 的基础。它确保 **测试用例** 涵盖 **用例** 所代表的所有功能，从而实现全面的 **测试覆盖率**。此外，它还可用于根据 **用例** 在现实场景中的频率和关键性来 **优先排序测试用例**，从而优化测试工作。
  总体而言，**用例图** 是系统设计中的一种战略工具，有助于以用户为中心的方法，确保最终产品符合用户需求和期望，同时促进结构化和高效的测试过程。

#### 用例场景
- **什么是用例场景？**
  **用例场景** 是一个详细的叙述，描述了用户（或“参与者”）与系统之间为实现特定目标而进行的交互。它概述了参与者为完成任务而采取的一系列步骤，包括任何系统响应。与可能包含多个场景的更广泛的 **用例** 不同，**用例场景** 侧重于单一事件流。
  **用例场景** 在 **测试自动化** 中起着重要作用，因为它们提供了创建 **测试脚本** 的基础。它们有助于可视化功能的端到端功能，这些功能可以转换为自动化的 **测试用例**。这些场景确保自动化测试覆盖应用程序的实际使用情况。
  这是一个 markdown 格式的 **用例场景** 示例：
  ```markdown
  **标题：** 从 ATM 取款

  **主要参与者：** 银行客户

  **前置条件：**
  - ATM 正在运行。
  - 客户拥有有效的银行卡和 PIN。

  **主流程：**
  1. 客户插入银行卡。
  2. 系统提示输入 PIN。
  3. 客户输入 PIN。
  4. 系统验证 PIN 并显示交易选项。
  5. 客户选择“取款”。
  6. 系统提示输入金额。
  7. 客户输入金额。
  8. 系统分发取款并打印收据。
  9. 客户拿走现金和收据。
  10. 系统弹出银行卡。
  11. 客户拿走卡。

  **后置条件：**
  - 客户已收到正确金额的现金。
  - 客户的账户余额已更新。
  - ATM 准备好进行下一次交易。
  ```
  在 **测试自动化** 中，此类场景对于定义 **测试用例** 的范围和确保自动化测试准确反映用户交互至关重要。它们还有助于在影响最终用户之前识别边缘情况和潜在的系统问题。

- **用例场景与用例有何不同？**
  **用例** 通过描述 **参与者**（用户或其他系统）与系统本身之间为实现目标而进行的交互来概述系统的 **功能需求**。这是一个高级描述，保持相对抽象，侧重于交互的意图和最终结果。
  相比之下，**用例场景** 是一个特定的叙述或事件流，说明了通过 **用例** 的单一路径。它提供了参与者动作和系统响应的详细、逐步说明。**用例场景** 是具体的例子，展示了如何在实践中满足需求。
  虽然 **用例** 可能声明用户可以处理交易，但 **用例场景** 将详细说明处理该交易的步骤，例如登录、输入交易详细信息、提交交易进行处理以及接收确认。
  **用例场景** 在 **测试自动化** 中特别有用，因为它们将 **用例** 的抽象需求转换为有形的 **测试脚本**。每个场景都可以作为 **测试用例** 的基础，确保系统在特定情况下按预期运行。
  这是一个说明差异的例子：
  **用例**：用户管理他们的个人资料。
  **用例场景**：
  1. 用户登录系统。
  2. 用户导航到个人资料管理页面。
  3. 用户更新他们的电子邮件地址。
  4. 用户保存更改。
  5. 系统确认更新。
  该场景为 **测试自动化** 提供了清晰的序列，而 **用例** 定义了更广泛的能力。

- **如何编写用例场景？**
  编写 **用例场景** 涉及详细说明用户或系统将在应用程序中实现特定目标所采取的步骤。这是一个简明指南：
  1. **识别参与者**：确定谁在与系统交互（例如，用户、外部系统）。
  2. **定义目标**：清楚地说明参与者试图实现的目标。
  3. **设置前置条件**：列出在场景启动之前必须为真的任何条件。
  4. **枚举主流程**：概述参与者为实现目标而采取的主要步骤序列。使用简单、编号的句子以清晰明了。
  5. **描述替代流程**：捕获主流程的任何变体，处理不同的选择或异常。
  6. **指定后置条件**：描述 **用例** 完成后系统的状态，确保目标已实现。
  7. **包含成功标准**：定义什么将使 **用例** 从参与者的角度来看是成功的。
  这是一个登录 **用例场景** 的简化示例：
  ```markdown
  参与者：用户
  目标：成功登录系统

  前置条件：
  - 用户已注册。
  - 登录页面可访问。

  主流程：
  1. 用户导航到登录页面。
  2. 用户输入用户名和密码。
  3. 用户点击登录按钮。
  4. 系统验证凭据。
  5. 用户被重定向到主页。

  替代流程：
  A. 无效凭据：
     1. 系统显示错误消息。
     2. 用户可以尝试重新输入凭据。

  后置条件：
  - 用户已登录并有权访问系统。

  成功标准：
  - 用户在点击登录按钮后 5 秒内获得对主页的访问权限。
  ```
  记得保持场景 **现实** 并 **专注** 于用户交互，避免技术术语以确保利益相关者清晰明了。

- **用例场景在软件测试中的作用是什么？**
  在 **软件测试** 中，**用例场景** 在指导 **测试脚本** 和 **测试用例** 的创建方面起着至关重要的作用。它提供了代表参与者（通常是用户）与系统之间为实现目标而进行的特定交互的详细步骤序列。这个详细的叙述包括 **前置条件**、**触发器** 和 **后置条件**，为测试人员提供了一条清晰的路径。
  **用例场景** 在 **功能测试** 中起着重要作用，因为它们确保通过现实世界的模拟验证所有 **功能需求**。它们有助于发现通过隔离的单元测试可能不明显的 **功能缺陷** 和 **工作流问题**。通过包含各种可能的路径，包括 **替代流程** 和 **异常路径**，**用例场景** 使测试人员能够执行彻底的 **边界值** 和 **负面测试**。
  此外，它们作为 **自动化回归测试** 的基础，确保新更改不会破坏现有功能。测试人员可以自动化场景以在每次 **迭代** 或部署后快速验证系统的行为。
  在 **性能测试** 中，场景有助于在负载和压力条件下对用户行为进行建模。它们可用于为虚拟用户编写动作脚本以模拟现实世界的使用模式，从而识别性能瓶颈。
  最后，**用例场景** 通过代表用户的观点有助于 **用户验收测试 (UAT)**，这对于确保系统在上线前满足业务需求和用户期望至关重要。

- **用例场景如何帮助识别系统中的潜在问题？**
  **用例场景** 通过模拟系统的实际使用情况，有助于识别潜在问题。它们提供了一个 **叙述**，描述了用户如何与系统交互以实现目标。这种叙述有助于揭示：
  - **边缘情况 (Edge Cases)**：场景可以突出用户可能采取的不太明显的路径或交互，这些通常被忽视但可能导致意外行为。
  - **集成点 (Integration Points)**：它们暴露了系统如何与外部系统或模块交互，查明潜在的集成问题。
  - **用户体验问题 (User Experience Issues)**：通过逐步执行用户采取的步骤，场景可以揭示繁琐或不直观的工作流程，这些工作流程可能导致用户错误。
  - **安全漏洞 (Security Vulnerabilities)**：通过概述不同类型的用户如何与系统交互，它们可以帮助识别与安全相关的场景，例如访问控制问题或数据隐私问题。
  - **性能瓶颈 (Performance Bottlenecks)**：涉及复杂交互或高数据负载的场景可以帮助识别现实条件下的性能问题。
  - **需求差距 (Requirement Gaps)**：通过详细说明具体的操作和结果，**用例场景** 可以暴露缺失的需求或对预期功能的误解。
  - **回归影响 (Regression Effects)**：当进行系统更改时，场景有助于确保现有功能不受影响，揭示潜在的回归问题。
  将 **用例场景** 纳入 **测试自动化** 策略可确保测试以用户为中心并专注于实际应用，从而产生更健壮和可靠的系统。

#### 高级概念
- **什么是用例套件？**
  **用例套件 (Use Case Suite)** 是一组相关的 **用例**，归类在一起以便在软件 **测试自动化** 期间作为一个整体进行管理和执行。它是涵盖特定特征、功能或系统方面的有组织的场景集。套件中的每个 **用例** 代表被测系统的不同路径或变体，确保全面覆盖。
  在 **测试自动化** 中，**用例套件** 通常作为一组一起执行的自动化 **测试脚本** 来实现。此套件可以定制以验证特定的需求集或模拟特定的用户旅程。通过运行 **用例套件**，**测试自动化** 工程师可以验证系统在多个场景和条件下是否按预期运行。
  这是如何在代码中表示 **用例套件** 的示例：
  ```javascript
  describe('Login Use Case Suite', () => {
    it('should allow a user with valid credentials to log in', () => {
      // Test code for valid login
    });

    it('should reject a user with invalid credentials', () => {
      // Test code for invalid login
    });

    it('should lock the account after multiple failed login attempts', () => {
      // Test code for account lock
    });

    // Additional use case scenarios...
  });
  ```
  在此示例中，`describe` 块定义套件，每个 `it` 块代表该套件中的单个 **用例场景**。通过对相关场景进行分组，工程师可以更轻松地管理和维护他们的 **测试自动化** 工作。

- **用例和用户故事有什么区别？**
  **用例** 是用户如何与系统交互以实现特定目标的详细描述，通常捕获各种条件下的系统行为。它包括主要成功场景以及替代路径和异常，侧重于用户（参与者）与系统之间的交互。
  相比之下，**用户故事 (User Story)** 是从渴望新功能的人（通常是用户或系统的客户）的角度讲述的功能的简短、简单的描述。用户故事通常用非正式的自然语言编写，并遵循一个简单的模板：“作为一个 [用户类型]，我想要 [一个动作]，以便 [一个好处/价值]。”它们是 **敏捷开发** 中使用的一种工具，用于从最终用户的角度捕获产品功能。
  虽然 **用例** 提供了捕获系统使用的 **功能需求** 和场景的结构化和详细的方法，但用户故事提供了一种捕获用户需求本质的快速、对话式方法。用户故事更多关于“什么”和“为什么”，而 **用例** 深入研究“如何”。用户故事通常伴随着验收标准，这是一组必须满足的条件，以便故事被视为完成。
  在 **测试自动化** 中，用户故事可以指导创建侧重于用户预期结果和利益的 **测试场景**，而 **用例** 可以告知更全面的测试，包括替代流程和异常处理。

- **用例在敏捷开发中的作用是什么？**
  在 **敏捷开发** 中，**用例** 在 **弥合用户需求与软件功能迭代实现之间的差距** 方面起着至关重要的作用。它们作为创建用户故事的 **蓝图**，用户故事是敏捷方法中的主要工作单元。
  **用例** 从用户的角度提供系统交互的 **高级概述**，确保开发团队和利益相关者对系统功能有共同的理解。这种共同的理解有助于 **优先排序** 功能和规划 **迭代** 或冲刺。
  在积压工作细化和冲刺规划期间，**用例** 通常被 **分解** 为更小、更易于管理的用户故事，这些用户故事适合 **迭代**。然后使用这些用户故事来创建 **验收标准**，通过定义软件必须满足才能被视为完成的条件来指导 **测试自动化** 工作。
  此外，**用例** 有助于 **识别** 功能和非功能需求的 **测试场景**，确保全面的 **测试覆盖率**。它们还通过突出应在 **迭代** 之间保持稳定的关键路径和交互来帮助 **回归测试**。
  总之，**敏捷开发** 中的 **用例** 在以下方面起着重要作用：
  - 指导用户故事和验收标准的创建。
  - 确保对系统功能的共同理解。
  - 优先排序开发工作。
  - 识别全面覆盖的测试场景。
  - 通过概述关键系统交互来支持回归测试。

- **如何在非功能测试中使用用例？**
  **用例** 通过为评估性能、安全性和可用性等系统属性提供 **上下文框架**，可以在 **非功能测试** 中发挥重要作用。虽然 **用例** 传统上与 **功能需求** 相关联，但它们也可以概述非功能质量至关重要的场景。
  例如，描述高流量场景的 **用例** 可用于派生性能测试，确保系统可以处理指定的负载。同样，涉及用户身份验证的 **用例** 可以导致侧重于授权和数据保护的安全测试。
  在 **可用性测试** 中，**用例** 有助于理解用户交互，并可用于评估系统的易用性和可访问性。通过模拟 **用例** 中概述的动作和体验，测试人员可以评估系统在多大程度上支持用户实现其目标。
  要在 **非功能测试** 中利用 **用例**：
  - **识别** 具有显着非功能含义的关键 **用例**。
  - 将这些 **用例翻译** 为特定的非功能需求。
  - **设计测试** 以挑战用例描述的系统非功能方面。
  - **执行测试** 以对照用例设定的期望验证系统的性能、安全性、可用性等。
  通过这样做，您可以确保 **非功能测试** 基于现实和相关的用户场景，提供对系统整体质量的全面评估。

- **编写用例时要避免哪些常见错误？**
  编写 **用例** 时，请避免这些常见错误：
  - **忽视用户视角**：始终关注用户的观点。过于以系统为中心的 **用例** 可能会错过用户交互和期望。
  - **过于笼统或过于详细**：关键是取得平衡。过于笼统的 **用例** 缺乏可操作的信息，而过多的细节会让人不知所措并感到困惑。
  - **忽略替代流程**：不要只关注 **快乐路径**。考虑替代和异常流程以确保全面覆盖。
  - **混合功能**：每个 **用例** 应代表单一功能或目标。混合多个目标可能导致混乱和可测试性问题。
  - **忽视非功能需求**：虽然 **用例** 主要关注 **功能需求**，但重要的是要考虑可能影响场景的性能、可用性和安全方面。
  - **未能更新**：随着系统的发展，**用例** 也应随之发展。过时的 **用例** 会导致无关或不正确的测试。
  - **缺乏清晰的范围**：定义 **用例** 将涵盖和不涵盖的边界，以防止范围蔓延并确保集中测试。
  - **定义不清的参与者**：清楚地识别涉及的参与者及其角色。这里的模糊性会导致不完整的测试。
  - **术语不一致**：在整个 **用例** 中使用一致的语言和术语以避免混淆。
  - **跳过验证**：与利益相关者验证 **用例** 以确保准确性和完整性。
  请记住，精心制作的 **用例** 是有效 **测试自动化** 的基础，为测试团队提供清晰且可操作的场景。

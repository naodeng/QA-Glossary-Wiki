# 自动化测试 (Automated Testing)

[自动化测试](#automated-testing)

### 相关术语：
- [手工测试](/glossary/manual-testing)
- [测试自动化](/glossary/test-automation)

### 参见：
- [维基百科 (Wikipedia)](https://en.wikipedia.org/wiki/Test_automation)

## 关于自动化测试的问题？

#### 基础知识与重要性

- **什么是自动化测试？**

**自动化测试 (Automated Testing)** 是指利用软件工具执行预先编写的**测试脚本 (Test Scripts)**，以验证软件应用程序的功能、性能和可靠性的过程。与每一步都需要人工参与的**手工测试 (Manual Testing)** 不同，自动化测试一旦设置完成，运行时的手工干预极少，并且可以重复执行。

测试通常使用与应用程序代码相同或不同的语言编写，并设计为可重用且易于维护。它们的范围可以从验证单个组件的简单单元测试，到验证应用程序内整个工作流程的复杂端到端测试。

自动化测试通常作为**持续集成/持续部署 (CI/CD)** 流水线的一部分被触发，确保新的代码更改不会引入回归。这对于在快速迭代的开发环境中保持**软件质量 (Software Quality)** 至关重要。

```typescript
// TypeScript 中的简单自动化测试脚本示例
import { expect } from 'chai';
import { Calculator } from './Calculator';

describe('Calculator', () => {
  it('应该正确执行两个数字的加法', () => {
    const calculator = new Calculator();
    expect(calculator.add(2, 3)).to.equal(5);
  });
});
```

有效的自动化测试依赖于选择合适的工具和框架，开发稳健的**测试用例 (Test Cases)**，并随着应用程序的演进而对其进行维护。确保全面的**测试覆盖率 (Test Coverage)** 以在部署前发现尽可能多的问题也至关重要。随着 AI 和机器学习的发展，自动化测试正变得更加智能，能够在减少人工输入的情况下预测并适应软件的变化。

- **为什么自动化测试很重要？**

自动化测试对于以手工测试无法企及的速度和规模**确保软件质量**至关重要。它使团队能够在更短的时间内执行更多测试，为代码更改提供**快速反馈 (Rapid Feedback)**。这在现代开发实践（如持续集成和交付是关键的敏捷和 DevOps）中必不可少。

自动化通过允许频繁且一致的测试来支持这些方法，从而尽早发现缺陷，降低了修复 **Bug** 的成本和精力。

此外，自动化测试可以以极低的额外成本**重复运行**，确保在引入新更改后，以前开发的功能仍然正常工作（回归测试）。它们还支持在各种环境和设备上**并行执行**，从而提高了测试覆盖率和效率。自动化测试能产生更**可靠的结果**，减少了人为错误，并提供有助于调试的详细日志。

从本质上讲，自动化测试是**质量保证策略 (Quality Assurance Strategy)** 的基石，旨在及时交付稳健的软件。它通过处理重复、耗时的任务来补充手工测试工作，使人工测试员能够专注于更复杂和**探索性测试 (Exploratory Testing)** 场景。

- **自动化测试有哪些优缺点？**

**自动化测试的优点：**
- **速度与效率**：自动化测试比手工测试运行快，允许在更短的时间内进行更多测试。
- **可重用性**：测试脚本可以在应用程序的不同版本中重用，节省测试准备时间。
- **一致性**：确保每次执行的测试完全相同，消除了人为错误。
- **覆盖率**：能够进行手工操作可能不切实际的彻底测试，包括复杂场景和海量数据集。
- **持续集成**：通过在更改发生时自动运行测试，促进了 CI/CD。
- **早期 Bug 检测**：可以在开发过程中迅速识别 Bug，降低修复成本。
- **非功能性测试**：非常适合难以手工进行的性能、负载和压力测试。

**自动化测试的缺点：**
- **初期投资**：工具和测试环境设置的初期成本较高。
- **维护**：测试脚本需要定期更新以应对应用程序的变化。
- **学习曲线**：团队需要时间来学习工具并开发有效的测试。
- **范围有限**：无法像人类那样处理视觉参考或 UX 评估。
- **误报/漏报**：自动化测试可能会报告非 Bug 的失败（误报），或错过真正的 Bug（漏报）。
- **设置复杂**：某些测试场景难以自动化，可能不值得为此付出努力。
- **工具限制**：工具可能不支持每种技术或应用程序类型，限制了其使用。

- **自动化测试如何融入软件开发生命周期 (SDLC)？**

自动化测试无缝集成到 **SDLC** 的各个阶段，提高了效率和可靠性。

在**需求阶段**，计划自动化测试，并使其与验收标准保持一致。在**设计与开发阶段**，实施自动化单元测试，通常遵循 TDD 实践。随着功能的完成，自动化集成测试验证组件间的交互。

在**测试阶段**，自动化回归测试确保新更改不会破坏现有功能，而自动化系统测试则对整个软件进行验证。自动化端到端 (E2E) 测试模拟用户行为，覆盖完整的应用程序流程。

对于**部署**，自动化测试在 CI/CD 流水线中至关重要，为构建的健康状况提供即时反馈。**部署后**，自动化测试继续支持**维护阶段**，快速识别由补丁或更新引入的问题。

在整个 SDLC 过程中，自动化测试不断得到维护和改进，以适应不断变化的应用程序需求并覆盖新场景。自动化测试的角色是迭代且持续的，与敏捷和 DevOps 方法论相一致，支持快速开发周期和频繁发布。

```typescript
// TypeScript 中的简单自动化单元测试示例
import { add } from './math';

describe('add 函数', () => {
  it('应该正确相加两个数字', () => {
    expect(add(2, 3)).toBe(5);
  });
});
```

- **手工测试和自动化测试有什么区别？**

**手工测试**涉及人工测试员在没有工具或脚本辅助的情况下执行测试用例。而**自动化测试**使用软件工具自动运行测试，管理测试的执行以及实际结果与预期结果的比较。

**关键区别在于：**
- **执行**：手工测试每一步都需要人工干预，而自动化测试由软件执行。
- **速度**：一旦测试开发完成，自动化测试执行速度显著加快。
- **一致性**：自动化测试可以在相同条件下重复运行，确保一致性；手工测试可能会受到人为错误的影响。
- **初期成本**：与手工测试相比，设置自动化测试需要更多前期的投入和资源。
- **维护**：随着应用程序的变化，自动化测试需要维护以保持有效，而手工测试在面对变化时更具适应性，无需额外设置。
- **可扩展性**：自动化测试可以处理大量测试并具备可扩展性，这对手工测试而言具有挑战性。
- **复杂性**：某些复杂的用户交互可能难以自动化，可能更适合手工评估。
- **反馈**：手工测试可以提供即时的定性反馈，而自动化测试则不能。
- **用例**：手工测试通常更适合探索性、易用性和随机测试；自动化测试则是回归、负载和性能测试等的理想选择。

在实践中，平衡地利用这两种方法的优势通常是最有效的策略。

#### 工具与技术

- **自动化测试中常用工具有哪些？**

自动化测试常用工具包括：
- **Selenium**：用于跨各种浏览器和平台的 Web 应用程序测试的开源框架。它支持多种编程语言，如 Java、C# 和 Python。
  ```java
  WebDriver driver = new ChromeDriver();
  driver.get("http://www.example.com");
  ```
- **Appium**：用于在 iOS 和 Android 平台上自动化移动应用程序的开源工具。它使用 WebDriver 协议。
  ```java
  DesiredCapabilities caps = new DesiredCapabilities();
  caps.setCapability("platformName", "iOS");
  caps.setCapability("deviceName", "iPhone Simulator");
  ```
- **JUnit 和 TestNG**：Java 单元测试框架，提供注解和断言来帮助结构化和运行测试。
  ```java
  @Test
  public void testMethod() {
    assertEquals(1, 1);
  }
  ```
- **Cypress**：基于 JavaScript 的端到端测试框架，在浏览器中运行，可对任何在浏览器中运行的内容进行快速、简单且可靠的测试。
  ```javascript
  describe('My First Test', () => {
    it('Visits the Kitchen Sink', () => {
      cy.visit('https://example.cypress.io')
    })
  })
  ```
- **Robot Framework**：基于关键字驱动的测试自动化框架，用于验收测试和验收测试驱动开发 (ATDD)。
  ```robot
  *** Test Cases ***
  Valid Login
      Open Browser To Login Page
      Input Username    demo
      Input Password    mode
      Submit Credentials
  ```
- **Postman**：一款 API 测试工具，允许用户发送 HTTP 请求并分析响应、创建自动化测试以及与 CI/CD 流水线集成。
  ```json
  {
    "id": "f2955b9f-da77-4f80-8f1c-9f8b0d8f2b7d",
    "name": "API Test",
    "request": {
      "method": "GET",
      "url": "https://api.example.com/v1/users"
    }
  }
  ```
- **Cucumber**：支持行为驱动开发 (BDD)，允许以通俗语言规范应用程序行为。
  ```gherkin
  Feature: 登录功能
    Scenario: 使用有效凭据成功登录
      Given 用户在登录页面
      When 用户输入有效凭据
      Then 用户被重定向到主页
  ```
这些工具为不同的测试需求（从单元和集成测试到端到端和 API 测试）提供各种功能。

- **这些工具之间有什么区别？**

不同的自动化测试工具有其独特的功能、能力和**用例**。以下是简要对比：
- **Selenium**：用于跨浏览器和平台的 Web 应用程序测试。它支持多种语言并能与各种框架集成。
- **QTP/UFT (Unified Functional Testing)**：Micro Focus 的商业工具，专注于桌面和 Web 应用的功能和回归测试，使用 VBScript 并以录制与回放功能著称。
- **TestComplete**：另一款商业工具，支持桌面、移动和 Web 应用程序，提供基于脚本和关键字驱动的测试，支持多种编程语言。
- **Cypress**：专为现代 Web 应用程序设计的基于 JavaScript 的端到端测试框架，与应用程序在同一运行循环中运行测试，提供实时反馈。
- **Jest**：专注于简单性的 JavaScript 测试框架，支持单元和集成测试，非常适合 React。
- **Appium**：移动应用程序自动化测试工具，支持原生、混合及移动 Web 应用。
- **Robot Framework**：使用表格化测试数据语法的关键字驱动框架，易于非编程背景人员学习。

每种工具都有其优势，选择通常取决于被测应用、首选编程语言以及测试流程的具体要求。

- **如何为特定测试任务选择合适的工具？**

选择合适工具需要考虑：
- **兼容性**：确保工具支持应用的技术栈（如 Web、移动、桌面）。
- **易用性**：选择符合团队技能水平的工具。过高的学习曲线可能会阻碍生产力。
- **集成**：工具应能与现有工作流（如版本控制、CI/CD、缺陷跟踪）无缝集成。
- **可扩展性**：考虑工具能否处理应用随增长而增加的规模和复杂性。
- **灵活性**：编写自定义函数或与其他工具集成的能力对复杂场景至关重要。
- **报告**：详细的报告和分析有助于快速识别趋势并定位问题。
- **支持与社区**：强大的社区和厂商支持对解决故障及保持工具更新非常有价值。
- **成本**：根据预算评估成本，包括许可、维护及潜在的培训费用。
- **性能**：工具应能高效快速地执行测试，以跟上快速开发周期的步伐。
- **可靠性**：选择具有稳定性口碑的工具，避免不稳定的测试 (Flaky tests)。

通过权衡这些因素，您可以选择出能提高测试效率和有效性的工具。

- **自动化测试中常用技术有哪些？**

常用技术包括：
- **页面对象模型 (POM)**：将页面元素和交互封装在类中，促进代码重用和**可维护性 (Maintainability)**。
- **模块化测试**：将测试分解为具有独立测试脚本的较小模块，增强可维护性和可扩展性。
- **混合测试框架**：结合多种测试方法（如关键字驱动和数据驱动）以利用其各自优势。
- **行为驱动开发 (BDD)**：使用自然语言描述定义应用行为，促进利益相关者之间的沟通。
- **测试驱动开发 (TDD)**：在实际代码之前编写测试用例，确保软件在构建时就考虑了测试。
- **数据驱动测试**：使用外部数据源向测试用例输入多组数据，提高覆盖率和效率。
- **关键字驱动测试**：使用代表动作和数据的关键字定义测试，使测试更易于理解和维护。
- **持续测试**：将测试集成到集成与交付流水线中，提供即时反馈。
- **并行测试**：在不同环境中同步执行多个测试，缩短测试执行时间。
- **API 测试**：侧重于直接测试 API 的功能、可靠性、性能和安全性。
- **Mock 和 Stub**：使用虚假对象和存根模拟真实组件行为，实现部分系统的隔离测试。
- **视觉回归测试**：通过对比当前截图与基准图像来检测非预期的视觉变化。
- **负载与性能测试**：模拟用户负载以检查不同条件下的性能和可扩展性。
- **安全测试**：探测应用漏洞的自动化脚本。

这些技术可以根据具体项目需求进行组合和定制，以确保稳健高效的自动化测试流程。

- **如何将自动化测试工具集成到 CI/CD 流水线中？**

集成步骤包括：
1. **选择合适的工具**：应能与 CI/CD 服务器（如 Jenkins, GitLab CI, CircleCI）无缝集成。
2. **配置 CI/CD 服务器**：触发自动化测试，通常在流水线配置文件中定义任务或阶段。
3. **设置测试环境**：配置专用的测试服务器、容器化环境或云服务。
4. **编写测试脚本**：脚本需兼容 CI/CD 环境且无需人工干预即可执行。
5. **版本控制**：将测试脚本与应用代码一同存放。
6. **定义触发器**：如每次提交、每晚构建或手动触发。
7. **执行与报告**：将测试作为流水线一部分运行，并将结果反馈给 CI/CD 服务器。
8. **处理测试结果**：设置通知、仪表盘或与其他工具集成进行结果分析。
9. **管理测试数据**：确保各次运行之间的数据一致性。
10. **自动部署**：在运行测试前将应用部署到测试环境。

Jenkinsfile 流水线配置片段示例：
```groovy
pipeline {
    agent any
    stages {
        stage('Test') {
            steps {
                // 检出代码
                checkout scm
                // 运行测试
                script {
                    // 执行测试命令
                    sh 'npm test'
                }
            }
            post {
                always {
                    // 发布测试结果
                    junit '**/target/surefire-reports/TEST-*.xml'
                }
            }
        }
    }
}
```
确保流水线设计为**如果测试失败则停止部署**，以维持发布质量。

#### 测试用例与脚本

- **如何为自动化测试开发测试用例？**

步骤如下：
1. **识别测试需求**：分析被测应用 (AUT) 以确定测试需求，侧重于高风险或频繁更改的功能。
2. **定义测试目标**：明确每个测试用例应验证的内容。
3. **设计测试用例**：创建详细的用例，包括预设条件、测试数据、操作步骤和**预期结果 (Expected Results)**。
4. **参数化测试**：使测试用例数据驱动。
5. **创建断言 (Assertions)**：实现断言以检查 AUT 的响应。
6. **开发测试脚本**：使用工具或框架编写脚本，遵循编码最佳实践（如 UI 测试使用 POM）。
7. **设置测试环境**：配置所需的流量。
8. **实现测试执行逻辑**：定义执行顺序、依赖关系和前后置处理。
9. **评审与精炼**：进行同行评审或走读，并根据需要进行重构。
10. **版本控制**：存放脚本以方便跟踪更改。
11. **集成 CI/CD**：实现持续验证。

通过这些步骤，测试自动化工程师可以创建出贡献于软件整体质量的稳健、可靠且有效的自动化测试用例。

- **自动化测试背景下的“测试脚本”是什么？**

在自动化测试中，**测试脚本 (Test Script)** 是由自动化工具执行的一组指令，用于验证软件的功能。它本质上是一个将手工测试用例步骤自动化的程序。

测试脚本与被测应用 (AUT) 交互，输入数据，并将预期结果与实际结果进行比较。它们使用工具支持的编程或脚本语言编写，如 JavaScript、Python 或 Ruby。

JavaScript 示例：
```javascript
describe('登录页面测试', function() {
  it('应该允许用户登录', function() {
    goToLoginPage();
    enterUsername('testUser');
    enterPassword('password123');
    submitLoginForm();
    expect(isLoggedIn()).toBe(true);
  });
});
```
有效的测试脚本具备：
- **可重用性**：通用函数可在多个用例中使用。
- **可维护性**：应用变化时易于更新。
- **可读性**：简洁明了，方便他人理解。
- **可靠性**：结果一致并能优雅处理异常。

脚本通常组织在**测试套件 (Test Suites)** 中以便管理，是流水线中频繁且自动化校验构建的关键。

- **如何确保测试用例覆盖所有可能场景？**

策略如下：
- **等价类划分 (Equivalence Partitioning)**：将输入划分为逻辑组，每组测试一个代表值。
- **边界值分析 (Boundary Value Analysis)**：关注输入范围边缘的极值。
- **判定表测试 (Decision Table Testing)**：探索不同输入组合及其对应动作。
- **状态转换测试 (State Transition Testing)**：将场景建模为系统状态及转换。
- **用例测试 (Use Case Testing)**：根据真实用户旅程导出测试。
- **组合测试 (Combinatorial Testing)**：如两两组合 (Pairwise) 测试参数间交互。
- **基于风险的测试 (Risk-Based Testing)**：根据失败风险和影响确定优先级。
- **探索性测试**：用手工探索补充自动化，发现异常行为。
- **基于模型的测试 (Model-Based Testing)**：从系统模型生成测试。
- **代码覆盖率分析 (Code Coverage Analysis)**：使用工具衡量被执行代码的范围。

定期评审并更新用例以适应应用及使用模式的变化。

- **编写测试脚本有哪些最佳实践？**

最佳实践包括：
- **可维护性**：编写清晰代码，使用 POM 隔离逻辑与 UI 结构。
- **重用性**：为通用操作创建可重用函数，减少重复。
- **模块化**：分解为独立模块，增强可读性和调试性。
- **数据分离**：将测试数据与脚本分离，使用外部数据源（JSON, CSV 等）。
- **版本控制**：跟踪更改并协作。
- **命名规范**：使用描述性名称，一目了然。
- **错误处理**：实现稳健的异常管理，使测试优雅失败并提供清晰的消息。
- **断言**：使用明确具体的断言。
- **并行执行**：尽可能设计为并行运行。
- **清理**：始终清理测试数据并恢复系统状态。
- **报告**：生成日志和报告。
- **持续集成**：集成到流水线。

- **随着时间推移，如何管理和维护测试用例及脚本？**

策略如下：
- **版本控制**：使用 Git 等系统。
- **模块化设计**：减少维护工作量。
- **文档化**：记录目的、输入、预期结果及变更历史。
- **重构**：定期改进代码质量，去除冗余。
- **代码评审**：确保脚本质量和标准。
- **自动化检查**：使用 Lint 和代码分析工具。
- **测试数据管理**：使用数据工厂等策略。
- **持续集成**：确保持续兼容。
- **监控**：识别并不稳定的测试。
- **优先级排序**：优先维护高影响区域。
- **弃用策略**：移除过时测试。

#### 自动化测试的类型

- **什么是单元测试？**

**单元测试 (Unit Testing)** 是指对应用程序中最小可测试部分（通常是函数或方法）进行孤立测试的实践，以确保每个组件按预期运行。单元测试通常由开发人员在编写代码时同步编写和运行。

在自动化测试背景下，单元测试自动执行，通常作为构建过程或 CI 系统的一部分。它们对于在周期早期识别问题、降低修复成本至关重要。单元测试的特点是范围窄且速度快。使用 JUnit、NUnit 或 Jest 等框架编写，包含断言。

```typescript
import { add } from './math';

test('1 + 2 应该等于 3', () => {
  expect(add(1, 2)).toBe(3);
});
```

- **什么是集成测试？**

**集成测试 (Integration Testing)** 是软件测试的一个级别，在这种测试中，单个单元或组件被组合并作为整体进行测试。主要目标是验证集成模块之间的功能、性能和可靠性。

自动化集成测试通常被纳入构建流程，确保新更改不会破坏组件间的交互。它们比单元测试更复杂，因为需要配置多个组件交互的环境，侧重于数据流、API 契约及 UI 组合。

示例：
```typescript
import { expect } from 'chai';
import { fetchData, processInput } from './integrationComponents';

describe('集成测试', () => {
  it('应该处理输入并返回预期数据', async () => {
    const input = '测试输入';
    const processedData = await processInput(input);
    const fetchedData = await fetchData(processedData);

    expect(fetchedData).to.be.an('object');
    expect(fetchedData).to.have.property('key', 'expected value');
  });
});
```

- **什么是系统测试？**

**系统测试 (System Testing)** 是一个高水平的测试阶段，评估完整且集成的软件系统以验证其是否符合规定需求。通常在集成测试之后、验收测试之前进行，关注多种条件下的行为和输出。应用在接近生产的环境中测试，包括数据库、网络和服务器交互。

关键方面包括：
- 功能测试
- 性能测试
- 安全测试
- 易用性测试
- 兼容性测试

自动化系统测试能显著显著节省重复性检查的时间。

- **什么是回归测试？**

**回归测试 (Regression Testing)** 是验证以前开发和测试过的软件在经过增强、补丁或配置更动后仍能正确执行的过程，确保新代码未对现有功能产生负面影响。在自动化测试中，它们通常作为流水线中频繁运行的测试套件的一部分执行。

示例：
```javascript
describe('计算器', () => {
  test('应该正确执行加法', () => {
    expect(add(1, 2)).toBe(3);
  });
});
```

- **黑盒测试和白盒测试有什么区别？**

**黑盒测试 (Black box testing)** 将软件视为不透明实体，关注输入和输出而不考虑内部代码。测试人员根据规格说明验证功能，不了解内部逻辑。

**白盒测试 (White box testing)** 则需要了解内部逻辑，检查代码结构以确保正确运行，如循环、分支和路径覆盖率。

黑盒测试通常是更高水平的（如 UI 测试），而白盒测试通常更低水平（如单元测试）。

- **什么是端到端 (E2E) 测试，为什么它很重要？**

**端到端测试 (End-to-end testing)** 是一种模拟真实用户场景对整个应用程序进行测试的技术，涉及数据库、网络、硬件及其他应用的交互。目标是验证从开始到结束的系统集成及数据完整性。它验证系统的整体健康状况，能发现孤立测试难以察觉的问题。

#### 高级概念

- **什么是测试驱动开发 (TDD)，它与自动化测试有什么关系？**

**测试驱动开发 (TDD)** 是一种在编写实现代码之前先编写测试的方法。其周期为：**编写测试** -> **运行测试（初始失败）** -> **编写最小代码使其通过** -> **重构代码并确保测试通过**。

TDD 固有的依赖于自动化测试，因为它确保每个新功能都对应一个自动化的**测试用例**。这种方法能提供持续反馈、防止回归、影响设计并增加重构信心。

- **什么是行为驱动开发 (BDD)，它与自动化测试有什么关系？**

**行为驱动开发 (BDD)** 是一种鼓励开发者、QA 和业务人员协作的敏捷过程，侧重于通过讨论达成对软件行为的一致理解。它扩展了 TDD，使用非程序员也能阅读的自然语言编写测试用例。

BDD 通过提供框架（如 Gherkin 语言）将人性化描述转化为可由 Cucumber 等工具执行的自动化测试。它确保自动化测试从用户角度出发，与业务需求及预期行为保持一致。

- **什么是数据驱动测试？**

**数据驱动测试 (DDT)** 是一种使用多组输入数据执行相同测试步骤的自动化策略。通过将测试逻辑与存储在 CSV、Excel、数据库等外部数据源中的**测试数据**分离，从而在不增加脚本数量的情况下提高覆盖率。

- **什么是关键字驱动测试？**

**关键字驱动测试**使用一套预定义的关键字（代表点击、输入等动作）来编写测试用例，而无需直接编写代码。这使得非编程背景的人员也能参与设计和执行测试，实现了测试设计与脚本实现的解耦，方便维护和扩展。

- **AI 和机器学习在自动化测试中的角色是什么？**

AI 和 ML 正在通过以下方式改变自动化测试：
- **预测分析**：优化测试套件，优先执行高风险测试。
- **模式识别**：通过学习历史执行结果预判失败。
- **自愈测试 (Self-healing tests)**：在 UI 或 API 变动时自动更新脚本，大幅降低维护成本。
- **视觉测试**：检测肉眼可见但脚本难以捕捉的 UI 差异。
- **测试生成**：分析用户行为自动生成测试用例。

总之，AI 和 ML 使测试过程变得更聪明、更高效。

<!-- markdownlint-disable MD041 -->
- [Actual Result 实际结果](#actual-result-实际结果)
- [关于实际结果的问题](#关于实际结果的问题)
  - [基础知识和重要性](#基础知识和重要性)
    - [在软件测试中“实际结果”的定义是什么？](#在软件测试中实际结果的定义是什么)
    - [为什么在 e2e 测试中确定 "实际结果 "很重要？](#为什么在-e2e-测试中确定-实际结果-很重要)
    - [“实际结果”对整个测试过程有何贡献？](#实际结果对整个测试过程有何贡献)
  - [比较与对比](#比较与对比)
    - [“预期结果”和“实际结果”有什么区别？](#预期结果和实际结果有什么区别)
    - [“实际结果”与“测试用例”有何关系？](#实际结果与测试用例有何关系)
    - [在什么情况下“实际结果”可能与“预期结果”不同？](#在什么情况下实际结果可能与预期结果不同)
  - [实际应用](#实际应用)
    - [测试过程中如何记录“实际结果”？](#测试过程中如何记录实际结果)
    - [有哪些常用工具或方法可用于获取 "实际结果"？](#有哪些常用工具或方法可用于获取-实际结果)
    - [如何使用 "实际结果 "来识别和诊断软件缺陷或问题？](#如何使用-实际结果-来识别和诊断软件缺陷或问题)
  - [深层理解](#深层理解)
    - [“实际结果”如何影响回归测试？](#实际结果如何影响回归测试)
    - [“实际结果”在自动化测试中扮演什么角色？](#实际结果在自动化测试中扮演什么角色)
    - [“实际结果”差异如何有助于软件优化和改进？](#实际结果差异如何有助于软件优化和改进)

# Actual Result 实际结果

>实际结果（又称为测试结果）

实际结果是在进行测试后获得的结果。在测试阶段，实际结果会与测试用例一起记录。在所有测试结束后，它将与预期结果进行比较，注意任何差异。

# 关于实际结果的问题

## 基础知识和重要性

### 在软件测试中“实际结果”的定义是什么？

在[软件测试](../S/software-testing.md)中，**实际结果**指的是执行测试时观察到的系统行为。它是测试步骤执行后应用程序的输出、响应或状态。然后，将这个结果与**[预期结果](../E/expected-result.md)**进行比较，以确定测试是通过还是失败。实际结果对于发现可能存在缺陷或需要改进的地方至关重要。

实际结果通常记录在[测试管理](../T/test-management.md)工具中或直接在自动化测试代码中。它们作为测试执行的证据，对于测试过程中的可追溯性和责任制非常重要。当实际结果与[预期结果](../E/expected-result.md)不一致时，会引发调查，可能导致[缺陷](../B/bug.md)修复和功能增强，以确保软件符合其要求并能够按照预期运行。

### 为什么在 e2e 测试中确定 "实际结果 "很重要？

在端对端（e2e）测试中，确定**实际结果**对于验证**整个应用程序流程的完整性**至关重要。这确保了每个集成组件在按顺序操作时（从开始到结束）都能按预期运行。通过将实际结果与[预期结果](../E/expected-result.md)进行比较，测试人员可以确认系统在各种条件下，包括**用户交互、数据处理和连接性**时是否按照设计行为。

在 e2e 测试中，实际结果是[测试执行](../T/test-execution.md)的**结果**。它为评估系统是否符合业务需求和用户需求提供了**具体的依据**。当存在不一致时，它们突显了可能影响用户体验或系统可靠性的**潜在问题**，促使进一步的调查和改进。

此外，实际结果在**保持测试可信度**方面起着重要作用。它为利益相关方提供了关于系统当前状态和测试策略有效性的有形证据。这种透明性对于**建立对软件质量的信心**以及对发布和部署做出明智决策至关重要。

在[自动化测试](../A/automated-testing.md)中，捕获实际结果通常由自动化框架处理，该框架记录结果以供后续分析。这种**自动化捕获**不仅简化了测试过程，还**减少了人为错误**，确保结果能够一致和准确地报告。

通过专注于实际结果，[测试自动化](../T/test-automation.md)工程师可以**直接影响**软件的开发周期，确保每个发布都符合成功产品所需的质量标准。  

### “实际结果”对整个测试过程有何贡献？

在测试过程中，**实际结果**是至关重要的，因为它直接反映了系统在测试条件下的当前行为。通过将实际结果与[预期结果](../E/expected-result.md)进行比较，测试人员可以立即判断[测试用例](../T/test-case.md)是否通过或失败。这种比较对于验证软件的功能并确保其满足指定要求至关重要。

在[自动化测试](../A/automated-testing.md)中，实际结果通常由[测试脚本](../T/test-script.md)捕获和记录，然后自动将其与[预期结果](../E/expected-result.md)进行比较。这有助于形成快速的反馈循环，快速识别失败，并根据测试结果决定是否继续或中止持续集成和交付流程。

当出现差异时，实际结果是调试的起点。它有助于准确定位缺陷的确切性质，引导开发人员找到根本原因。此外，分析跨多次测试运行的实际结果中的模式可以揭示出诸如性能下降或应用程序特定区域的不稳定性等更大问题。

总之，实际结果对于：

- **验证**软件行为是否符合期望。
- 在测试脚本中进行**自动化**通过/失败决策。
- 通过提供系统行为的具体证据进行**调试**。
- 分析**趋势和模式**以指导未来的开发和测试工作。

通过有效利用实际结果，团队可以保持较高的[软件质量](../S/software-quality.md)并加速开发生命周期。

## 比较与对比

### “预期结果”和“实际结果”有什么区别？

在软件[测试自动化](../T/test-automation.md)中，**[预期结果](../E/expected-result.md)**是基于需求或设计规范的[测试用例](../T/test-case.md)的预定义结果。它代表了系统在特定条件下应该表现出的行为。

另一方面，**实际结果**是系统在执行[测试用例](../T/test-case.md)时实际表现出的行为。它是从被测试系统中获得的实时结果。

预期结果和实际结果之间的比较对于确定[测试用例](../T/test-case.md)的成功或失败至关重要。匹配表示系统表现如预期，而不匹配可能揭示缺陷或与预期行为的偏差。这种比较通常在[测试脚本](../T/test-script.md)中自动化进行，其中使用断言或检查点来验证实际结果是否与[预期结果](../E/expected-result.md)一致。

这些结果之间的差异会触发进一步的调查，以了解根本原因并纠正任何问题，确保软件符合其质量标准。

### “实际结果”与“测试用例”有何关系？

在**[测试用例](../T/test-case.md)**的情境下，**实际结果**是测试执行时所观察到的结果。它直接与**[预期结果](../E/expected-result.md)**进行比较，以确定测试是否通过或失败。这种比较对于验证被测试软件的行为至关重要。

对于自动化测试，**实际结果**通常由[测试脚本](../T/test-script.md)本身捕获。例如，在基于[Selenium](../S/selenium.md)的测试中，脚本可能包含如下断言：

```javascript
assert.equal(element.getText(), "Expected Text");
```

这里，`element.getText()`是与预期文本进行比较的**实际结果**。如果它们匹配，测试通过；否则，测试失败。

**实际结果**对于准确定位**[测试用例](../T/test-case.md)**中故障发生的确切步骤至关重要。在复杂的场景中，它有助于将缺陷隔离到特定的模块或功能。此外，当测试失败时，**实际结果**可以深入了解[缺陷](../B/bug.md)的性质，有助于调试和解决问题。

在持续集成环境中，**实际结果**通常被记录并作为[测试报告](../T/test-report.md)的一部分。这对于利益相关者了解软件的当前状态以及开发人员在发布软件之前解决任何问题非常有价值。

### 在什么情况下“实际结果”可能与“预期结果”不同？

**实际结果**与**[预期结果](../E/expected-result.md)**之间可能存在差异的原因有很多：

- **代码缺陷**：应用代码中的错误可能导致意外行为。
- **环境问题**：测试环境的差异，如配置、数据库或网络条件的不同。
- **[测试数据](../T/test-data.md)的变化性**：不一致或不正确的测试数据可能导致不同的结果。
- **[不稳定的测试](../F/flaky-test.md)**：表现出非确定性行为的测试通常会间歇性地失败。
- **错误的期望**：预期结果可能基于过时或被误解的需求。
- **并发问题**：仅在多个进程或用户同时与系统交互时才显现的问题。
- **集成依赖**：应用程序依赖的外部服务或组件的故障。
- **时间问题**：影响应用程序行为的竞态条件或超时。
- **平台特定行为**：不同操作系统、浏览器或设备处理某些操作的方式的差异。
- **[测试脚本](../T/test-script.md)错误**：自动化脚本本身中的错误，如不正确的断言或同步问题。

识别差异的原因对于解决问题和提高[软件质量](../S/software-quality.md)至关重要。

## 实际应用

### 测试过程中如何记录“实际结果”？

在测试过程中记录**实际结果**通常包括对测试执行后系统行为的清晰而简明的描述。它记录在[测试管理](../T/test-management.md)工具或[测试用例](../T/test-case.md)文档中，通常与相应的**[测试用例](../T/test-case.md)**和**[预期结果](../T/expected-result.md)**一起，以便进行轻松比较。

以下是一般的方法：

1. **执行[测试用例](../T/test-case.md)**：按照规定的步骤运行测试。
2. **观察**：仔细观察系统的行为或输出。
3. **记录**：立即记录观察到的行为。使用清晰的语言描述发生了什么，包括任何错误消息、系统响应或结果。
4. **截图/日志**：如果截图、日志文件或视频能够清晰地说明问题，特别是对于界面问题或复杂错误，请附加它们。
5. **时间戳**：记录测试的时间和日期，因为这对于调试可能是至关重要的。
6. **环境详细信息**：包括有关测试环境的详细信息，如浏览器版本、设备或系统配置。
7. **可重现性**：指示结果在重新测试时是否一致。
8. **链接缺陷**：如果结果表示存在缺陷，请创建缺陷报告并将其链接到测试用例，以实现可追溯性。

确保**实际结果**足够详细，以使开发人员能够清楚地理解问题，避免歧义，促进更快的解决和[重新测试](../R/retesting.md)。

### 有哪些常用工具或方法可用于获取 "实际结果"？

在[测试自动化](../T/test-automation.md)中捕获**实际结果**通常涉及多种工具和方法：

- **自动化[测试脚本](../T/test-script.md)**：在诸如**[Selenium](../S/selenium)**、**[Cypress](../C/cypress.md)**或**Appium**等框架中编写的脚本在[测试执行](../T/test-execution.md)期间自动捕获输出。例如：

```javascript
// 示例：使用 Selenium 进行文本验证
String actualText = driver.findElement(By.id("elementId")).getText();
```

- **日志记录**：通常，自动化测试被设计为记录结果和错误。诸如 Java 的**Log4j**或[Node.js](../N/node-js.md)的**Winston**之类的工具可用于记录实际结果。

- **截图**：诸如**[Selenium](../S/selenium.md)**之类的工具可以在执行测试步骤时捕获应用程序状态的截图，这对于 UI 测试很有用。

- **视频录制**：一些测试框架，如**TestCafe**或云服务如**Sauce Labs**，提供视频录制功能以捕获[测试执行](../T/test-execution.md)。

- **[API](../A/api.md)响应**：对于[API 测试](../A/api-testing.md)，诸如**[Postman](../P/postman.md)**或**RestAssured**之类的工具捕获 HTTP 响应数据，这代表了实际结果。

- **性能数据**：诸如**[JMeter](../J/jmeter.md)**或**Gatling**之类的工具捕获时间和吞吐量数据作为实际结果进行[性能测试](../P/performance-testing.md)。

- **[测试报告](../T/test-report.md)**：诸如**JUnit**、**TestNG**或**Mocha**之类的框架生成包含实际结果的报告。这些报告可以进一步与**Jenkins**或**GitLab CI**等 CI/CD 工具集成，以进行全面的报告。

- **自定义处理程序**：在测试代码中实现自定义事件处理程序或回调，以捕获特定的数据点或应用程序状态。

- **[数据库](../D/database.md)验证**：使用[SQL](../S/sql.md)或 NoSQL 命令直接查询[数据库](../D/database.md)以捕获数据更改。

- **文件输出**：将结果写入文件，如 CSV 或 JSON

，以便以后解析和分析。

每种方法的选择基于需要捕获的内容的**上下文**和正在执行的测试的**类型**。

### 如何使用 "实际结果 "来识别和诊断软件缺陷或问题？

**实际结果**在识别和排除软件[缺陷](../B/bug.md)方面充当着至关重要的诊断工具。当[测试用例](../T/test-case.md)执行产生一个与[期望结果](../E/expected-result.md)不符的实际结果时，这种差异标志着软件中可能存在缺陷。

为了诊断问题，工程师会在[测试环境](../T/test-environment.md)和输入数据的背景下分析实际结果。他们可能会查找在不同[测试用例](../T/test-case.md)或条件下结果的模式或不一致性。例如，如果某个功能在一个输入集下按预期工作，而在另一个输入集下却没有，这可能表明存在边界情况问题或数据处理[缺陷](../B/bug.md)。

工程师还使用实际结果来准确定位故障发生的确切步骤。通过检查应用程序在此时的状态，包括日志、堆栈跟踪或[数据库](../D/database.md)状态，他们可以确定故障的根本原因。

在实际结果表明存在性能问题（例如响应时间较慢或资源瓶颈）的情况下，工程师可以使用性能分析工具深入挖掘系统在测试时的行为。

[自动化测试](../A/automated-testing.md)框架通常提供捕获和报告详细实际结果的功能，包括[测试执行](../T/test-execution.md)的截图或视频录制，这对于诊断 UI 问题非常有价值。

通过系统地分析实际结果，工程师可以提出关于[缺陷](../B/bug.md)来源的假设，然后进行

测试和验证，从而实现更高效的[缺陷](../B/bug.md)修复流程。

## 深层理解

### “实际结果”如何影响回归测试？

在[回归测试](../R/regression-testing.md)中，**实际结果**对于验证最近的代码更改是否对现有功能产生不良影响至关重要。它是在软件被修改后[测试用例](../T/test-case.md)的结果。通过将**实际结果**与**[期望结果](../E/expected-result.md)**进行比较，测试人员可以确定是否发生了回归错误。

对于自动化回归测试，**实际结果**通常由[测试脚本](../T/test-script.md)捕获，并与**[期望结果](../E/expected-result.md)**进行程序化比较。差异会触发测试失败，提醒工程师可能存在回归。这种比较通常通过测试代码中的断言完成。

```typescript
assert.equal(actualResult, expectedResult, 'The actual result does not match the expected result.');
```

当**实际结果**与**[期望结果](../E/expected-result.md)**匹配时，表明应用程序的行为与其先前状态保持一致。相反，不匹配可能表示最近的更改引入了一个缺陷，需要进一步调查和潜在的代码修复。

在持续集成环境中，**实际结果**是反馈循环的一部分，通知开发团队关于每次代码提交后其应用程序稳定性的情况。这种即时反馈对于保持[软件质量](../S/software-quality.md)和加速开发周期至关重要。

具有清晰**实际结果**的自动化回归测试可以快速确定已经发生回归的具体功能，简化调试过程，并确保软件发布符合质量标准。

### “实际结果”在自动化测试中扮演什么角色？

在[自动化测试](../A/automated-testing.md)中，**实际结果**作为验证软件行为是否符合预期结果的关键数据点起着重要作用。这是由[测试脚本](../T/test-script.md)执行时产生的输出。然后，此结果会自动与**[期望结果](../E/expected-result.md)**进行比较，以确定测试是否通过或失败。

```typescript
// 捕获自动化测试中的实际结果的示例
const actualResult = performAction();
assert.equal(actualResult, expectedResult, '测试失败：实际结果与期望结果不匹配。');
```

在自动化[测试场景](../T/test-scenario.md)尤其是复杂场景中，**实际结果**对于确定差异发生的确切步骤至关重要。当测试失败时，**实际结果**立即提供有关失败性质的反馈，使工程师能够在无需手动干预的情况下启动调试和根本原因分析。

自动化测试通常将**实际结果**记录到报告或仪表板中，提供[测试执行](../T/test-execution.md)的历史记录。这有助于趋势分析，并有助于了解软件随时间的稳定性。

在持续集成和部署（CI/CD）管道中，**实际结果**可以触发工作流，如通知、回滚或根据[测试用例](../T/test-case.md)的成功或失败而执行其他[测试套件](../T/test-suite.md)。

总体而言，**实际结果**是[自动化测试](../T/test-automation.md)的基石，以系统化和可扩展的方式推动[质量保证](../Q/quality-assurance.md)流程，从而高效而准确地验证软件功能。

### “实际结果”差异如何有助于软件优化和改进？

**实际结果**与**[期望结果](../E/expected-result.md)**之间的差异对于软件的优化和改进至关重要。当[测试用例](../T/test-case.md)的实际结果偏离预期时，这表明存在潜在的缺陷或需要改进的领域。这些差异可能导致：

- **需求的完善**：不一致性可能揭示需求理解不足或存在漏洞，促使更清晰和精确的规范。
- **代码优化**：在测试中暴露的性能问题或意外行为可以引导开发人员优化算法和重构代码。
- **增强用户体验**：在用户界面或工作流中出现差异的实际结果可能突显出可用性问题，从而引导改进，使软件更直观和用户友好。
- **更好的错误处理**：遇到未在期望结果中考虑的错误或异常可以通过改进错误处理和消息传递来提高软件的健壮性。
- **增加[测试覆盖率](../T/test-coverage.md)**：差异通常揭示了未经测试的路径或边缘情况，扩展了测试套件，实现更全面的覆盖。

通过分析这些差异，团队可以迭代地完善他们的软件，从而打造更可靠、高性能和用户中心的产品。记录和跟踪这些发现是确保它们在未来的开发周期中得到解决的关键。
